{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/chenpt.ico","path":"chenpt.ico","modified":0,"renderable":0},{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"d6b919bd91b828e6e8f36aac19fe6984861b4a3a","modified":1498812400595},{"_id":"source/chenpt.ico","hash":"ce84d63e8b6c6c4899487845ca6c442cc9cb8bc2","modified":1521136782744},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1488216496000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1488216496000},{"_id":"themes/next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1488216496000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1488216496000},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1488216496000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1488216496000},{"_id":"themes/next/.travis.yml","hash":"c42d9608c8c7fe90de7b1581a8dc3886e90c179e","modified":1488216496000},{"_id":"themes/next/README.en.md","hash":"4ece25ee5f64447cd522e54cb0fffd9a375f0bd4","modified":1488216496000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1488216496000},{"_id":"themes/next/_config.yml","hash":"ce5b6f2d8355073190a07640fdea719148aa5391","modified":1521988380608},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1488216496000},{"_id":"themes/next/chenpt.ico","hash":"ce84d63e8b6c6c4899487845ca6c442cc9cb8bc2","modified":1521136782744},{"_id":"themes/next/gulpfile.coffee","hash":"b00e93c5c8667a4fbed71046dc93ce6784bf6257","modified":1488216496000},{"_id":"themes/next/package.json","hash":"a042faed34835a52505643aa2d841cd2dcf5dff6","modified":1488216496000},{"_id":"source/_posts/.aaa.md.swp","hash":"0838520f50f24b600b673427b4b18fa49e3e1b14","modified":1472139484295},{"_id":"source/_posts/2016-summer.md","hash":"f1ddca5af79648cc6c057347cda59b5c9d6e74a7","modified":1500268423645},{"_id":"source/_posts/CscwPage-summary.md","hash":"89392c7cf358b2d75cb06e33ac3b785222b6cb6c","modified":1500268554677},{"_id":"source/_posts/EventEmitter.md","hash":"0e76a437300c5179fc894c857a778418eb667994","modified":1521100253737},{"_id":"source/_posts/Js-Function.md","hash":"e7a7a5a2ac8125bd61e1ff2dcd03c17b476c487e","modified":1500268513053},{"_id":"source/_posts/SSL.md","hash":"629f72bc4a85f12ab467c731fcff468dcb6161fa","modified":1522056932247},{"_id":"source/_posts/Summer-Vacation.md","hash":"457ba98759207b4e187cd88654180a62175c67dc","modified":1502668024616},{"_id":"source/_posts/Ubuntu-install-Shadowsocks.md","hash":"25c127a1a50ffa14aa10899ec8fc565663be2355","modified":1500268380009},{"_id":"source/_posts/canvas.md","hash":"b83f6ee58e16047e49a55cb1ab7bf8a24873e8b4","modified":1499960220130},{"_id":"source/_posts/currying&partial-application.md","hash":"6bdbe37119bbbe3fb9d72343f5e332ddabf7a41a","modified":1500268531417},{"_id":"source/_posts/database.md","hash":"23c63a83d80eeff8fa30fd0eca2fbe1cea44541c","modified":1521100553148},{"_id":"source/_posts/hello-world.md","hash":"44dc1927766435f423e98c22198f8fb7161420c8","modified":1469465556603},{"_id":"source/_posts/hexo-Error.md","hash":"519873d699cceff7d1b56456f2307dfeb07be7e6","modified":1521141893933},{"_id":"source/_posts/in.md","hash":"6ff3c6116fe3d15e116e7f7b7196764f4e29c333","modified":1500364203469},{"_id":"source/_posts/hexo-notes.md","hash":"854987b80d10de1a1ff640dfeeed733a8cd82e10","modified":1500267391612},{"_id":"source/_posts/inherit.md","hash":"51a1da65fc6f2f565b1c7df64bda2b05ab3778ef","modified":1469467370688},{"_id":"source/_posts/process.md","hash":"879ba3e08d4e9b550c74f5575b0df42dc136e3d9","modified":1501420881659},{"_id":"source/_posts/prototype-mode.md","hash":"b179452540db4ac2bfdf284700587072f4ec9c97","modified":1500267421001},{"_id":"source/_posts/second-Monday.md","hash":"5da3435ecc2adbf96923c0dda2db05b330ffb1f7","modified":1500351738761},{"_id":"source/_posts/summer-css3-canvas.md","hash":"1c0aa79bff478d719b84c74a97dd21c8f22736e1","modified":1500268482285},{"_id":"source/_posts/webpack.md","hash":"464aab97b7cafe3b5d52719cb2e56d1fe050bc34","modified":1520867998208},{"_id":"source/_posts/事件流.md","hash":"ce6b423123b17fa729c38767aef088f4361c0765","modified":1520871827607},{"_id":"source/_posts/学习Vue源码（一）.md","hash":"f40fd88754a14d57d3466a4593684e0df747e677","modified":1521736493279},{"_id":"source/_posts/数组去重.md","hash":"9df0c15f87ee719eddc6002b741a2e5ce2490d52","modified":1521365519806},{"_id":"source/about/index.html","hash":"e2f0aaf129f0a940cca2ce17118b8fa2158ebeb1","modified":1521653500254},{"_id":"source/img/avatar.jpg","hash":"ce84d63e8b6c6c4899487845ca6c442cc9cb8bc2","modified":1521137350121},{"_id":"source/categories/index.md","hash":"173c1910f0f22b6c4a4c4996bee598cea09e915d","modified":1468861594241},{"_id":"source/tags/index.md","hash":"d03aab109ed419c2aa968f14c665ecc0df9fbc7c","modified":1468824791397},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1488216496000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1488216496000},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1488216496000},{"_id":"themes/next/languages/default.yml","hash":"95ec5cdfb563854f231b76162a3494f6ecc5bf61","modified":1488216496000},{"_id":"themes/next/languages/en.yml","hash":"95ec5cdfb563854f231b76162a3494f6ecc5bf61","modified":1488216496000},{"_id":"themes/next/languages/fr-FR.yml","hash":"e98f1558347752a20019b71f0b1f9c8be1b34f42","modified":1488216496000},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1488216496000},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1488216496000},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1488216496000},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1488216496000},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1488216496000},{"_id":"themes/next/languages/ru.yml","hash":"5022885d8955e1b91d8841048db272bf99c59a76","modified":1488216496000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"40d01dc46d57f71c2ef635c45b295d4355456e90","modified":1488216496000},{"_id":"themes/next/languages/zh-hk.yml","hash":"19c23d21f262e24c06ee6ddfd51d2a6585304f88","modified":1488216496000},{"_id":"themes/next/languages/zh-tw.yml","hash":"68407799271c78ecc07f03d238257dd8c65ad42d","modified":1488216496000},{"_id":"themes/next/layout/_layout.swig","hash":"2c0c3547a5b470024326a33ae2779d5ee0252266","modified":1521139207248},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1488216496000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1488216496000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1488216496000},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1488216496000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1488216496000},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1488216496000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1488216496000},{"_id":"themes/next/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1488216496000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1488216496000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1488216496000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1488216496000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1488216496000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1488216496000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1488216496000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1488216496000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1488216496000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1488216496000},{"_id":"themes/next/layout/_macro/post.swig","hash":"1ac58a31f8ac76d6e9e810ae3ef2f2597e51ff5d","modified":1521138558332},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b57650032ed47b8bd357ec4dcc02d872fdd0e3e1","modified":1488216496000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1488216496000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"970aa668680896262b1056bb5787fc9ec8754495","modified":1488216496000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1488216496000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1521139130446},{"_id":"themes/next/layout/_partials/head.swig","hash":"a0eafe24d1dae30c790ae35612154b3ffbbd5cce","modified":1488216496000},{"_id":"themes/next/layout/_partials/header.swig","hash":"a1ffbb691dfad3eaf2832a11766e58a179003b8b","modified":1488216496000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1488216496000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1488216496000},{"_id":"themes/next/layout/_partials/search.swig","hash":"7b61e96508df70152b809ea5354236ab7f0d54f4","modified":1488216496000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1488216496000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1488216496000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1488216496000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"4512867d80d9eddfc3a0f5fea3c456f33aa9d522","modified":1488216496000},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1488216496000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"79378f3a1cd90518b07808ed09156a3ab55ffa31","modified":1488216496000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1488216496000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1488216496000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1488216496000},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1488216496000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1488216496000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1488216496000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1488216496000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1488216496000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1488216496000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1488216496000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1488216496000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1488216496000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1488216496000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1488216496000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1488216496000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1488216496000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1488216496000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1488216496000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1488216496000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1488216496000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1488216496000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1488216496000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1488216496000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1488216496000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1488216496000},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1488216496000},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1488216496000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1488216496000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1488216496000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"741f09b2ba4e440011c15f5d288b109b82c87f1b","modified":1488216496000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1488216496000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1488216496000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1488216496000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1488216496000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1488216496000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1488216496000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1488216496000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"e46900412e28f529c26e25e6bada342006435a32","modified":1488216496000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"a279e1881208aff2f669fe235e9661ab825bc540","modified":1488216496000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1488216496000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"ceb39c100c99900294ddee8b1ff81fcaf43873b5","modified":1488216496000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1488216496000},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1488216496000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1488216496000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1488216496000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1488216496000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1488216496000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1488216496000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1488216496000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"06f432f328a5b8a9ef0dbd5301b002aba600b4ce","modified":1488216496000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"e7c76d93605e2b685274400afe51c55cc651486e","modified":1488216496000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"417cbf2f0ff590ec98c8b923f940bf4b38db615f","modified":1521140503862},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1488216496000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"54ca0acff29a414e2c1b7c1790db22f0c775604c","modified":1488216496000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1488216496000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1488216496000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1488216496000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1488216496000},{"_id":"themes/next/source/js/src/post-details.js","hash":"3b2d64c2e6ae072ba2a9ebf7f09908a1543abd58","modified":1488216496000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1488216496000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1488216496000},{"_id":"themes/next/source/js/src/utils.js","hash":"9ff232a2d39a513b811814480502e3eaac429c52","modified":1488216496000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1488216496000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1488216496000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1488216496000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1488216496000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1488216496000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1488216496000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1488216496000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"c1072942459fa0880e8a33a1bd929176b62b4171","modified":1488216496000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1488216496000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1488216496000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1488216496000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1488216496000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1488216496000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1488216496000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1488216496000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1488216496000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1488216496000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1488216496000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1488216496000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1488216496000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1488216496000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1488216496000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1488216496000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1488216496000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1488216496000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1488216496000},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1488216496000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1488216496000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1488216496000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1488216496000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1488216496000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1488216496000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-mta.swig","hash":"a652f202bd5b30c648c228ab8f0e997eb4928e44","modified":1488216496000},{"_id":"themes/next/layout/_scripts/third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1488216496000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1488216496000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1488216496000},{"_id":"themes/next/layout/_scripts/third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1488216496000},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1488216496000},{"_id":"themes/next/layout/_scripts/third-party/comments/livere.swig","hash":"7240f2e5ec7115f8abbbc4c9ef73d4bed180fdc7","modified":1488216496000},{"_id":"themes/next/layout/_scripts/third-party/comments/youyan.swig","hash":"af9dd8a4aed7d06cf47b363eebff48850888566c","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"59ad08bcc6fe9793594869ac2b4c525021453e78","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"ef089a407c90e58eca10c49bc47ec978f96e03ba","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1488216496000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1488216496000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"7804e31c44717c9a9ddf0f8482b9b9c1a0f74538","modified":1488216496000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1488216496000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1488216496000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1488216496000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1488216496000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1488216496000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1488216496000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1488216496000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1488216496000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1488216496000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1488216496000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1488216496000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1488216496000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1488216496000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1488216496000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1488216496000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1488216496000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1488216496000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"f15537cee1a9ef4fa1e72a1670ebce4097db8115","modified":1488216496000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1488216496000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1488216496000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1488216496000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1488216496000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1488216496000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1488216496000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1488216496000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1488216496000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1488216496000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1488216496000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1488216496000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1488216496000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1488216496000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1488216496000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1488216496000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1488216496000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1488216496000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1488216496000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1488216496000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1488216496000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1488216496000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1488216496000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1488216496000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1488216496000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1488216496000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"755b04edbbfbdd981a783edb09c9cc34cb79cea7","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"b9a2e76f019a5941191f1263b54aef7b69c48789","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"bfd806d0a9f21446a22df82ac02e37d0075cc3b5","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a2ec22ef4a6817bbb2abe8660fcd99fe4ca0cc5e","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8fe1e55bc290e6aaf07cc644fe27b62107a272a8","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"173490e21bece35a34858e8e534cf86e34561350","modified":1488216496000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1488216496000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1488216496000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1488216496000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1488216496000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1488216496000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1488216496000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1488216496000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1488216496000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1488216496000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1488216496000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1488216496000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1488216496000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1488216496000},{"_id":"public/tags/index.html","hash":"851970cb5719debe620a58b8c059e88332b67cc5","modified":1522073726713},{"_id":"public/categories/index.html","hash":"848514135e2107e7b9590de48477aec559931279","modified":1522073726715},{"_id":"public/2016/07/26/hello-world/index.html","hash":"e176a42ffb8f94270e12d016703c02a5eef52c64","modified":1522073726716},{"_id":"public/archives/index.html","hash":"23f474045884ac57c41d4796a1d6ac522152cb64","modified":1522073726716},{"_id":"public/archives/page/2/index.html","hash":"7bdc805a0b12e37c57df5b2fc32e2eb9c38fe81c","modified":1522073726716},{"_id":"public/archives/page/3/index.html","hash":"a5d5f37917deda485a5d1fc36e3b93395080b95f","modified":1522073726716},{"_id":"public/archives/page/4/index.html","hash":"a39fbaeed11abc47d2379f855b0be76358bc8612","modified":1522073726716},{"_id":"public/archives/2016/index.html","hash":"488f19ab51a98f46d2aa8404e228fb734b045f30","modified":1522073726716},{"_id":"public/archives/2016/page/2/index.html","hash":"2e5130d2c895f5ba572de321ccb0feaeada99c16","modified":1522073726716},{"_id":"public/archives/2016/07/index.html","hash":"510389cd2dee2385846d5301f33c5bad861ed08c","modified":1522073726716},{"_id":"public/archives/2016/08/index.html","hash":"6a4eaafc8e607728c86b0eff9d966a16ccb66e87","modified":1522073726716},{"_id":"public/archives/2017/index.html","hash":"68fe24875146ffc3a55a361926beb05f8dfd92ed","modified":1522073726716},{"_id":"public/archives/2017/page/2/index.html","hash":"7ca064d45cf327a12a80dd5744b3e0060bd2f1e2","modified":1522073726716},{"_id":"public/archives/2017/07/index.html","hash":"a759141011ae4ed3ece8e3446dbd4412ce507035","modified":1522073726717},{"_id":"public/archives/2017/07/page/2/index.html","hash":"edbb4d05c29e5d907131051fea75a05176ee2c0e","modified":1522073726717},{"_id":"public/archives/2017/08/index.html","hash":"647414492d0a0a0dc21dcd5e33954f18c10474c0","modified":1522073726717},{"_id":"public/archives/2018/index.html","hash":"4921c981a92ea3024f51b050c1f12afa5a547180","modified":1522073726717},{"_id":"public/archives/2018/page/2/index.html","hash":"de7f05842d52aac784da5cce3766af76c6a2057c","modified":1522073726717},{"_id":"public/archives/2018/01/index.html","hash":"86f2ba9010389ad493b4ae85d624f2c5290e8abd","modified":1522073726723},{"_id":"public/archives/2018/03/index.html","hash":"b6f2f89ec730bd8ef42468d519ab276e9786f4f6","modified":1522073726723},{"_id":"public/categories/生活笔记/index.html","hash":"1e5d3caefd38c08c19717617f0351da0f787dc3f","modified":1522073726723},{"_id":"public/categories/项目总结/index.html","hash":"78c4e3a443d0e57870b73fd4f14d04844a9fb4b8","modified":1522073726723},{"_id":"public/categories/JavaScript/index.html","hash":"54918aa0b66d96f78198129bf5fe9183373836b3","modified":1522073726723},{"_id":"public/categories/JavaScript/page/2/index.html","hash":"0ec0b14f3d8b6a4a9efb4f56344709350f7f4e76","modified":1522073726723},{"_id":"public/categories/HTTPS/index.html","hash":"bf86c71518ce77db257160f4dd4d55e612b1acee","modified":1522073726723},{"_id":"public/categories/日常生活/index.html","hash":"fa136b5205943cadab97f92a6a503a5cfdb9c5ef","modified":1522073726723},{"_id":"public/categories/Ubuntu/index.html","hash":"85997435089182e03bffd63033b645a3d50fb6a4","modified":1522073726723},{"_id":"public/categories/HTML-5/index.html","hash":"4318c90d9f9b6dada13f55883ba6e0c920e138c3","modified":1522073726723},{"_id":"public/categories/database/index.html","hash":"265174f2495224fbb2c3ac9e3b94cf41049f5c1a","modified":1522073726723},{"_id":"public/categories/Bug记录/index.html","hash":"79fa5f4ba82f375152be10d696082dae5cfb4426","modified":1522073726724},{"_id":"public/categories/blog笔记/index.html","hash":"a8914630aa71b7cfbf1cded6b8bde19588fd66e7","modified":1522073726724},{"_id":"public/categories/Node-js/index.html","hash":"7bbfa4d8ac237656ad5411e97f937ff1b4e646bd","modified":1522073726724},{"_id":"public/categories/2017暑假/index.html","hash":"7be2933fcb4696d1fab215994bd8a5613a8b121b","modified":1522073726724},{"_id":"public/categories/webpack/index.html","hash":"6278e1ba5396e3ee3d799de069cc4ae55dc93a24","modified":1522073726724},{"_id":"public/categories/Vue/index.html","hash":"c2a8b157aaaefa4752e023a7e55387622624a5e2","modified":1522073726724},{"_id":"public/tags/暑假/index.html","hash":"e9691d0e349caa60d0774b6a6aa290bd932e3181","modified":1522073726724},{"_id":"public/tags/夏令营/index.html","hash":"0daae6ad01a87330f858145ca23e3b62db05d115","modified":1522073726724},{"_id":"public/tags/协同前端组/index.html","hash":"742ec94766879478ef0be9abe3214bf682ff79b6","modified":1522073726724},{"_id":"public/tags/协同主页/index.html","hash":"7182d528010b29e51a43a58617d0ce0053ae2bae","modified":1522073726724},{"_id":"public/tags/总结/index.html","hash":"09a4c27cf1e9e36b7beff13b28910eec46198874","modified":1522073726724},{"_id":"public/tags/JavaScript/index.html","hash":"642fac74a8f01fc6a8a2fb6442794b29bf1a25e2","modified":1522073726724},{"_id":"public/tags/模拟实现/index.html","hash":"2cf9d68d4922e2cbfef5d3afc5252525984dbcff","modified":1522073726724},{"_id":"public/tags/Function/index.html","hash":"12813cacf96b094075578b18a9b57faa0adebf5a","modified":1522073726725},{"_id":"public/tags/HTTPS/index.html","hash":"b1eaad70fc7569378160738885d8542f0a8bd4b3","modified":1522073726725},{"_id":"public/tags/网络/index.html","hash":"1c0f7cca2fd4212e588faf7e1ab52cad7ad6439f","modified":1522073726725},{"_id":"public/tags/Ubuntu/index.html","hash":"d9c4b51ebb55110325cb5158e9080c6406f046b7","modified":1522073726725},{"_id":"public/tags/Shadowsocks/index.html","hash":"651dc40f9c85c2343dea9a550c5c3bd6e1e90750","modified":1522073726725},{"_id":"public/tags/canvas/index.html","hash":"f605aa6cef717751952933182a71c2b6253ea5ce","modified":1522073726725},{"_id":"public/tags/数据库/index.html","hash":"84563c21a85d4abd7b1a33e7fdc95b9637b26363","modified":1522073726725},{"_id":"public/tags/课设/index.html","hash":"db62946a48628ebb112c1e5f227e949cd45486f9","modified":1522073726725},{"_id":"public/tags/hexo/index.html","hash":"5bb5b97c2b133d987823ef70b135188152f5cf58","modified":1522073726728},{"_id":"public/tags/笔记/index.html","hash":"381fb6d085c55ed259f8049bf85bdbf93323051a","modified":1522073726728},{"_id":"public/tags/HTTP缓存/index.html","hash":"d246dd6a70e47a5801959825d0651f21ec949818","modified":1522073726728},{"_id":"public/tags/Object/index.html","hash":"927cf4662e5a4048b0b02906e913cc6c59b9359f","modified":1522073726728},{"_id":"public/tags/继承/index.html","hash":"86666b77a4b655f17c6c30a67326099f336b506d","modified":1522073726728},{"_id":"public/tags/原型模式/index.html","hash":"137fd01b65a2356d8db45d0b87e916ade76b6805","modified":1522073726728},{"_id":"public/tags/2017/index.html","hash":"e8011385f5607d4d92e1f1a4c0a6ee787d6fc4f0","modified":1522073726728},{"_id":"public/tags/前端工程化/index.html","hash":"9942d7e036c838e5dcdaac6e1638a2320af6c96a","modified":1522073726728},{"_id":"public/tags/Vue/index.html","hash":"da2bed07b671f75fe144c5509069b924067cf17d","modified":1522073726728},{"_id":"public/tags/Array/index.html","hash":"d671fca9487d0db243eddcd566c902fb9551acd2","modified":1522073726728},{"_id":"public/tags/Event/index.html","hash":"b339276e13d966affa5c60ce6b9ddfda9ae2d274","modified":1522073726728},{"_id":"public/about/index.html","hash":"b614a2b104e000003e8fd1265f60b8ec8268e55e","modified":1522073726728},{"_id":"public/2018/03/26/SSL/index.html","hash":"b5471a1b87277a5759cf68fdda928b78e01a81f8","modified":1522073726729},{"_id":"public/2018/03/23/学习Vue源码（一）/index.html","hash":"8986cf1bb776444d0d57a97189ec393106d2d1fc","modified":1522073726729},{"_id":"public/2018/03/18/数组去重/index.html","hash":"354a6ac1645b6844efb37cdf0edf3d029e447e5b","modified":1522073726729},{"_id":"public/2018/03/15/hexo-Error/index.html","hash":"cd723ac44fde982ac7e5342f2b6fb1b22889a5d0","modified":1522073726729},{"_id":"public/2018/03/15/EventEmitter/index.html","hash":"924851c35d0294b15266124855f4e08ab6922de0","modified":1522073726729},{"_id":"public/2018/03/12/事件流/index.html","hash":"b68732538667a96ae2ef1a04f0f31fca4a585e0b","modified":1522073726729},{"_id":"public/2018/01/19/database/index.html","hash":"009868498c88da9f6f334090e9d336ec5386e54e","modified":1522073726729},{"_id":"public/2017/08/14/Summer-Vacation/index.html","hash":"8ef853c3ea706f338457d8857e0f326547f29a6c","modified":1522073726729},{"_id":"public/2017/07/30/process/index.html","hash":"199aab275462b9a1e298743b8d3efa5d20c40e82","modified":1522073726729},{"_id":"public/2017/07/25/webpack/index.html","hash":"55c053717cf0cf323141ff5722dfaf106d203601","modified":1522073726729},{"_id":"public/2017/07/18/in/index.html","hash":"dcce49e2e9d78be18eb7c8b7da71620e587676de","modified":1522073726729},{"_id":"public/2017/07/18/second-Monday/index.html","hash":"14d468be7886f134c908e2877c0182eea8dad9f1","modified":1522073726729},{"_id":"public/2017/07/17/Ubuntu-install-Shadowsocks/index.html","hash":"98bf220f8780ddd0059e07f6081838e39bcb4be5","modified":1522073726729},{"_id":"public/2017/07/13/Js-Function/index.html","hash":"9d79ac64a013f35a52a8125c0513b539237d7a78","modified":1522073726729},{"_id":"public/2017/07/12/currying&partial-application/index.html","hash":"e4851b577eb120ec30d4bdb7d6965b246de02679","modified":1522073726729},{"_id":"public/2017/07/11/summer-css3-canvas/index.html","hash":"b29b241b19dc9c38d4b99800ff575d4edb4dd47e","modified":1522073726730},{"_id":"public/2016/08/15/2016-summer/index.html","hash":"d99ec96cf7e47e71508e7cb77905d7fa9f9b0858","modified":1522073726730},{"_id":"public/2016/08/01/CscwPage-summary/index.html","hash":"fa0c8688b7498dc58a5ae68bd2ff966a56198c60","modified":1522073726730},{"_id":"public/2016/07/26/inherit/index.html","hash":"e512f34b1c5a0012925544a3771bf1143f512ec5","modified":1522073726730},{"_id":"public/2016/07/26/canvas/index.html","hash":"6377ae74a6783fbb3e4da6bd63d03be7a7952327","modified":1522073726730},{"_id":"public/2016/07/26/prototype-mode/index.html","hash":"7f2b1aa638f8463d34c3493fe47c75c7ff9e6440","modified":1522073726730},{"_id":"public/2016/07/25/hexo-notes/index.html","hash":"be727ea19cb7fb78180652f2b3be025a4e43c854","modified":1522073726730},{"_id":"public/index.html","hash":"065c476fc04106f5ce34b06d3540b9f47c6817c8","modified":1522073726730},{"_id":"public/page/2/index.html","hash":"60df57d12b8f65e6efd5dc12d27ddfbdb664f9d0","modified":1522073726730},{"_id":"public/page/3/index.html","hash":"cbdf739f69d9999552af3153f29dfb32c762a6c6","modified":1522073726730},{"_id":"public/page/4/index.html","hash":"be3ed3c9a9d2d787381a29a5a332a04986853d31","modified":1522073726730},{"_id":"public/CNAME","hash":"d6b919bd91b828e6e8f36aac19fe6984861b4a3a","modified":1522056943743},{"_id":"public/chenpt.ico","hash":"ce84d63e8b6c6c4899487845ca6c442cc9cb8bc2","modified":1522056943743},{"_id":"public/img/avatar.jpg","hash":"ce84d63e8b6c6c4899487845ca6c442cc9cb8bc2","modified":1522056943744},{"_id":"public/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1522056943744},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1522056943744},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1522056943744},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1522056943744},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1522056943744},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1522056943744},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1522056943744},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1522056943744},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1522056943744},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1522056943744},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1522056943744},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1522056943744},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1522056943744},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1522056943744},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1522056943744},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1522056943744},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1522056943744},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1522056943745},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1522056943745},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1522056943745},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1522056943745},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1522056943745},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1522056943745},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1522056943745},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1522056944644},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1522056944650},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1522056944654},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1522056944654},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1522056944681},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1522056944681},{"_id":"public/js/src/algolia-search.js","hash":"54ca0acff29a414e2c1b7c1790db22f0c775604c","modified":1522056944681},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1522056944681},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1522056944681},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1522056944681},{"_id":"public/js/src/utils.js","hash":"9ff232a2d39a513b811814480502e3eaac429c52","modified":1522056944681},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1522056944681},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1522056944681},{"_id":"public/js/src/post-details.js","hash":"3b2d64c2e6ae072ba2a9ebf7f09908a1543abd58","modified":1522056944682},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1522056944682},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1522056944682},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1522056944682},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1522056944682},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1522056944683},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1522056944683},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1522056944683},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1522056944683},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1522056944683},{"_id":"public/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1522056944683},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1522056944683},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1522056944683},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1522056944683},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1522056944684},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1522056944684},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1522056944684},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1522056944684},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1522056944684},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1522056944684},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1522056944684},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1522056944685},{"_id":"public/css/main.css","hash":"e2768161206f038023f6d0fe8baaa2964c1ea098","modified":1522056944685},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1522056944685},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1522056944685},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1522056944685},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1522056944685},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1522056944685},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1522056944685},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1522056944685},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1522056944686},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1522056944686},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1522056944686},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1522056944686},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1522056944711},{"_id":"source/_posts/netlify.md","hash":"958108cdc3e7856ac53b656b75a23832f19042fc","modified":1522073092543},{"_id":"public/2018/03/26/netlify/index.html","hash":"44397918c95bd1cc07d141cbe49997c04f0f41be","modified":1522073726731},{"_id":"public/archives/2018/03/page/2/index.html","hash":"af5d41451d4b3bcb50038f53c6e2e8431fdd2c0a","modified":1522073726731},{"_id":"public/tags/Blog/index.html","hash":"483c4fe42ab11447f172a2e2e81ecc912206e60a","modified":1522073726731}],"Category":[{"name":"生活笔记","_id":"cjf81eh6x0002v4ef3kyrkuso"},{"name":"项目总结","_id":"cjf81eh7h0007v4efz0ilu29t"},{"name":"JavaScript","_id":"cjf81eh7q000cv4efx22cyrx1"},{"name":"HTTPS","_id":"cjf81eh89000nv4ef85ggovjm"},{"name":"日常生活","_id":"cjf81eh8j000vv4efqg8hyebb"},{"name":"Ubuntu","_id":"cjf81eh8t0013v4ef6fp77pbb"},{"name":"HTML 5","_id":"cjf81eh910019v4efqmjisdd4"},{"name":"database","_id":"cjf81eh9b001hv4ef7lbwhngz"},{"name":"Bug记录","_id":"cjf81eh9c001lv4ef4arqc0xs"},{"name":"blog笔记","_id":"cjf81eh9f001rv4efim1l1jzz"},{"name":"Node.js","_id":"cjf81eh9i001uv4eftdtszu4b"},{"name":"2017暑假","_id":"cjf81eh9k001zv4efdbi07dfg"},{"name":"webpack","_id":"cjf81eh9n0022v4efa5pl9tm9"},{"name":"Vue","_id":"cjf81ehhq0038v4efmv678fgw"}],"Data":[],"Page":[{"_content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n    <style>\n              \n    </style>\n</head>\n<body>\n    <h1>click the blank</h1>\n    <canvas id=\"bg\" width=\"650\" height=\"450\"></canvas>\n</body>\n    <script>\n        var canvas = document.getElementById(\"bg\");\n        var ctx = canvas.getContext('2d');\n        var percent = 0;\n        var ball = {\n            radius: 15,\n            x: 30,\n            y: 30,\n            color: 'rgb(247,99,10)'\n        }\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = '#000'\n        \n\n        function animate(startX,startY) { \n            ctx.clearRect( 0, 0, 800, 800 );\n            end = drawStands(100,80,500,100,20);\n            ctx.beginPath();\n            drawCurvePath( \n                ctx,\n                [startX,startY],\n                end,\n                0.5,\n                percent\n            );\n            ctx.stroke();\n\n            percent = ( percent + 1 ) % 100;\n            ctx.closePath();\n            \n        }\n        function test (e) {\n            var a = animate.bind(null,e.offsetX,e.offsetY)\n            for(let i = 1; i<=100; i++) {\n                var timer = setTimeout(a,i*11);\n            }   \n        }\n        canvas.addEventListener('click',throttle(test));\n\n        function throttle(fn) {\n            let canRun = true;\n            return function() {\n                if(!canRun) return;\n                canRun = false;\n                fn.apply(this,arguments);\n                setTimeout(() => {\n                    canRun = true;\n                },1100)\n            }\n        }\n        animate();\n        /**\n        *   width:球板的宽度\n        *   height: 球板的高度\n        *   startX: 起点X值\n        *   startX: 起点Y值\n        *   angle:  球板的角度（平行四边形的角度）\n        */\n\n        function drawBall(ball) {\n            ctx.fillStyle = ball.color;\n            ctx.arc(ball.x, ball.y,ball.radius, 0, Math.PI*2);\n            ctx.fill();\n            ctx.closePath();\n        }\n\n        function drawStands(width, height, startX, startY, angle) {\n                var mh = width * Math.sin(Math.PI/180 * angle),\n                    mw = width * Math.cos(Math.PI/180 * angle),\n                    result;\n\n                var circle_x_radius = width/4,  //椭圆X轴半径\n                    circle_y_radius = circle_x_radius/2,    //椭圆Y轴半径\n                    temp = 5,   //用来决定杆子的宽度,与球板的下面的中心点比较.\n                    ganHeight = width;   //球架的杆子的高度.\n\n                //绘制球板\n                ctx.save();\n                ctx.strokeStyle = '#555';\n                ctx.lineWidth = 2;\n                ctx.beginPath();\n                ctx.moveTo(startX,startY);\n                ctx.lineTo(startX, height+startY);\n                ctx.lineTo(width+startX, height+ mh+startY);\n                ctx.lineTo(width+startX, mh+startY);\n                ctx.lineTo(startX,startY);\n                ctx.stroke();\n                ctx.closePath();\n                ctx.restore();\n                \n                //绘制球框\n                BezierEllipse1(ctx, mw/2+startX-2-circle_x_radius/2, mh/2+startY+height+circle_y_radius-10, circle_x_radius+5, circle_y_radius+2)\n            \n                //球架的杆\n                ctx.save();\n                ctx.beginPath();\n                ctx.strokeStyle = \"#000\";\n                ctx.lineWidth = 1.5;\n                ctx.moveTo(mw/2+startX-temp, mh/2+startY+height-Math.tan(Math.PI/180 * angle)*temp);\n                ctx.lineTo(mw/2+startX-temp, mh/2+startY+height+ganHeight-Math.tan(Math.PI/180 * angle)*temp);\n                ctx.lineTo(mw/2+startX+temp, mh/2+startY+height+ganHeight+Math.tan(Math.PI/180 * angle)*temp);\n                ctx.lineTo(mw/2+startX+temp,mh/2+startY+height+Math.tan(Math.PI/180 * angle)*temp);\n                ctx.stroke();\n                ctx.closePath();\n                ctx.restore()\n\n                //模拟球的轨迹\n                // ctx.moveTo(40,300);\n                // ctx.quadraticCurveTo((mw/2+startX-2-circle_x_radius/2+30)/2,40,mw/2+startX-2-circle_x_radius/2,mh/2+startY+height+circle_y_radius-10);\n                // ctx.stroke();\n                // ctx.save();\n\n                return result = [mw/2+startX-2-circle_x_radius/2, mh/2+startY+height+circle_y_radius-10];\n        }\n            //网上找的利用贝塞尔曲线来画椭圆的方法.\n        function BezierEllipse1(context, x, y, a, b){\n            //关键是bezierCurveTo中两个控制点的设置\n            //0.5和0.6是两个关键系数（在本函数中为试验而得）\n            var ox = 0.5 * a,\n                oy = 0.6 * b;\n            \n            context.save();\n            context.strokeStyle = \"red\"\n            context.lineWidth = 2.5;\n            context.translate(x, y);\n            context.beginPath();\n            //从椭圆纵轴下端开始逆时针方向绘制\n            context.moveTo(0, b); \n            context.bezierCurveTo(ox, b, a, oy, a, 0);\n            context.bezierCurveTo(a, -oy, ox, -b, 0, -b);\n            context.bezierCurveTo(-ox, -b, -a, -oy, -a, 0);\n            context.bezierCurveTo(-a, oy, -ox, b, 0, b);\n            context.closePath();\n            context.stroke();\n            context.restore();\n            \n        };\n\n        /**\n        * 绘制一条曲线路径\n        * @param  {Object} ctx canvas渲染上下文\n        * @param  {Array<number>} start 起点\n        * @param  {Array<number>} end 终点\n        * @param  {number} curveness 曲度(0-1)\n        * @param  {number} percent 绘制百分比(0-100)\n        */\n\n        function drawCurvePath( ctx, start, end, curveness, percent ) {\n\n            var cp = [\n                ( start[ 0 ] + end[ 0 ] ) / 2 - ( start[ 1 ] - end[ 1 ] ) * curveness,\n                ( start[ 1 ] + end[ 1 ] ) / 2 - ( end[ 0 ] - start[ 0 ] ) * curveness\n            ];\n            //cp为二次贝塞尔曲线的控制点.\n            \n            var t = percent / 80;\n            \n            var p0 = start; //起点\n            var p1 = cp;    \n            var p2 = end;\n            \n            var v01 = [ p1[ 0 ] - p0[ 0 ], p1[ 1 ] - p0[ 1 ] ];     // 向量<p0, p1>\n            var v12 = [ p2[ 0 ] - p1[ 0 ], p2[ 1 ] - p1[ 1 ] ];     // 向量<p1, p2>\n        \n            var q0 = [ p0[ 0 ] + v01[ 0 ] * t, p0[ 1 ] + v01[ 1 ] * t ];\n            var q1 = [ p1[ 0 ] + v12[ 0 ] * t, p1[ 1 ] + v12[ 1 ] * t ];\n            \n            var v = [ q1[ 0 ] - q0[ 0 ], q1[ 1 ] - q0[ 1 ] ];       // 向量<q0, q1>\n        \n            var b = [ q0[ 0 ] + v[ 0 ] * t, q0[ 1 ] + v[ 1 ] * t ];\n            \n\n            ball.x = b[0],\n            ball.y = b[1]\n            drawBall(ball);\n\n        \n        }\n\n    </script>\n</html>","source":"about/index.html","raw":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n    <style>\n              \n    </style>\n</head>\n<body>\n    <h1>click the blank</h1>\n    <canvas id=\"bg\" width=\"650\" height=\"450\"></canvas>\n</body>\n    <script>\n        var canvas = document.getElementById(\"bg\");\n        var ctx = canvas.getContext('2d');\n        var percent = 0;\n        var ball = {\n            radius: 15,\n            x: 30,\n            y: 30,\n            color: 'rgb(247,99,10)'\n        }\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = '#000'\n        \n\n        function animate(startX,startY) { \n            ctx.clearRect( 0, 0, 800, 800 );\n            end = drawStands(100,80,500,100,20);\n            ctx.beginPath();\n            drawCurvePath( \n                ctx,\n                [startX,startY],\n                end,\n                0.5,\n                percent\n            );\n            ctx.stroke();\n\n            percent = ( percent + 1 ) % 100;\n            ctx.closePath();\n            \n        }\n        function test (e) {\n            var a = animate.bind(null,e.offsetX,e.offsetY)\n            for(let i = 1; i<=100; i++) {\n                var timer = setTimeout(a,i*11);\n            }   \n        }\n        canvas.addEventListener('click',throttle(test));\n\n        function throttle(fn) {\n            let canRun = true;\n            return function() {\n                if(!canRun) return;\n                canRun = false;\n                fn.apply(this,arguments);\n                setTimeout(() => {\n                    canRun = true;\n                },1100)\n            }\n        }\n        animate();\n        /**\n        *   width:球板的宽度\n        *   height: 球板的高度\n        *   startX: 起点X值\n        *   startX: 起点Y值\n        *   angle:  球板的角度（平行四边形的角度）\n        */\n\n        function drawBall(ball) {\n            ctx.fillStyle = ball.color;\n            ctx.arc(ball.x, ball.y,ball.radius, 0, Math.PI*2);\n            ctx.fill();\n            ctx.closePath();\n        }\n\n        function drawStands(width, height, startX, startY, angle) {\n                var mh = width * Math.sin(Math.PI/180 * angle),\n                    mw = width * Math.cos(Math.PI/180 * angle),\n                    result;\n\n                var circle_x_radius = width/4,  //椭圆X轴半径\n                    circle_y_radius = circle_x_radius/2,    //椭圆Y轴半径\n                    temp = 5,   //用来决定杆子的宽度,与球板的下面的中心点比较.\n                    ganHeight = width;   //球架的杆子的高度.\n\n                //绘制球板\n                ctx.save();\n                ctx.strokeStyle = '#555';\n                ctx.lineWidth = 2;\n                ctx.beginPath();\n                ctx.moveTo(startX,startY);\n                ctx.lineTo(startX, height+startY);\n                ctx.lineTo(width+startX, height+ mh+startY);\n                ctx.lineTo(width+startX, mh+startY);\n                ctx.lineTo(startX,startY);\n                ctx.stroke();\n                ctx.closePath();\n                ctx.restore();\n                \n                //绘制球框\n                BezierEllipse1(ctx, mw/2+startX-2-circle_x_radius/2, mh/2+startY+height+circle_y_radius-10, circle_x_radius+5, circle_y_radius+2)\n            \n                //球架的杆\n                ctx.save();\n                ctx.beginPath();\n                ctx.strokeStyle = \"#000\";\n                ctx.lineWidth = 1.5;\n                ctx.moveTo(mw/2+startX-temp, mh/2+startY+height-Math.tan(Math.PI/180 * angle)*temp);\n                ctx.lineTo(mw/2+startX-temp, mh/2+startY+height+ganHeight-Math.tan(Math.PI/180 * angle)*temp);\n                ctx.lineTo(mw/2+startX+temp, mh/2+startY+height+ganHeight+Math.tan(Math.PI/180 * angle)*temp);\n                ctx.lineTo(mw/2+startX+temp,mh/2+startY+height+Math.tan(Math.PI/180 * angle)*temp);\n                ctx.stroke();\n                ctx.closePath();\n                ctx.restore()\n\n                //模拟球的轨迹\n                // ctx.moveTo(40,300);\n                // ctx.quadraticCurveTo((mw/2+startX-2-circle_x_radius/2+30)/2,40,mw/2+startX-2-circle_x_radius/2,mh/2+startY+height+circle_y_radius-10);\n                // ctx.stroke();\n                // ctx.save();\n\n                return result = [mw/2+startX-2-circle_x_radius/2, mh/2+startY+height+circle_y_radius-10];\n        }\n            //网上找的利用贝塞尔曲线来画椭圆的方法.\n        function BezierEllipse1(context, x, y, a, b){\n            //关键是bezierCurveTo中两个控制点的设置\n            //0.5和0.6是两个关键系数（在本函数中为试验而得）\n            var ox = 0.5 * a,\n                oy = 0.6 * b;\n            \n            context.save();\n            context.strokeStyle = \"red\"\n            context.lineWidth = 2.5;\n            context.translate(x, y);\n            context.beginPath();\n            //从椭圆纵轴下端开始逆时针方向绘制\n            context.moveTo(0, b); \n            context.bezierCurveTo(ox, b, a, oy, a, 0);\n            context.bezierCurveTo(a, -oy, ox, -b, 0, -b);\n            context.bezierCurveTo(-ox, -b, -a, -oy, -a, 0);\n            context.bezierCurveTo(-a, oy, -ox, b, 0, b);\n            context.closePath();\n            context.stroke();\n            context.restore();\n            \n        };\n\n        /**\n        * 绘制一条曲线路径\n        * @param  {Object} ctx canvas渲染上下文\n        * @param  {Array<number>} start 起点\n        * @param  {Array<number>} end 终点\n        * @param  {number} curveness 曲度(0-1)\n        * @param  {number} percent 绘制百分比(0-100)\n        */\n\n        function drawCurvePath( ctx, start, end, curveness, percent ) {\n\n            var cp = [\n                ( start[ 0 ] + end[ 0 ] ) / 2 - ( start[ 1 ] - end[ 1 ] ) * curveness,\n                ( start[ 1 ] + end[ 1 ] ) / 2 - ( end[ 0 ] - start[ 0 ] ) * curveness\n            ];\n            //cp为二次贝塞尔曲线的控制点.\n            \n            var t = percent / 80;\n            \n            var p0 = start; //起点\n            var p1 = cp;    \n            var p2 = end;\n            \n            var v01 = [ p1[ 0 ] - p0[ 0 ], p1[ 1 ] - p0[ 1 ] ];     // 向量<p0, p1>\n            var v12 = [ p2[ 0 ] - p1[ 0 ], p2[ 1 ] - p1[ 1 ] ];     // 向量<p1, p2>\n        \n            var q0 = [ p0[ 0 ] + v01[ 0 ] * t, p0[ 1 ] + v01[ 1 ] * t ];\n            var q1 = [ p1[ 0 ] + v12[ 0 ] * t, p1[ 1 ] + v12[ 1 ] * t ];\n            \n            var v = [ q1[ 0 ] - q0[ 0 ], q1[ 1 ] - q0[ 1 ] ];       // 向量<q0, q1>\n        \n            var b = [ q0[ 0 ] + v[ 0 ] * t, q0[ 1 ] + v[ 1 ] * t ];\n            \n\n            ball.x = b[0],\n            ball.y = b[1]\n            drawBall(ball);\n\n        \n        }\n\n    </script>\n</html>","date":"2018-03-21T17:31:40.254Z","updated":"2018-03-21T17:31:40.254Z","path":"about/index.html","title":"","comments":1,"layout":"page","_id":"cjf81ehhb0035v4ef09srwdfv","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n    <style>\n              \n    </style>\n</head>\n<body>\n    <h1>click the blank</h1>\n    <canvas id=\"bg\" width=\"650\" height=\"450\"></canvas>\n</body>\n    <script>\n        var canvas = document.getElementById(\"bg\");\n        var ctx = canvas.getContext('2d');\n        var percent = 0;\n        var ball = {\n            radius: 15,\n            x: 30,\n            y: 30,\n            color: 'rgb(247,99,10)'\n        }\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = '#000'\n        \n\n        function animate(startX,startY) { \n            ctx.clearRect( 0, 0, 800, 800 );\n            end = drawStands(100,80,500,100,20);\n            ctx.beginPath();\n            drawCurvePath( \n                ctx,\n                [startX,startY],\n                end,\n                0.5,\n                percent\n            );\n            ctx.stroke();\n\n            percent = ( percent + 1 ) % 100;\n            ctx.closePath();\n            \n        }\n        function test (e) {\n            var a = animate.bind(null,e.offsetX,e.offsetY)\n            for(let i = 1; i<=100; i++) {\n                var timer = setTimeout(a,i*11);\n            }   \n        }\n        canvas.addEventListener('click',throttle(test));\n\n        function throttle(fn) {\n            let canRun = true;\n            return function() {\n                if(!canRun) return;\n                canRun = false;\n                fn.apply(this,arguments);\n                setTimeout(() => {\n                    canRun = true;\n                },1100)\n            }\n        }\n        animate();\n        /**\n        *   width:球板的宽度\n        *   height: 球板的高度\n        *   startX: 起点X值\n        *   startX: 起点Y值\n        *   angle:  球板的角度（平行四边形的角度）\n        */\n\n        function drawBall(ball) {\n            ctx.fillStyle = ball.color;\n            ctx.arc(ball.x, ball.y,ball.radius, 0, Math.PI*2);\n            ctx.fill();\n            ctx.closePath();\n        }\n\n        function drawStands(width, height, startX, startY, angle) {\n                var mh = width * Math.sin(Math.PI/180 * angle),\n                    mw = width * Math.cos(Math.PI/180 * angle),\n                    result;\n\n                var circle_x_radius = width/4,  //椭圆X轴半径\n                    circle_y_radius = circle_x_radius/2,    //椭圆Y轴半径\n                    temp = 5,   //用来决定杆子的宽度,与球板的下面的中心点比较.\n                    ganHeight = width;   //球架的杆子的高度.\n\n                //绘制球板\n                ctx.save();\n                ctx.strokeStyle = '#555';\n                ctx.lineWidth = 2;\n                ctx.beginPath();\n                ctx.moveTo(startX,startY);\n                ctx.lineTo(startX, height+startY);\n                ctx.lineTo(width+startX, height+ mh+startY);\n                ctx.lineTo(width+startX, mh+startY);\n                ctx.lineTo(startX,startY);\n                ctx.stroke();\n                ctx.closePath();\n                ctx.restore();\n                \n                //绘制球框\n                BezierEllipse1(ctx, mw/2+startX-2-circle_x_radius/2, mh/2+startY+height+circle_y_radius-10, circle_x_radius+5, circle_y_radius+2)\n            \n                //球架的杆\n                ctx.save();\n                ctx.beginPath();\n                ctx.strokeStyle = \"#000\";\n                ctx.lineWidth = 1.5;\n                ctx.moveTo(mw/2+startX-temp, mh/2+startY+height-Math.tan(Math.PI/180 * angle)*temp);\n                ctx.lineTo(mw/2+startX-temp, mh/2+startY+height+ganHeight-Math.tan(Math.PI/180 * angle)*temp);\n                ctx.lineTo(mw/2+startX+temp, mh/2+startY+height+ganHeight+Math.tan(Math.PI/180 * angle)*temp);\n                ctx.lineTo(mw/2+startX+temp,mh/2+startY+height+Math.tan(Math.PI/180 * angle)*temp);\n                ctx.stroke();\n                ctx.closePath();\n                ctx.restore()\n\n                //模拟球的轨迹\n                // ctx.moveTo(40,300);\n                // ctx.quadraticCurveTo((mw/2+startX-2-circle_x_radius/2+30)/2,40,mw/2+startX-2-circle_x_radius/2,mh/2+startY+height+circle_y_radius-10);\n                // ctx.stroke();\n                // ctx.save();\n\n                return result = [mw/2+startX-2-circle_x_radius/2, mh/2+startY+height+circle_y_radius-10];\n        }\n            //网上找的利用贝塞尔曲线来画椭圆的方法.\n        function BezierEllipse1(context, x, y, a, b){\n            //关键是bezierCurveTo中两个控制点的设置\n            //0.5和0.6是两个关键系数（在本函数中为试验而得）\n            var ox = 0.5 * a,\n                oy = 0.6 * b;\n            \n            context.save();\n            context.strokeStyle = \"red\"\n            context.lineWidth = 2.5;\n            context.translate(x, y);\n            context.beginPath();\n            //从椭圆纵轴下端开始逆时针方向绘制\n            context.moveTo(0, b); \n            context.bezierCurveTo(ox, b, a, oy, a, 0);\n            context.bezierCurveTo(a, -oy, ox, -b, 0, -b);\n            context.bezierCurveTo(-ox, -b, -a, -oy, -a, 0);\n            context.bezierCurveTo(-a, oy, -ox, b, 0, b);\n            context.closePath();\n            context.stroke();\n            context.restore();\n            \n        };\n\n        /**\n        * 绘制一条曲线路径\n        * @param  {Object} ctx canvas渲染上下文\n        * @param  {Array<number>} start 起点\n        * @param  {Array<number>} end 终点\n        * @param  {number} curveness 曲度(0-1)\n        * @param  {number} percent 绘制百分比(0-100)\n        */\n\n        function drawCurvePath( ctx, start, end, curveness, percent ) {\n\n            var cp = [\n                ( start[ 0 ] + end[ 0 ] ) / 2 - ( start[ 1 ] - end[ 1 ] ) * curveness,\n                ( start[ 1 ] + end[ 1 ] ) / 2 - ( end[ 0 ] - start[ 0 ] ) * curveness\n            ];\n            //cp为二次贝塞尔曲线的控制点.\n            \n            var t = percent / 80;\n            \n            var p0 = start; //起点\n            var p1 = cp;    \n            var p2 = end;\n            \n            var v01 = [ p1[ 0 ] - p0[ 0 ], p1[ 1 ] - p0[ 1 ] ];     // 向量<p0, p1>\n            var v12 = [ p2[ 0 ] - p1[ 0 ], p2[ 1 ] - p1[ 1 ] ];     // 向量<p1, p2>\n        \n            var q0 = [ p0[ 0 ] + v01[ 0 ] * t, p0[ 1 ] + v01[ 1 ] * t ];\n            var q1 = [ p1[ 0 ] + v12[ 0 ] * t, p1[ 1 ] + v12[ 1 ] * t ];\n            \n            var v = [ q1[ 0 ] - q0[ 0 ], q1[ 1 ] - q0[ 1 ] ];       // 向量<q0, q1>\n        \n            var b = [ q0[ 0 ] + v[ 0 ] * t, q0[ 1 ] + v[ 1 ] * t ];\n            \n\n            ball.x = b[0],\n            ball.y = b[1]\n            drawBall(ball);\n\n        \n        }\n\n    </script>\n</html>","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n    <style>\n              \n    </style>\n</head>\n<body>\n    <h1>click the blank</h1>\n    <canvas id=\"bg\" width=\"650\" height=\"450\"></canvas>\n</body>\n    <script>\n        var canvas = document.getElementById(\"bg\");\n        var ctx = canvas.getContext('2d');\n        var percent = 0;\n        var ball = {\n            radius: 15,\n            x: 30,\n            y: 30,\n            color: 'rgb(247,99,10)'\n        }\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = '#000'\n        \n\n        function animate(startX,startY) { \n            ctx.clearRect( 0, 0, 800, 800 );\n            end = drawStands(100,80,500,100,20);\n            ctx.beginPath();\n            drawCurvePath( \n                ctx,\n                [startX,startY],\n                end,\n                0.5,\n                percent\n            );\n            ctx.stroke();\n\n            percent = ( percent + 1 ) % 100;\n            ctx.closePath();\n            \n        }\n        function test (e) {\n            var a = animate.bind(null,e.offsetX,e.offsetY)\n            for(let i = 1; i<=100; i++) {\n                var timer = setTimeout(a,i*11);\n            }   \n        }\n        canvas.addEventListener('click',throttle(test));\n\n        function throttle(fn) {\n            let canRun = true;\n            return function() {\n                if(!canRun) return;\n                canRun = false;\n                fn.apply(this,arguments);\n                setTimeout(() => {\n                    canRun = true;\n                },1100)\n            }\n        }\n        animate();\n        /**\n        *   width:球板的宽度\n        *   height: 球板的高度\n        *   startX: 起点X值\n        *   startX: 起点Y值\n        *   angle:  球板的角度（平行四边形的角度）\n        */\n\n        function drawBall(ball) {\n            ctx.fillStyle = ball.color;\n            ctx.arc(ball.x, ball.y,ball.radius, 0, Math.PI*2);\n            ctx.fill();\n            ctx.closePath();\n        }\n\n        function drawStands(width, height, startX, startY, angle) {\n                var mh = width * Math.sin(Math.PI/180 * angle),\n                    mw = width * Math.cos(Math.PI/180 * angle),\n                    result;\n\n                var circle_x_radius = width/4,  //椭圆X轴半径\n                    circle_y_radius = circle_x_radius/2,    //椭圆Y轴半径\n                    temp = 5,   //用来决定杆子的宽度,与球板的下面的中心点比较.\n                    ganHeight = width;   //球架的杆子的高度.\n\n                //绘制球板\n                ctx.save();\n                ctx.strokeStyle = '#555';\n                ctx.lineWidth = 2;\n                ctx.beginPath();\n                ctx.moveTo(startX,startY);\n                ctx.lineTo(startX, height+startY);\n                ctx.lineTo(width+startX, height+ mh+startY);\n                ctx.lineTo(width+startX, mh+startY);\n                ctx.lineTo(startX,startY);\n                ctx.stroke();\n                ctx.closePath();\n                ctx.restore();\n                \n                //绘制球框\n                BezierEllipse1(ctx, mw/2+startX-2-circle_x_radius/2, mh/2+startY+height+circle_y_radius-10, circle_x_radius+5, circle_y_radius+2)\n            \n                //球架的杆\n                ctx.save();\n                ctx.beginPath();\n                ctx.strokeStyle = \"#000\";\n                ctx.lineWidth = 1.5;\n                ctx.moveTo(mw/2+startX-temp, mh/2+startY+height-Math.tan(Math.PI/180 * angle)*temp);\n                ctx.lineTo(mw/2+startX-temp, mh/2+startY+height+ganHeight-Math.tan(Math.PI/180 * angle)*temp);\n                ctx.lineTo(mw/2+startX+temp, mh/2+startY+height+ganHeight+Math.tan(Math.PI/180 * angle)*temp);\n                ctx.lineTo(mw/2+startX+temp,mh/2+startY+height+Math.tan(Math.PI/180 * angle)*temp);\n                ctx.stroke();\n                ctx.closePath();\n                ctx.restore()\n\n                //模拟球的轨迹\n                // ctx.moveTo(40,300);\n                // ctx.quadraticCurveTo((mw/2+startX-2-circle_x_radius/2+30)/2,40,mw/2+startX-2-circle_x_radius/2,mh/2+startY+height+circle_y_radius-10);\n                // ctx.stroke();\n                // ctx.save();\n\n                return result = [mw/2+startX-2-circle_x_radius/2, mh/2+startY+height+circle_y_radius-10];\n        }\n            //网上找的利用贝塞尔曲线来画椭圆的方法.\n        function BezierEllipse1(context, x, y, a, b){\n            //关键是bezierCurveTo中两个控制点的设置\n            //0.5和0.6是两个关键系数（在本函数中为试验而得）\n            var ox = 0.5 * a,\n                oy = 0.6 * b;\n            \n            context.save();\n            context.strokeStyle = \"red\"\n            context.lineWidth = 2.5;\n            context.translate(x, y);\n            context.beginPath();\n            //从椭圆纵轴下端开始逆时针方向绘制\n            context.moveTo(0, b); \n            context.bezierCurveTo(ox, b, a, oy, a, 0);\n            context.bezierCurveTo(a, -oy, ox, -b, 0, -b);\n            context.bezierCurveTo(-ox, -b, -a, -oy, -a, 0);\n            context.bezierCurveTo(-a, oy, -ox, b, 0, b);\n            context.closePath();\n            context.stroke();\n            context.restore();\n            \n        };\n\n        /**\n        * 绘制一条曲线路径\n        * @param  {Object} ctx canvas渲染上下文\n        * @param  {Array<number>} start 起点\n        * @param  {Array<number>} end 终点\n        * @param  {number} curveness 曲度(0-1)\n        * @param  {number} percent 绘制百分比(0-100)\n        */\n\n        function drawCurvePath( ctx, start, end, curveness, percent ) {\n\n            var cp = [\n                ( start[ 0 ] + end[ 0 ] ) / 2 - ( start[ 1 ] - end[ 1 ] ) * curveness,\n                ( start[ 1 ] + end[ 1 ] ) / 2 - ( end[ 0 ] - start[ 0 ] ) * curveness\n            ];\n            //cp为二次贝塞尔曲线的控制点.\n            \n            var t = percent / 80;\n            \n            var p0 = start; //起点\n            var p1 = cp;    \n            var p2 = end;\n            \n            var v01 = [ p1[ 0 ] - p0[ 0 ], p1[ 1 ] - p0[ 1 ] ];     // 向量<p0, p1>\n            var v12 = [ p2[ 0 ] - p1[ 0 ], p2[ 1 ] - p1[ 1 ] ];     // 向量<p1, p2>\n        \n            var q0 = [ p0[ 0 ] + v01[ 0 ] * t, p0[ 1 ] + v01[ 1 ] * t ];\n            var q1 = [ p1[ 0 ] + v12[ 0 ] * t, p1[ 1 ] + v12[ 1 ] * t ];\n            \n            var v = [ q1[ 0 ] - q0[ 0 ], q1[ 1 ] - q0[ 1 ] ];       // 向量<q0, q1>\n        \n            var b = [ q0[ 0 ] + v[ 0 ] * t, q0[ 1 ] + v[ 1 ] * t ];\n            \n\n            ball.x = b[0],\n            ball.y = b[1]\n            drawBall(ball);\n\n        \n        }\n\n    </script>\n</html>"},{"title":"Tagcloud","date":"2016-07-18T06:18:05.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: Tagcloud\ndate: 2016-07-18 14:18:05\ntype: \"tags\"\ncomments: false\n---\n","updated":"2016-07-18T06:53:11.397Z","path":"tags/index.html","layout":"page","_id":"cjf81ehhn0037v4ef5l8iez1s","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2016-07-18T06:56:57.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-07-18 14:56:57\ntype: \"categories\"\ncomments: false\n---\n","updated":"2016-07-18T17:06:34.241Z","path":"categories/index.html","layout":"page","_id":"cjf81ehhu003bv4ef7mzxvmgp","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"暑假夏令营记录","date":"2016-08-15T12:00:20.000Z","_content":"## 第一天\n7月12号,我那天早上发了一条朋友圈, 早安呀,我的暑假. 寓意着夏令营的开始~ 哝,那天我是最早到的工一414那边的.然后,接下来的日子我几乎都是最晚到的而且压哨居多,哈哈.我有点背,从第一天开始嗓子痛,然后感冒了一个多星期.最后还是靠我的洪荒之力把感冒君从我的身体逼出.\n## 在协同跟大家一起度过的第一个暑假生活\n![](http://i1.buimg.com/567571/2ecde9607d1dacb7.jpg)\n(这张图我们是在工一414上课.)\n一开始小房间是没有空调的,然后过了不久,我们就装了.\n![](http://i1.buimg.com/567571/cb2d97682cf34195.jpg)\n呐,我挺开心的,又认识了一群有趣的人.前三个星期每天早上听课,大二的师兄师姐给我们培训,中午吃完饭回来理学馆玩几局英雄杀或者看下视频,然后午休.实话,在理学馆午休好不舒服,睡得别扭.要不是宿舍远,我会天天回宿舍的~.晚上也就看看书,学习新知识,写笔记. 第二个周六的晚上我们一起看了招魂,-.-bra说我们来看悬疑推理片,恩好的,然而这个是恐怖片,对于片中出现的那些现象都无法解释的.恩,所以bra最后腿毛被我们拔光了.在看片的时候,翔和果都很害怕的样子哈哈哈,一个拿着枕头,一个拿着玩偶挡自己的视线.这个周末也缺席了两位,因为大福和大脸之前早上在过来工作室这边的路上发生了车祸,受伤了,所以她们没来到.大福的脚受伤了,她也从此回家养猪蹄了~,大脸的脚和手也擦伤得蛮严重的.心疼她们.\n![](http://i1.buimg.com/567571/7b6db70cfe3fa856.jpg)\n大家平常就各忙各的,然后到了饭点就会一起去二饭吃饭,-.-,翔每天都是这么的开心,在二饭吃饭的时候经常笑得很逗比哈哈哈,有时叫外卖.中午留在理学馆的,都会到我们大一待的这个房间里面午休.-.-诞生了挺多黑照!?!?(有的图片来自bra之手)\n![](http://i1.buimg.com/567571/bec7d9ee8d71e11f.jpg)\n![](http://i1.buimg.com/567571/9add86f567437d22.jpg)\n![](http://i1.buimg.com/567571/3902ca1c39947176.jpg)\n![](http://i1.buimg.com/567571/bbabb7e12c060f7f.jpg)\n哈哈哈\n\n大家一起去南亭吃饭,喝糖水,一起玩UNO和狼人,说起玩狼人,等到后面再说.满满都是尴尬...\n\n我们还去唱了一次K,哈哈.大家都 very 666.我也过了一下瘾,因为好久没唱K了.\n不知不觉时间也过得挺快,PT焗饭也吃了好多好多次,我们到了最后一周做协同主页的时候了.这个主页由我们的设计师大人,光正还有小白兔负责设计.-.-呐,光正已经被我们用锋利的JQuery劈死了.不过我们得以靠小喵大腿完成那些比较复杂的动画.做这个协同主页,我们也学了很多东西.也体现了我们的团队协作.大家都很棒.大福在家也参与了我们这次任务,她是我们的远程合作伙伴.-.-愉快的一周过去了.我们的主页也差不多了.\n然后我们那天晚上就在玩狼人.我主要任务还是当法官,帮大家组织游戏进行.哎呀,不过我记忆不太好.出了好多错误 哈哈哈哈.我把果姐姐(那一把当守卫,要守卫的人忘了.然后好像狼人恰好杀到了,我又偷偷问了她一次 哈哈.)-.-还有就是女娲被杀死的晚上,我问女巫,女巫请睁眼,今晚死的人是你,你救不救,然后大家都\"哈哈哈哈哈\". 好吧 哈哈,这种情况发生了两次哈哈哈.还有就是大毛和小白兔就是经常当狼人,然后一脸无辜,\"没什么信息\",然后赢到了最后哈哈哈哈.翔,-.-也经常当狼人,不过他当狼人的时候,总是被我们投票出去-.-光正心机,狼人跳别的身份就是他开始带头的.\n## 轰趴之旅\n我们大家来到了一个别墅.恩,那天早上我...手机刚好关机然后闹铃没响,我睡到了中午12点多....然后手机一堆未接来电.我就没有跟大家一起吃午饭,我等到下午直接过去别墅那边了.\n![](http://i4.buimg.com/567571/b75d5f9254d21164.jpg)\n大脸,是我们的厨师.bra也是我们的厨师.毛也是我们的厨师,小白兔,也是我们的厨师.\n主厨还是大脸.\n我们不会煮的只负责吃,当然了,还有帮忙收拾一下吃完的残局.洗碗,收拾垃圾.\n吃完饭就唱唱K,看看电影,玩玩桌面足球.然后大家就又一起愉快的去玩狼人杀了~\n![](http://i1.buimg.com/567571/c6f83883c3ab5a7d.jpg)\n狼人杀充满欢乐哈哈哈,到后面就有点认真玩了~\n光正总是无辜躺枪,经常被第一个票出去.博,是蛮会玩的,然后那天他当狼人,第一个杀了我,然后我是猎人我就顺便带走他,刚好他是狼人 哈哈哈.bra就喜欢盲毒,不过一般都是毒果姐姐,哈哈.小猪和光正总是竞选警长然后好像没当过几次哈哈..心疼.不过我最心疼我自己,那天第二把当狼人,杀了小白兔,然后小白兔是先知,她验了我的身份,说我是狼...好吧.小白兔说什么大家一般都会相信,然后我...就..这样...无情地...被...投票投出去了.要是是别人当先知查我杀,我还可以反过来诬陷一把哈哈哈..不过是小白兔的话我就已经宣布GG了.大毛也因为当狼人的时候不太会演,所以她最后当了法官给我们主持.我当狼人那几把,消费了大家对我的信任,我感到抱歉哈哈,游戏而已哈哈哈.不能当真~~\n大脸也用那些没用到的食材给我们做了夜宵.很满足~~有得吃有得玩\n## 感受\n感谢这个暑假,感谢师兄师姐们,感谢同级的小伙伴们~\n大家都很随和,很nice,很开心认识大家这一群人,相处了小小的一段时间,未来还有更长的路要继续前行,加油.\n","source":"_posts/2016-summer.md","raw":"---\ntitle: 暑假夏令营记录\ndate: 2016-08-15 20:00:20\ncategory: 生活笔记\ntags: [暑假,夏令营,协同前端组]\n---\n## 第一天\n7月12号,我那天早上发了一条朋友圈, 早安呀,我的暑假. 寓意着夏令营的开始~ 哝,那天我是最早到的工一414那边的.然后,接下来的日子我几乎都是最晚到的而且压哨居多,哈哈.我有点背,从第一天开始嗓子痛,然后感冒了一个多星期.最后还是靠我的洪荒之力把感冒君从我的身体逼出.\n## 在协同跟大家一起度过的第一个暑假生活\n![](http://i1.buimg.com/567571/2ecde9607d1dacb7.jpg)\n(这张图我们是在工一414上课.)\n一开始小房间是没有空调的,然后过了不久,我们就装了.\n![](http://i1.buimg.com/567571/cb2d97682cf34195.jpg)\n呐,我挺开心的,又认识了一群有趣的人.前三个星期每天早上听课,大二的师兄师姐给我们培训,中午吃完饭回来理学馆玩几局英雄杀或者看下视频,然后午休.实话,在理学馆午休好不舒服,睡得别扭.要不是宿舍远,我会天天回宿舍的~.晚上也就看看书,学习新知识,写笔记. 第二个周六的晚上我们一起看了招魂,-.-bra说我们来看悬疑推理片,恩好的,然而这个是恐怖片,对于片中出现的那些现象都无法解释的.恩,所以bra最后腿毛被我们拔光了.在看片的时候,翔和果都很害怕的样子哈哈哈,一个拿着枕头,一个拿着玩偶挡自己的视线.这个周末也缺席了两位,因为大福和大脸之前早上在过来工作室这边的路上发生了车祸,受伤了,所以她们没来到.大福的脚受伤了,她也从此回家养猪蹄了~,大脸的脚和手也擦伤得蛮严重的.心疼她们.\n![](http://i1.buimg.com/567571/7b6db70cfe3fa856.jpg)\n大家平常就各忙各的,然后到了饭点就会一起去二饭吃饭,-.-,翔每天都是这么的开心,在二饭吃饭的时候经常笑得很逗比哈哈哈,有时叫外卖.中午留在理学馆的,都会到我们大一待的这个房间里面午休.-.-诞生了挺多黑照!?!?(有的图片来自bra之手)\n![](http://i1.buimg.com/567571/bec7d9ee8d71e11f.jpg)\n![](http://i1.buimg.com/567571/9add86f567437d22.jpg)\n![](http://i1.buimg.com/567571/3902ca1c39947176.jpg)\n![](http://i1.buimg.com/567571/bbabb7e12c060f7f.jpg)\n哈哈哈\n\n大家一起去南亭吃饭,喝糖水,一起玩UNO和狼人,说起玩狼人,等到后面再说.满满都是尴尬...\n\n我们还去唱了一次K,哈哈.大家都 very 666.我也过了一下瘾,因为好久没唱K了.\n不知不觉时间也过得挺快,PT焗饭也吃了好多好多次,我们到了最后一周做协同主页的时候了.这个主页由我们的设计师大人,光正还有小白兔负责设计.-.-呐,光正已经被我们用锋利的JQuery劈死了.不过我们得以靠小喵大腿完成那些比较复杂的动画.做这个协同主页,我们也学了很多东西.也体现了我们的团队协作.大家都很棒.大福在家也参与了我们这次任务,她是我们的远程合作伙伴.-.-愉快的一周过去了.我们的主页也差不多了.\n然后我们那天晚上就在玩狼人.我主要任务还是当法官,帮大家组织游戏进行.哎呀,不过我记忆不太好.出了好多错误 哈哈哈哈.我把果姐姐(那一把当守卫,要守卫的人忘了.然后好像狼人恰好杀到了,我又偷偷问了她一次 哈哈.)-.-还有就是女娲被杀死的晚上,我问女巫,女巫请睁眼,今晚死的人是你,你救不救,然后大家都\"哈哈哈哈哈\". 好吧 哈哈,这种情况发生了两次哈哈哈.还有就是大毛和小白兔就是经常当狼人,然后一脸无辜,\"没什么信息\",然后赢到了最后哈哈哈哈.翔,-.-也经常当狼人,不过他当狼人的时候,总是被我们投票出去-.-光正心机,狼人跳别的身份就是他开始带头的.\n## 轰趴之旅\n我们大家来到了一个别墅.恩,那天早上我...手机刚好关机然后闹铃没响,我睡到了中午12点多....然后手机一堆未接来电.我就没有跟大家一起吃午饭,我等到下午直接过去别墅那边了.\n![](http://i4.buimg.com/567571/b75d5f9254d21164.jpg)\n大脸,是我们的厨师.bra也是我们的厨师.毛也是我们的厨师,小白兔,也是我们的厨师.\n主厨还是大脸.\n我们不会煮的只负责吃,当然了,还有帮忙收拾一下吃完的残局.洗碗,收拾垃圾.\n吃完饭就唱唱K,看看电影,玩玩桌面足球.然后大家就又一起愉快的去玩狼人杀了~\n![](http://i1.buimg.com/567571/c6f83883c3ab5a7d.jpg)\n狼人杀充满欢乐哈哈哈,到后面就有点认真玩了~\n光正总是无辜躺枪,经常被第一个票出去.博,是蛮会玩的,然后那天他当狼人,第一个杀了我,然后我是猎人我就顺便带走他,刚好他是狼人 哈哈哈.bra就喜欢盲毒,不过一般都是毒果姐姐,哈哈.小猪和光正总是竞选警长然后好像没当过几次哈哈..心疼.不过我最心疼我自己,那天第二把当狼人,杀了小白兔,然后小白兔是先知,她验了我的身份,说我是狼...好吧.小白兔说什么大家一般都会相信,然后我...就..这样...无情地...被...投票投出去了.要是是别人当先知查我杀,我还可以反过来诬陷一把哈哈哈..不过是小白兔的话我就已经宣布GG了.大毛也因为当狼人的时候不太会演,所以她最后当了法官给我们主持.我当狼人那几把,消费了大家对我的信任,我感到抱歉哈哈,游戏而已哈哈哈.不能当真~~\n大脸也用那些没用到的食材给我们做了夜宵.很满足~~有得吃有得玩\n## 感受\n感谢这个暑假,感谢师兄师姐们,感谢同级的小伙伴们~\n大家都很随和,很nice,很开心认识大家这一群人,相处了小小的一段时间,未来还有更长的路要继续前行,加油.\n","slug":"2016-summer","published":1,"updated":"2017-07-17T05:13:43.645Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf81eh6e0000v4efm1t4gs23","content":"<h2 id=\"第一天\"><a href=\"#第一天\" class=\"headerlink\" title=\"第一天\"></a>第一天</h2><p>7月12号,我那天早上发了一条朋友圈, 早安呀,我的暑假. 寓意着夏令营的开始~ 哝,那天我是最早到的工一414那边的.然后,接下来的日子我几乎都是最晚到的而且压哨居多,哈哈.我有点背,从第一天开始嗓子痛,然后感冒了一个多星期.最后还是靠我的洪荒之力把感冒君从我的身体逼出.</p>\n<h2 id=\"在协同跟大家一起度过的第一个暑假生活\"><a href=\"#在协同跟大家一起度过的第一个暑假生活\" class=\"headerlink\" title=\"在协同跟大家一起度过的第一个暑假生活\"></a>在协同跟大家一起度过的第一个暑假生活</h2><p><img src=\"http://i1.buimg.com/567571/2ecde9607d1dacb7.jpg\" alt=\"\"><br>(这张图我们是在工一414上课.)<br>一开始小房间是没有空调的,然后过了不久,我们就装了.<br><img src=\"http://i1.buimg.com/567571/cb2d97682cf34195.jpg\" alt=\"\"><br>呐,我挺开心的,又认识了一群有趣的人.前三个星期每天早上听课,大二的师兄师姐给我们培训,中午吃完饭回来理学馆玩几局英雄杀或者看下视频,然后午休.实话,在理学馆午休好不舒服,睡得别扭.要不是宿舍远,我会天天回宿舍的~.晚上也就看看书,学习新知识,写笔记. 第二个周六的晚上我们一起看了招魂,-.-bra说我们来看悬疑推理片,恩好的,然而这个是恐怖片,对于片中出现的那些现象都无法解释的.恩,所以bra最后腿毛被我们拔光了.在看片的时候,翔和果都很害怕的样子哈哈哈,一个拿着枕头,一个拿着玩偶挡自己的视线.这个周末也缺席了两位,因为大福和大脸之前早上在过来工作室这边的路上发生了车祸,受伤了,所以她们没来到.大福的脚受伤了,她也从此回家养猪蹄了~,大脸的脚和手也擦伤得蛮严重的.心疼她们.<br><img src=\"http://i1.buimg.com/567571/7b6db70cfe3fa856.jpg\" alt=\"\"><br>大家平常就各忙各的,然后到了饭点就会一起去二饭吃饭,-.-,翔每天都是这么的开心,在二饭吃饭的时候经常笑得很逗比哈哈哈,有时叫外卖.中午留在理学馆的,都会到我们大一待的这个房间里面午休.-.-诞生了挺多黑照!?!?(有的图片来自bra之手)<br><img src=\"http://i1.buimg.com/567571/bec7d9ee8d71e11f.jpg\" alt=\"\"><br><img src=\"http://i1.buimg.com/567571/9add86f567437d22.jpg\" alt=\"\"><br><img src=\"http://i1.buimg.com/567571/3902ca1c39947176.jpg\" alt=\"\"><br><img src=\"http://i1.buimg.com/567571/bbabb7e12c060f7f.jpg\" alt=\"\"><br>哈哈哈</p>\n<p>大家一起去南亭吃饭,喝糖水,一起玩UNO和狼人,说起玩狼人,等到后面再说.满满都是尴尬…</p>\n<p>我们还去唱了一次K,哈哈.大家都 very 666.我也过了一下瘾,因为好久没唱K了.<br>不知不觉时间也过得挺快,PT焗饭也吃了好多好多次,我们到了最后一周做协同主页的时候了.这个主页由我们的设计师大人,光正还有小白兔负责设计.-.-呐,光正已经被我们用锋利的JQuery劈死了.不过我们得以靠小喵大腿完成那些比较复杂的动画.做这个协同主页,我们也学了很多东西.也体现了我们的团队协作.大家都很棒.大福在家也参与了我们这次任务,她是我们的远程合作伙伴.-.-愉快的一周过去了.我们的主页也差不多了.<br>然后我们那天晚上就在玩狼人.我主要任务还是当法官,帮大家组织游戏进行.哎呀,不过我记忆不太好.出了好多错误 哈哈哈哈.我把果姐姐(那一把当守卫,要守卫的人忘了.然后好像狼人恰好杀到了,我又偷偷问了她一次 哈哈.)-.-还有就是女娲被杀死的晚上,我问女巫,女巫请睁眼,今晚死的人是你,你救不救,然后大家都”哈哈哈哈哈”. 好吧 哈哈,这种情况发生了两次哈哈哈.还有就是大毛和小白兔就是经常当狼人,然后一脸无辜,”没什么信息”,然后赢到了最后哈哈哈哈.翔,-.-也经常当狼人,不过他当狼人的时候,总是被我们投票出去-.-光正心机,狼人跳别的身份就是他开始带头的.</p>\n<h2 id=\"轰趴之旅\"><a href=\"#轰趴之旅\" class=\"headerlink\" title=\"轰趴之旅\"></a>轰趴之旅</h2><p>我们大家来到了一个别墅.恩,那天早上我…手机刚好关机然后闹铃没响,我睡到了中午12点多….然后手机一堆未接来电.我就没有跟大家一起吃午饭,我等到下午直接过去别墅那边了.<br><img src=\"http://i4.buimg.com/567571/b75d5f9254d21164.jpg\" alt=\"\"><br>大脸,是我们的厨师.bra也是我们的厨师.毛也是我们的厨师,小白兔,也是我们的厨师.<br>主厨还是大脸.<br>我们不会煮的只负责吃,当然了,还有帮忙收拾一下吃完的残局.洗碗,收拾垃圾.<br>吃完饭就唱唱K,看看电影,玩玩桌面足球.然后大家就又一起愉快的去玩狼人杀了~<br><img src=\"http://i1.buimg.com/567571/c6f83883c3ab5a7d.jpg\" alt=\"\"><br>狼人杀充满欢乐哈哈哈,到后面就有点认真玩了~<br>光正总是无辜躺枪,经常被第一个票出去.博,是蛮会玩的,然后那天他当狼人,第一个杀了我,然后我是猎人我就顺便带走他,刚好他是狼人 哈哈哈.bra就喜欢盲毒,不过一般都是毒果姐姐,哈哈.小猪和光正总是竞选警长然后好像没当过几次哈哈..心疼.不过我最心疼我自己,那天第二把当狼人,杀了小白兔,然后小白兔是先知,她验了我的身份,说我是狼…好吧.小白兔说什么大家一般都会相信,然后我…就..这样…无情地…被…投票投出去了.要是是别人当先知查我杀,我还可以反过来诬陷一把哈哈哈..不过是小白兔的话我就已经宣布GG了.大毛也因为当狼人的时候不太会演,所以她最后当了法官给我们主持.我当狼人那几把,消费了大家对我的信任,我感到抱歉哈哈,游戏而已哈哈哈.不能当真~~<br>大脸也用那些没用到的食材给我们做了夜宵.很满足~~有得吃有得玩</p>\n<h2 id=\"感受\"><a href=\"#感受\" class=\"headerlink\" title=\"感受\"></a>感受</h2><p>感谢这个暑假,感谢师兄师姐们,感谢同级的小伙伴们~<br>大家都很随和,很nice,很开心认识大家这一群人,相处了小小的一段时间,未来还有更长的路要继续前行,加油.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"第一天\"><a href=\"#第一天\" class=\"headerlink\" title=\"第一天\"></a>第一天</h2><p>7月12号,我那天早上发了一条朋友圈, 早安呀,我的暑假. 寓意着夏令营的开始~ 哝,那天我是最早到的工一414那边的.然后,接下来的日子我几乎都是最晚到的而且压哨居多,哈哈.我有点背,从第一天开始嗓子痛,然后感冒了一个多星期.最后还是靠我的洪荒之力把感冒君从我的身体逼出.</p>\n<h2 id=\"在协同跟大家一起度过的第一个暑假生活\"><a href=\"#在协同跟大家一起度过的第一个暑假生活\" class=\"headerlink\" title=\"在协同跟大家一起度过的第一个暑假生活\"></a>在协同跟大家一起度过的第一个暑假生活</h2><p><img src=\"http://i1.buimg.com/567571/2ecde9607d1dacb7.jpg\" alt=\"\"><br>(这张图我们是在工一414上课.)<br>一开始小房间是没有空调的,然后过了不久,我们就装了.<br><img src=\"http://i1.buimg.com/567571/cb2d97682cf34195.jpg\" alt=\"\"><br>呐,我挺开心的,又认识了一群有趣的人.前三个星期每天早上听课,大二的师兄师姐给我们培训,中午吃完饭回来理学馆玩几局英雄杀或者看下视频,然后午休.实话,在理学馆午休好不舒服,睡得别扭.要不是宿舍远,我会天天回宿舍的~.晚上也就看看书,学习新知识,写笔记. 第二个周六的晚上我们一起看了招魂,-.-bra说我们来看悬疑推理片,恩好的,然而这个是恐怖片,对于片中出现的那些现象都无法解释的.恩,所以bra最后腿毛被我们拔光了.在看片的时候,翔和果都很害怕的样子哈哈哈,一个拿着枕头,一个拿着玩偶挡自己的视线.这个周末也缺席了两位,因为大福和大脸之前早上在过来工作室这边的路上发生了车祸,受伤了,所以她们没来到.大福的脚受伤了,她也从此回家养猪蹄了~,大脸的脚和手也擦伤得蛮严重的.心疼她们.<br><img src=\"http://i1.buimg.com/567571/7b6db70cfe3fa856.jpg\" alt=\"\"><br>大家平常就各忙各的,然后到了饭点就会一起去二饭吃饭,-.-,翔每天都是这么的开心,在二饭吃饭的时候经常笑得很逗比哈哈哈,有时叫外卖.中午留在理学馆的,都会到我们大一待的这个房间里面午休.-.-诞生了挺多黑照!?!?(有的图片来自bra之手)<br><img src=\"http://i1.buimg.com/567571/bec7d9ee8d71e11f.jpg\" alt=\"\"><br><img src=\"http://i1.buimg.com/567571/9add86f567437d22.jpg\" alt=\"\"><br><img src=\"http://i1.buimg.com/567571/3902ca1c39947176.jpg\" alt=\"\"><br><img src=\"http://i1.buimg.com/567571/bbabb7e12c060f7f.jpg\" alt=\"\"><br>哈哈哈</p>\n<p>大家一起去南亭吃饭,喝糖水,一起玩UNO和狼人,说起玩狼人,等到后面再说.满满都是尴尬…</p>\n<p>我们还去唱了一次K,哈哈.大家都 very 666.我也过了一下瘾,因为好久没唱K了.<br>不知不觉时间也过得挺快,PT焗饭也吃了好多好多次,我们到了最后一周做协同主页的时候了.这个主页由我们的设计师大人,光正还有小白兔负责设计.-.-呐,光正已经被我们用锋利的JQuery劈死了.不过我们得以靠小喵大腿完成那些比较复杂的动画.做这个协同主页,我们也学了很多东西.也体现了我们的团队协作.大家都很棒.大福在家也参与了我们这次任务,她是我们的远程合作伙伴.-.-愉快的一周过去了.我们的主页也差不多了.<br>然后我们那天晚上就在玩狼人.我主要任务还是当法官,帮大家组织游戏进行.哎呀,不过我记忆不太好.出了好多错误 哈哈哈哈.我把果姐姐(那一把当守卫,要守卫的人忘了.然后好像狼人恰好杀到了,我又偷偷问了她一次 哈哈.)-.-还有就是女娲被杀死的晚上,我问女巫,女巫请睁眼,今晚死的人是你,你救不救,然后大家都”哈哈哈哈哈”. 好吧 哈哈,这种情况发生了两次哈哈哈.还有就是大毛和小白兔就是经常当狼人,然后一脸无辜,”没什么信息”,然后赢到了最后哈哈哈哈.翔,-.-也经常当狼人,不过他当狼人的时候,总是被我们投票出去-.-光正心机,狼人跳别的身份就是他开始带头的.</p>\n<h2 id=\"轰趴之旅\"><a href=\"#轰趴之旅\" class=\"headerlink\" title=\"轰趴之旅\"></a>轰趴之旅</h2><p>我们大家来到了一个别墅.恩,那天早上我…手机刚好关机然后闹铃没响,我睡到了中午12点多….然后手机一堆未接来电.我就没有跟大家一起吃午饭,我等到下午直接过去别墅那边了.<br><img src=\"http://i4.buimg.com/567571/b75d5f9254d21164.jpg\" alt=\"\"><br>大脸,是我们的厨师.bra也是我们的厨师.毛也是我们的厨师,小白兔,也是我们的厨师.<br>主厨还是大脸.<br>我们不会煮的只负责吃,当然了,还有帮忙收拾一下吃完的残局.洗碗,收拾垃圾.<br>吃完饭就唱唱K,看看电影,玩玩桌面足球.然后大家就又一起愉快的去玩狼人杀了~<br><img src=\"http://i1.buimg.com/567571/c6f83883c3ab5a7d.jpg\" alt=\"\"><br>狼人杀充满欢乐哈哈哈,到后面就有点认真玩了~<br>光正总是无辜躺枪,经常被第一个票出去.博,是蛮会玩的,然后那天他当狼人,第一个杀了我,然后我是猎人我就顺便带走他,刚好他是狼人 哈哈哈.bra就喜欢盲毒,不过一般都是毒果姐姐,哈哈.小猪和光正总是竞选警长然后好像没当过几次哈哈..心疼.不过我最心疼我自己,那天第二把当狼人,杀了小白兔,然后小白兔是先知,她验了我的身份,说我是狼…好吧.小白兔说什么大家一般都会相信,然后我…就..这样…无情地…被…投票投出去了.要是是别人当先知查我杀,我还可以反过来诬陷一把哈哈哈..不过是小白兔的话我就已经宣布GG了.大毛也因为当狼人的时候不太会演,所以她最后当了法官给我们主持.我当狼人那几把,消费了大家对我的信任,我感到抱歉哈哈,游戏而已哈哈哈.不能当真~~<br>大脸也用那些没用到的食材给我们做了夜宵.很满足~~有得吃有得玩</p>\n<h2 id=\"感受\"><a href=\"#感受\" class=\"headerlink\" title=\"感受\"></a>感受</h2><p>感谢这个暑假,感谢师兄师姐们,感谢同级的小伙伴们~<br>大家都很随和,很nice,很开心认识大家这一群人,相处了小小的一段时间,未来还有更长的路要继续前行,加油.</p>\n"},{"title":"CscwPage总结","date":"2016-07-31T16:00:00.000Z","_content":"## 开发前的准备\n在夏令营的最后一个星期，我们进行了这个协同主页的开发。开始之前，我们开了个会商量了一下，然后由大脸写那个评估文档，然后根据设计师的设计稿进行分工。拿到设计稿，博志根据设计师的要求（各个页面切换的效果）定了一个框架，我写了静态的页面，博志写了用于切换的js代码。我们大概的分好工，我写那个导航栏和小组介绍具体详情页面的代码。然后我们各自进行开发。我们也同java组商量那些接口问题。\n\n\n## 利用了版本控制管理工具git进行多人协作\n这也是我真正意义上的一次使用git，也学习了很多，因为不太熟悉，所以也是边学边用，一边看教程，一边学以致用。丰富了自己使用git的经验，也熟悉了多人协作的模式。利用git，可以更好地进行多人协同开发，提高了效率。\n## 使用的框架/工具\n### bootstrap\n我在bootstrap中文文档网学习了一下，然后尝试着利用bootstrap的栅格系统去写我负责的那个页面的整体框架布局。发现这个bootstrap的栅格系统是个蛮方便蛮好用的东西。其主要原理是把整个页面最多分成12列，然后实现的话主要还是给一个百分比的宽度。然后每一列都是浮动的。它分为4种不同屏幕分辨率的写法，有超小屏幕（小于768px），小屏幕（768px到992px），中等屏幕（992px到1200px），大屏幕（1200px）。自己开始写那个页面之前就先把那个页面的框架给描绘出来，先定好框架，直接用bootstrap写成响应式，一步到位。个人感觉这个框架挺好用。\n### animate.css\n这次的动画效果我主要是用css3.根据设计师需要的动画效果，用到了animate.css。里面有很多动画效果。其原理是利用css3的动画，然后把这个动画写到一个类名上，然后利用JS来控制，就是addClass方法，把这个类名添加到你要实现动画的元素上。我没有直接引用一整个animate.css文件，而是去到animate.css的github上找到自己想要的动画的那个代码直接引用到自己的css中，因为我用到里面的动画也不多，所以这样可能会更好。\n### jquery \n主要还是用jquery写需要的js代码。\n也在小喵的帮助下学习了一个新东西。就是模拟操作。之前在书里也看过但是没用过，这次也用到了。\n\n## 开发中遇到的问题和解决方法\nbootstrap 会有许多默认的样式，有时候bootstrap里面的样式会破坏整个的效果，使得呈现的页面跟想要的页面不一样。我到谷歌浏览器的控制台查看然后利用权重值更改元素的css。它也会给你的元素添加一些默认的外边距呀内边距呀，我在做的时候都会跟设计稿有出入，所以我也另外利用css3的媒体查询，写了挺多元素的样式去覆盖掉bootstrap所添加的那些样式。\n还有一个就是这个页面的整体框架问题，我觉得不是最优的，这个也是一开始没有仔细考虑清楚吧。希望以后能够仔细考虑后再确定整体的框架。\n可能还有一些自己没发现的问题，也希望他人帮忙指出。\n\n## 最后结尾\n做这次的协同主页我们大家也踩了许多不大不小的坑，以后需要多注意，也感谢组内小伙伴的帮助和支持。一起加油。\n\n\n\n\n\n\n","source":"_posts/CscwPage-summary.md","raw":"---\ntitle: CscwPage总结\ndate: 2016-08-01\ncategory: 项目总结\ntags: [协同主页,总结]\n---\n## 开发前的准备\n在夏令营的最后一个星期，我们进行了这个协同主页的开发。开始之前，我们开了个会商量了一下，然后由大脸写那个评估文档，然后根据设计师的设计稿进行分工。拿到设计稿，博志根据设计师的要求（各个页面切换的效果）定了一个框架，我写了静态的页面，博志写了用于切换的js代码。我们大概的分好工，我写那个导航栏和小组介绍具体详情页面的代码。然后我们各自进行开发。我们也同java组商量那些接口问题。\n\n\n## 利用了版本控制管理工具git进行多人协作\n这也是我真正意义上的一次使用git，也学习了很多，因为不太熟悉，所以也是边学边用，一边看教程，一边学以致用。丰富了自己使用git的经验，也熟悉了多人协作的模式。利用git，可以更好地进行多人协同开发，提高了效率。\n## 使用的框架/工具\n### bootstrap\n我在bootstrap中文文档网学习了一下，然后尝试着利用bootstrap的栅格系统去写我负责的那个页面的整体框架布局。发现这个bootstrap的栅格系统是个蛮方便蛮好用的东西。其主要原理是把整个页面最多分成12列，然后实现的话主要还是给一个百分比的宽度。然后每一列都是浮动的。它分为4种不同屏幕分辨率的写法，有超小屏幕（小于768px），小屏幕（768px到992px），中等屏幕（992px到1200px），大屏幕（1200px）。自己开始写那个页面之前就先把那个页面的框架给描绘出来，先定好框架，直接用bootstrap写成响应式，一步到位。个人感觉这个框架挺好用。\n### animate.css\n这次的动画效果我主要是用css3.根据设计师需要的动画效果，用到了animate.css。里面有很多动画效果。其原理是利用css3的动画，然后把这个动画写到一个类名上，然后利用JS来控制，就是addClass方法，把这个类名添加到你要实现动画的元素上。我没有直接引用一整个animate.css文件，而是去到animate.css的github上找到自己想要的动画的那个代码直接引用到自己的css中，因为我用到里面的动画也不多，所以这样可能会更好。\n### jquery \n主要还是用jquery写需要的js代码。\n也在小喵的帮助下学习了一个新东西。就是模拟操作。之前在书里也看过但是没用过，这次也用到了。\n\n## 开发中遇到的问题和解决方法\nbootstrap 会有许多默认的样式，有时候bootstrap里面的样式会破坏整个的效果，使得呈现的页面跟想要的页面不一样。我到谷歌浏览器的控制台查看然后利用权重值更改元素的css。它也会给你的元素添加一些默认的外边距呀内边距呀，我在做的时候都会跟设计稿有出入，所以我也另外利用css3的媒体查询，写了挺多元素的样式去覆盖掉bootstrap所添加的那些样式。\n还有一个就是这个页面的整体框架问题，我觉得不是最优的，这个也是一开始没有仔细考虑清楚吧。希望以后能够仔细考虑后再确定整体的框架。\n可能还有一些自己没发现的问题，也希望他人帮忙指出。\n\n## 最后结尾\n做这次的协同主页我们大家也踩了许多不大不小的坑，以后需要多注意，也感谢组内小伙伴的帮助和支持。一起加油。\n\n\n\n\n\n\n","slug":"CscwPage-summary","published":1,"updated":"2017-07-17T05:15:54.677Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf81eh6o0001v4ef7fy5ruwh","content":"<h2 id=\"开发前的准备\"><a href=\"#开发前的准备\" class=\"headerlink\" title=\"开发前的准备\"></a>开发前的准备</h2><p>在夏令营的最后一个星期，我们进行了这个协同主页的开发。开始之前，我们开了个会商量了一下，然后由大脸写那个评估文档，然后根据设计师的设计稿进行分工。拿到设计稿，博志根据设计师的要求（各个页面切换的效果）定了一个框架，我写了静态的页面，博志写了用于切换的js代码。我们大概的分好工，我写那个导航栏和小组介绍具体详情页面的代码。然后我们各自进行开发。我们也同java组商量那些接口问题。</p>\n<h2 id=\"利用了版本控制管理工具git进行多人协作\"><a href=\"#利用了版本控制管理工具git进行多人协作\" class=\"headerlink\" title=\"利用了版本控制管理工具git进行多人协作\"></a>利用了版本控制管理工具git进行多人协作</h2><p>这也是我真正意义上的一次使用git，也学习了很多，因为不太熟悉，所以也是边学边用，一边看教程，一边学以致用。丰富了自己使用git的经验，也熟悉了多人协作的模式。利用git，可以更好地进行多人协同开发，提高了效率。</p>\n<h2 id=\"使用的框架-工具\"><a href=\"#使用的框架-工具\" class=\"headerlink\" title=\"使用的框架/工具\"></a>使用的框架/工具</h2><h3 id=\"bootstrap\"><a href=\"#bootstrap\" class=\"headerlink\" title=\"bootstrap\"></a>bootstrap</h3><p>我在bootstrap中文文档网学习了一下，然后尝试着利用bootstrap的栅格系统去写我负责的那个页面的整体框架布局。发现这个bootstrap的栅格系统是个蛮方便蛮好用的东西。其主要原理是把整个页面最多分成12列，然后实现的话主要还是给一个百分比的宽度。然后每一列都是浮动的。它分为4种不同屏幕分辨率的写法，有超小屏幕（小于768px），小屏幕（768px到992px），中等屏幕（992px到1200px），大屏幕（1200px）。自己开始写那个页面之前就先把那个页面的框架给描绘出来，先定好框架，直接用bootstrap写成响应式，一步到位。个人感觉这个框架挺好用。</p>\n<h3 id=\"animate-css\"><a href=\"#animate-css\" class=\"headerlink\" title=\"animate.css\"></a>animate.css</h3><p>这次的动画效果我主要是用css3.根据设计师需要的动画效果，用到了animate.css。里面有很多动画效果。其原理是利用css3的动画，然后把这个动画写到一个类名上，然后利用JS来控制，就是addClass方法，把这个类名添加到你要实现动画的元素上。我没有直接引用一整个animate.css文件，而是去到animate.css的github上找到自己想要的动画的那个代码直接引用到自己的css中，因为我用到里面的动画也不多，所以这样可能会更好。</p>\n<h3 id=\"jquery\"><a href=\"#jquery\" class=\"headerlink\" title=\"jquery\"></a>jquery</h3><p>主要还是用jquery写需要的js代码。<br>也在小喵的帮助下学习了一个新东西。就是模拟操作。之前在书里也看过但是没用过，这次也用到了。</p>\n<h2 id=\"开发中遇到的问题和解决方法\"><a href=\"#开发中遇到的问题和解决方法\" class=\"headerlink\" title=\"开发中遇到的问题和解决方法\"></a>开发中遇到的问题和解决方法</h2><p>bootstrap 会有许多默认的样式，有时候bootstrap里面的样式会破坏整个的效果，使得呈现的页面跟想要的页面不一样。我到谷歌浏览器的控制台查看然后利用权重值更改元素的css。它也会给你的元素添加一些默认的外边距呀内边距呀，我在做的时候都会跟设计稿有出入，所以我也另外利用css3的媒体查询，写了挺多元素的样式去覆盖掉bootstrap所添加的那些样式。<br>还有一个就是这个页面的整体框架问题，我觉得不是最优的，这个也是一开始没有仔细考虑清楚吧。希望以后能够仔细考虑后再确定整体的框架。<br>可能还有一些自己没发现的问题，也希望他人帮忙指出。</p>\n<h2 id=\"最后结尾\"><a href=\"#最后结尾\" class=\"headerlink\" title=\"最后结尾\"></a>最后结尾</h2><p>做这次的协同主页我们大家也踩了许多不大不小的坑，以后需要多注意，也感谢组内小伙伴的帮助和支持。一起加油。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"开发前的准备\"><a href=\"#开发前的准备\" class=\"headerlink\" title=\"开发前的准备\"></a>开发前的准备</h2><p>在夏令营的最后一个星期，我们进行了这个协同主页的开发。开始之前，我们开了个会商量了一下，然后由大脸写那个评估文档，然后根据设计师的设计稿进行分工。拿到设计稿，博志根据设计师的要求（各个页面切换的效果）定了一个框架，我写了静态的页面，博志写了用于切换的js代码。我们大概的分好工，我写那个导航栏和小组介绍具体详情页面的代码。然后我们各自进行开发。我们也同java组商量那些接口问题。</p>\n<h2 id=\"利用了版本控制管理工具git进行多人协作\"><a href=\"#利用了版本控制管理工具git进行多人协作\" class=\"headerlink\" title=\"利用了版本控制管理工具git进行多人协作\"></a>利用了版本控制管理工具git进行多人协作</h2><p>这也是我真正意义上的一次使用git，也学习了很多，因为不太熟悉，所以也是边学边用，一边看教程，一边学以致用。丰富了自己使用git的经验，也熟悉了多人协作的模式。利用git，可以更好地进行多人协同开发，提高了效率。</p>\n<h2 id=\"使用的框架-工具\"><a href=\"#使用的框架-工具\" class=\"headerlink\" title=\"使用的框架/工具\"></a>使用的框架/工具</h2><h3 id=\"bootstrap\"><a href=\"#bootstrap\" class=\"headerlink\" title=\"bootstrap\"></a>bootstrap</h3><p>我在bootstrap中文文档网学习了一下，然后尝试着利用bootstrap的栅格系统去写我负责的那个页面的整体框架布局。发现这个bootstrap的栅格系统是个蛮方便蛮好用的东西。其主要原理是把整个页面最多分成12列，然后实现的话主要还是给一个百分比的宽度。然后每一列都是浮动的。它分为4种不同屏幕分辨率的写法，有超小屏幕（小于768px），小屏幕（768px到992px），中等屏幕（992px到1200px），大屏幕（1200px）。自己开始写那个页面之前就先把那个页面的框架给描绘出来，先定好框架，直接用bootstrap写成响应式，一步到位。个人感觉这个框架挺好用。</p>\n<h3 id=\"animate-css\"><a href=\"#animate-css\" class=\"headerlink\" title=\"animate.css\"></a>animate.css</h3><p>这次的动画效果我主要是用css3.根据设计师需要的动画效果，用到了animate.css。里面有很多动画效果。其原理是利用css3的动画，然后把这个动画写到一个类名上，然后利用JS来控制，就是addClass方法，把这个类名添加到你要实现动画的元素上。我没有直接引用一整个animate.css文件，而是去到animate.css的github上找到自己想要的动画的那个代码直接引用到自己的css中，因为我用到里面的动画也不多，所以这样可能会更好。</p>\n<h3 id=\"jquery\"><a href=\"#jquery\" class=\"headerlink\" title=\"jquery\"></a>jquery</h3><p>主要还是用jquery写需要的js代码。<br>也在小喵的帮助下学习了一个新东西。就是模拟操作。之前在书里也看过但是没用过，这次也用到了。</p>\n<h2 id=\"开发中遇到的问题和解决方法\"><a href=\"#开发中遇到的问题和解决方法\" class=\"headerlink\" title=\"开发中遇到的问题和解决方法\"></a>开发中遇到的问题和解决方法</h2><p>bootstrap 会有许多默认的样式，有时候bootstrap里面的样式会破坏整个的效果，使得呈现的页面跟想要的页面不一样。我到谷歌浏览器的控制台查看然后利用权重值更改元素的css。它也会给你的元素添加一些默认的外边距呀内边距呀，我在做的时候都会跟设计稿有出入，所以我也另外利用css3的媒体查询，写了挺多元素的样式去覆盖掉bootstrap所添加的那些样式。<br>还有一个就是这个页面的整体框架问题，我觉得不是最优的，这个也是一开始没有仔细考虑清楚吧。希望以后能够仔细考虑后再确定整体的框架。<br>可能还有一些自己没发现的问题，也希望他人帮忙指出。</p>\n<h2 id=\"最后结尾\"><a href=\"#最后结尾\" class=\"headerlink\" title=\"最后结尾\"></a>最后结尾</h2><p>做这次的协同主页我们大家也踩了许多不大不小的坑，以后需要多注意，也感谢组内小伙伴的帮助和支持。一起加油。</p>\n"},{"title":"实现EventEmitter","date":"2018-03-14T16:00:00.000Z","_content":"\n# 实现一个EventEmitter (事件触发器)\n算是从现在开始自己模仿的第一个轮子把，加油.\n\n要实现一个EventEmitter，核心功能就是实现`on`，`emit`方法。\n\n<!-- more -->\n`on`方法用来为一个`事件`绑定一个`监听器`\n``` javascript\nconst a = new EventEmitter()\n\nvar listener = function(arg) {\n    console.log(arg)\n}\n\n//第一个参数为事件名称，string类型\n//第二个参数为想要绑定的监听器函数，这个函数在这个事件被触发时执行.\na.on(\"sayHello\", listener)\n\n```\n`emit`方法用来触发某个`事件`，并可以为这个事件所绑定的`监听器函数`传入参数。\n\n``` javascript\na.emit(\"sayHello\",\"hello World\")\n// “hello World”\n```\n\n## 构造函数EventEmitter\n``` javascript\n//eventEmitter.js\n\nfunction EventEmitter () {\n    this._event = {};\n    /** \n     * 第一次设计的结构\n     * {\n     *     \"event1\": [fn1,fn2,fn3],\n     *     \"event2\": [fn1,fn2,fn3]\n     * }\n    **/\n    /**第二次设计的结构\n     * {\n     *      \"event1\": [{fn:fn1, once: false}]\n     * } \n    **/\n}\n```\nthis._event对象存储'事件'与'监听器'的关系，因为每一个事件都可以绑定多个监听器，所以采用数组的形式来存储一个监听队列。结构如上代码注释. \n\n## 实现on方法\n``` javascript\n//eventEmitter.js\n\nvar proto = EventEmitter.prototype\n\n/**\n * \n * @param {string} eventName 事件名称\n * @param {function} listener 监听器函数\n */\nproto.on = function(eventName, listener) {\n    let listeners = this._event[eventName] =  this._event[eventName] || [];\n\n    //将传入的listener参数添加到listeners队列。\n    listeners.push(listener)\n\n    //返回EventEmitter对象，从而可以进行链式调用\n    return this;\n}\n```\n如果传入的这个事件的监听队列存在，则直接将其赋值给`listeners`变量，若不存在，则给`listeners`创建一个新队列（空数组）。\n\n再在`listeners`进行操作，将listener添加到监听队列中。\n\n## 实现emit方法\n``` javascript\nproto.emit = function(eventName, args) {\n    let listeners = this._event[eventName];\n    \n    //如果emit的事件不存在，则直接返回；\n    if(!listeners) return;\n\n    //遍历监听队列，将args传给监听函数并执行监听函数。\n    listeners.forEach(listener => {\n\n     //如果args是数组，则转化为参数列表\n        if(Array.isArray(args)) {\n            listener(...args)\n        } \n        else {\n            listener(args)\n        }\n    });\n\n    //返回EventEmitter对象，从而可以进行链式调用\n    return this; \n}\n```\n到这里就完成了一个简单的`EventEmitter`，后面就是进一步的完善了。\n\n## 实现off方法\n\noff方法用来移除某个事件的某个监听函数，需要传入参数为，`事件名`&`监听函数`\n``` javascript\nproto.off = function(eventName, listener) {\n    let listeners = this._event[eventName];\n\n    //如果事件对应的监听队列不存在，则直接返回\n    if(!listeners) return;\n\n    //采用filter方法将监听队列中监听函数为listener的给筛选掉.\n    listeners = listeners.filter(e => {\n        if(e !== listener) return  e;\n    })\n\n    return this;\n}\n```\n\n## 实现once方法\n\nonce方法对某个特定事件只执行一遍监听函数，执行完毕就将监听函数从监听队列中移除。\n\n``` javascript\n/**\n * \n * @param {string} eventName \n * @param {function} listener \n */\nproto.once = function(eventName, listener) {\n    return this.on(eventName, listener, true);\n}\n```\n`once`方法内部调用`on`方法，不过传参的时候多传了个`once`参数为ture，所以需要修改`on`方法来配合`once`方法.\n\n**修改后的on方法**\n\n``` javascript\n proto.on = function(eventName, listener, once = false) {\n     //once参数默认为false\n    //当某个事件监听队列的不存在时，创建一个空队列。存在则直接赋值给listeners\n    let listeners = this._event[eventName] =  this._event[eventName] || [];\n\n    //将传入的listener参数添加到listeners队列。\n    listeners.push({\n        fn: listener,\n        once: once\n    });\n\n    //返回EventEmitter对象，从而可以进行链式调用\n    return this;\n}\n```\n\n变化的地方就是`on`方法现在接受三个参数，第三个参数为once，默认值为`fasle`。`once`方法调用`on`方法传过来一个once参数为`true`。\n\n现在不直接把监听函数`listener`添加到监听队列中，而是用一个`对象`来代表一个监听函数，对象的fn字段就是监听函数，once字段代表是否只能够执行一次.  \n在emit的时候就判断监听队列中的item的once字段是否为true，如果是的话就调用off方法.\n\n## 添加一个验证listener参数的函数\n在调用EventEmitter的各个方法时，如果有需要传一个`listener`的参数的话，在内部需要判断这个参数是否为函数，如果不是函数，则抛出一个TypeError.\n\n``` javascript\nfunction isValid(listener) {\n    if(typeof listener === 'function') {\n        return true\n    } else if (typeof listener === 'object' && listener) {\n        return isValid(listener.fn)\n    } else {\n        return false\n    }\n}\n```\n\n在各个方法需要传入listener参数的就可以添加以下代码进行验证\n\n``` javascript \nif(!isValid(listener)) {\n    throw new TypeError(\"listener must be a function!\");\n}\n```\n\n## 实现Allof方法\n``` javascript\n/**\n * \n * @param {string} eventName 事件名称，如果事件名称为空则删除\n */\nproto.allOf = function(eventName) {\n    //如果事件名称为空，则删除所有事件与监听函数的绑定关系。\n    //若有指定某个事件，则删除此事件的监听队列，置为空。\n    if(!eventName) {\n        this._event = {}\n    } else if(eventName && this._event[eventName]) {\n        this._event[eventName] = []\n    }\n}\n```\n\n暴露EventEmitter对象\n``` javascript\n// eventEmitter.js\n\nmodule.exports = EventEmitter\n```\n\n## Test.js\n``` javascript\nconst eEmitter = require('./eventEmitter');\n\nlet event = new eEmitter();\n\nlet fn1 = function(arg) {\n    console.log(\"fn1: \",arg);\n}\n\nlet fn2 = function(arg) {\n    console.log(\"fn2: \", arg)\n}\n\nlet fn3 = function(arg) {\n    console.log(\"fn3: \", arg);\n}\n\nevent.on(\"event1\", fn1)\n    .on(\"event1\", fn2)\n    .once(\"event2\", fn3)\n    .on(\"event1\", fn3)\n    .on(\"event3\", fn1)\n    .on(\"event3\", fn2)\n\nconsole.log(event._event);\nconsole.log(\"--------------------------------\")\n\nevent.emit(\"event1\", 1)\n    .emit(\"event2\", 'once')\n\nconsole.log(\"--------------------------------\")\n\nevent.allOf(\"event1\")\nconsole.log(event._event);\n\n\nconsole.log(\"--------------------------------\")\nevent.off(\"event3\",fn1)\nconsole.log(event._event)\n\n\n```\n## In the End\nEventEmitter在Node.js的event模块中，而很多对象都是EventEmitter的实例，他们也就可以使用EventEmitter的方法.  \n\n对于`EventEmitter`来说，最主要的还是`on`和`emit`和`off`方法，其他的方法都是在这几个的基础上扩展出来的.\n\n通过这次实现，自己也学会了如何把一个任务拆解，并逐渐实现每个小任务，再对最后的结果加以适当的完善。\n\n还有就是需要对整个任务的轮廓有个大概的理解。\n\n呃...还是立个flag吧，实现一个Promise，现在只实现了简单的`then`和`resolve`。\n\n\n\n","source":"_posts/EventEmitter.md","raw":"---\ntitle: 实现EventEmitter\ncategory: JavaScript\ndate: 2018-3-15\ntags: [JavaScript, 模拟实现]\n---\n\n# 实现一个EventEmitter (事件触发器)\n算是从现在开始自己模仿的第一个轮子把，加油.\n\n要实现一个EventEmitter，核心功能就是实现`on`，`emit`方法。\n\n<!-- more -->\n`on`方法用来为一个`事件`绑定一个`监听器`\n``` javascript\nconst a = new EventEmitter()\n\nvar listener = function(arg) {\n    console.log(arg)\n}\n\n//第一个参数为事件名称，string类型\n//第二个参数为想要绑定的监听器函数，这个函数在这个事件被触发时执行.\na.on(\"sayHello\", listener)\n\n```\n`emit`方法用来触发某个`事件`，并可以为这个事件所绑定的`监听器函数`传入参数。\n\n``` javascript\na.emit(\"sayHello\",\"hello World\")\n// “hello World”\n```\n\n## 构造函数EventEmitter\n``` javascript\n//eventEmitter.js\n\nfunction EventEmitter () {\n    this._event = {};\n    /** \n     * 第一次设计的结构\n     * {\n     *     \"event1\": [fn1,fn2,fn3],\n     *     \"event2\": [fn1,fn2,fn3]\n     * }\n    **/\n    /**第二次设计的结构\n     * {\n     *      \"event1\": [{fn:fn1, once: false}]\n     * } \n    **/\n}\n```\nthis._event对象存储'事件'与'监听器'的关系，因为每一个事件都可以绑定多个监听器，所以采用数组的形式来存储一个监听队列。结构如上代码注释. \n\n## 实现on方法\n``` javascript\n//eventEmitter.js\n\nvar proto = EventEmitter.prototype\n\n/**\n * \n * @param {string} eventName 事件名称\n * @param {function} listener 监听器函数\n */\nproto.on = function(eventName, listener) {\n    let listeners = this._event[eventName] =  this._event[eventName] || [];\n\n    //将传入的listener参数添加到listeners队列。\n    listeners.push(listener)\n\n    //返回EventEmitter对象，从而可以进行链式调用\n    return this;\n}\n```\n如果传入的这个事件的监听队列存在，则直接将其赋值给`listeners`变量，若不存在，则给`listeners`创建一个新队列（空数组）。\n\n再在`listeners`进行操作，将listener添加到监听队列中。\n\n## 实现emit方法\n``` javascript\nproto.emit = function(eventName, args) {\n    let listeners = this._event[eventName];\n    \n    //如果emit的事件不存在，则直接返回；\n    if(!listeners) return;\n\n    //遍历监听队列，将args传给监听函数并执行监听函数。\n    listeners.forEach(listener => {\n\n     //如果args是数组，则转化为参数列表\n        if(Array.isArray(args)) {\n            listener(...args)\n        } \n        else {\n            listener(args)\n        }\n    });\n\n    //返回EventEmitter对象，从而可以进行链式调用\n    return this; \n}\n```\n到这里就完成了一个简单的`EventEmitter`，后面就是进一步的完善了。\n\n## 实现off方法\n\noff方法用来移除某个事件的某个监听函数，需要传入参数为，`事件名`&`监听函数`\n``` javascript\nproto.off = function(eventName, listener) {\n    let listeners = this._event[eventName];\n\n    //如果事件对应的监听队列不存在，则直接返回\n    if(!listeners) return;\n\n    //采用filter方法将监听队列中监听函数为listener的给筛选掉.\n    listeners = listeners.filter(e => {\n        if(e !== listener) return  e;\n    })\n\n    return this;\n}\n```\n\n## 实现once方法\n\nonce方法对某个特定事件只执行一遍监听函数，执行完毕就将监听函数从监听队列中移除。\n\n``` javascript\n/**\n * \n * @param {string} eventName \n * @param {function} listener \n */\nproto.once = function(eventName, listener) {\n    return this.on(eventName, listener, true);\n}\n```\n`once`方法内部调用`on`方法，不过传参的时候多传了个`once`参数为ture，所以需要修改`on`方法来配合`once`方法.\n\n**修改后的on方法**\n\n``` javascript\n proto.on = function(eventName, listener, once = false) {\n     //once参数默认为false\n    //当某个事件监听队列的不存在时，创建一个空队列。存在则直接赋值给listeners\n    let listeners = this._event[eventName] =  this._event[eventName] || [];\n\n    //将传入的listener参数添加到listeners队列。\n    listeners.push({\n        fn: listener,\n        once: once\n    });\n\n    //返回EventEmitter对象，从而可以进行链式调用\n    return this;\n}\n```\n\n变化的地方就是`on`方法现在接受三个参数，第三个参数为once，默认值为`fasle`。`once`方法调用`on`方法传过来一个once参数为`true`。\n\n现在不直接把监听函数`listener`添加到监听队列中，而是用一个`对象`来代表一个监听函数，对象的fn字段就是监听函数，once字段代表是否只能够执行一次.  \n在emit的时候就判断监听队列中的item的once字段是否为true，如果是的话就调用off方法.\n\n## 添加一个验证listener参数的函数\n在调用EventEmitter的各个方法时，如果有需要传一个`listener`的参数的话，在内部需要判断这个参数是否为函数，如果不是函数，则抛出一个TypeError.\n\n``` javascript\nfunction isValid(listener) {\n    if(typeof listener === 'function') {\n        return true\n    } else if (typeof listener === 'object' && listener) {\n        return isValid(listener.fn)\n    } else {\n        return false\n    }\n}\n```\n\n在各个方法需要传入listener参数的就可以添加以下代码进行验证\n\n``` javascript \nif(!isValid(listener)) {\n    throw new TypeError(\"listener must be a function!\");\n}\n```\n\n## 实现Allof方法\n``` javascript\n/**\n * \n * @param {string} eventName 事件名称，如果事件名称为空则删除\n */\nproto.allOf = function(eventName) {\n    //如果事件名称为空，则删除所有事件与监听函数的绑定关系。\n    //若有指定某个事件，则删除此事件的监听队列，置为空。\n    if(!eventName) {\n        this._event = {}\n    } else if(eventName && this._event[eventName]) {\n        this._event[eventName] = []\n    }\n}\n```\n\n暴露EventEmitter对象\n``` javascript\n// eventEmitter.js\n\nmodule.exports = EventEmitter\n```\n\n## Test.js\n``` javascript\nconst eEmitter = require('./eventEmitter');\n\nlet event = new eEmitter();\n\nlet fn1 = function(arg) {\n    console.log(\"fn1: \",arg);\n}\n\nlet fn2 = function(arg) {\n    console.log(\"fn2: \", arg)\n}\n\nlet fn3 = function(arg) {\n    console.log(\"fn3: \", arg);\n}\n\nevent.on(\"event1\", fn1)\n    .on(\"event1\", fn2)\n    .once(\"event2\", fn3)\n    .on(\"event1\", fn3)\n    .on(\"event3\", fn1)\n    .on(\"event3\", fn2)\n\nconsole.log(event._event);\nconsole.log(\"--------------------------------\")\n\nevent.emit(\"event1\", 1)\n    .emit(\"event2\", 'once')\n\nconsole.log(\"--------------------------------\")\n\nevent.allOf(\"event1\")\nconsole.log(event._event);\n\n\nconsole.log(\"--------------------------------\")\nevent.off(\"event3\",fn1)\nconsole.log(event._event)\n\n\n```\n## In the End\nEventEmitter在Node.js的event模块中，而很多对象都是EventEmitter的实例，他们也就可以使用EventEmitter的方法.  \n\n对于`EventEmitter`来说，最主要的还是`on`和`emit`和`off`方法，其他的方法都是在这几个的基础上扩展出来的.\n\n通过这次实现，自己也学会了如何把一个任务拆解，并逐渐实现每个小任务，再对最后的结果加以适当的完善。\n\n还有就是需要对整个任务的轮廓有个大概的理解。\n\n呃...还是立个flag吧，实现一个Promise，现在只实现了简单的`then`和`resolve`。\n\n\n\n","slug":"EventEmitter","published":1,"updated":"2018-03-15T07:50:53.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf81eh730004v4ef4ep3hwuh","content":"<h1 id=\"实现一个EventEmitter-事件触发器\"><a href=\"#实现一个EventEmitter-事件触发器\" class=\"headerlink\" title=\"实现一个EventEmitter (事件触发器)\"></a>实现一个EventEmitter (事件触发器)</h1><p>算是从现在开始自己模仿的第一个轮子把，加油.</p>\n<p>要实现一个EventEmitter，核心功能就是实现<code>on</code>，<code>emit</code>方法。</p>\n<a id=\"more\"></a>\n<p><code>on</code>方法用来为一个<code>事件</code>绑定一个<code>监听器</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"keyword\">new</span> EventEmitter()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> listener = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(arg)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第一个参数为事件名称，string类型</span></span><br><span class=\"line\"><span class=\"comment\">//第二个参数为想要绑定的监听器函数，这个函数在这个事件被触发时执行.</span></span><br><span class=\"line\">a.on(<span class=\"string\">\"sayHello\"</span>, listener)</span><br></pre></td></tr></table></figure></p>\n<p><code>emit</code>方法用来触发某个<code>事件</code>，并可以为这个事件所绑定的<code>监听器函数</code>传入参数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.emit(<span class=\"string\">\"sayHello\"</span>,<span class=\"string\">\"hello World\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// “hello World”</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"构造函数EventEmitter\"><a href=\"#构造函数EventEmitter\" class=\"headerlink\" title=\"构造函数EventEmitter\"></a>构造函数EventEmitter</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//eventEmitter.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">EventEmitter</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._event = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * 第一次设计的结构</span></span><br><span class=\"line\"><span class=\"comment\">     * &#123;</span></span><br><span class=\"line\"><span class=\"comment\">     *     \"event1\": [fn1,fn2,fn3],</span></span><br><span class=\"line\"><span class=\"comment\">     *     \"event2\": [fn1,fn2,fn3]</span></span><br><span class=\"line\"><span class=\"comment\">     * &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    **/</span></span><br><span class=\"line\">    <span class=\"comment\">/**第二次设计的结构</span></span><br><span class=\"line\"><span class=\"comment\">     * &#123;</span></span><br><span class=\"line\"><span class=\"comment\">     *      \"event1\": [&#123;fn:fn1, once: false&#125;]</span></span><br><span class=\"line\"><span class=\"comment\">     * &#125; </span></span><br><span class=\"line\"><span class=\"comment\">    **/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>this._event对象存储’事件’与’监听器’的关系，因为每一个事件都可以绑定多个监听器，所以采用数组的形式来存储一个监听队列。结构如上代码注释. </p>\n<h2 id=\"实现on方法\"><a href=\"#实现on方法\" class=\"headerlink\" title=\"实现on方法\"></a>实现on方法</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//eventEmitter.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> proto = EventEmitter.prototype</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;string&#125; eventName 事件名称</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;function&#125; listener 监听器函数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">proto.on = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventName, listener</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> listeners = <span class=\"keyword\">this</span>._event[eventName] =  <span class=\"keyword\">this</span>._event[eventName] || [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将传入的listener参数添加到listeners队列。</span></span><br><span class=\"line\">    listeners.push(listener)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//返回EventEmitter对象，从而可以进行链式调用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果传入的这个事件的监听队列存在，则直接将其赋值给<code>listeners</code>变量，若不存在，则给<code>listeners</code>创建一个新队列（空数组）。</p>\n<p>再在<code>listeners</code>进行操作，将listener添加到监听队列中。</p>\n<h2 id=\"实现emit方法\"><a href=\"#实现emit方法\" class=\"headerlink\" title=\"实现emit方法\"></a>实现emit方法</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proto.emit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventName, args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> listeners = <span class=\"keyword\">this</span>._event[eventName];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//如果emit的事件不存在，则直接返回；</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!listeners) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//遍历监听队列，将args传给监听函数并执行监听函数。</span></span><br><span class=\"line\">    listeners.forEach(<span class=\"function\"><span class=\"params\">listener</span> =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//如果args是数组，则转化为参数列表</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">Array</span>.isArray(args)) &#123;</span><br><span class=\"line\">            listener(...args)</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            listener(args)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//返回EventEmitter对象，从而可以进行链式调用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里就完成了一个简单的<code>EventEmitter</code>，后面就是进一步的完善了。</p>\n<h2 id=\"实现off方法\"><a href=\"#实现off方法\" class=\"headerlink\" title=\"实现off方法\"></a>实现off方法</h2><p>off方法用来移除某个事件的某个监听函数，需要传入参数为，<code>事件名</code>&amp;<code>监听函数</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proto.off = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventName, listener</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> listeners = <span class=\"keyword\">this</span>._event[eventName];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果事件对应的监听队列不存在，则直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!listeners) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//采用filter方法将监听队列中监听函数为listener的给筛选掉.</span></span><br><span class=\"line\">    listeners = listeners.filter(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(e !== listener) <span class=\"keyword\">return</span>  e;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"实现once方法\"><a href=\"#实现once方法\" class=\"headerlink\" title=\"实现once方法\"></a>实现once方法</h2><p>once方法对某个特定事件只执行一遍监听函数，执行完毕就将监听函数从监听队列中移除。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;string&#125; eventName </span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;function&#125; listener </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">proto.once = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventName, listener</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.on(eventName, listener, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>once</code>方法内部调用<code>on</code>方法，不过传参的时候多传了个<code>once</code>参数为ture，所以需要修改<code>on</code>方法来配合<code>once</code>方法.</p>\n<p><strong>修改后的on方法</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> proto.on = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventName, listener, once = false</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">//once参数默认为false</span></span><br><span class=\"line\">    <span class=\"comment\">//当某个事件监听队列的不存在时，创建一个空队列。存在则直接赋值给listeners</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> listeners = <span class=\"keyword\">this</span>._event[eventName] =  <span class=\"keyword\">this</span>._event[eventName] || [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将传入的listener参数添加到listeners队列。</span></span><br><span class=\"line\">    listeners.push(&#123;</span><br><span class=\"line\">        fn: listener,</span><br><span class=\"line\">        once: once</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//返回EventEmitter对象，从而可以进行链式调用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>变化的地方就是<code>on</code>方法现在接受三个参数，第三个参数为once，默认值为<code>fasle</code>。<code>once</code>方法调用<code>on</code>方法传过来一个once参数为<code>true</code>。</p>\n<p>现在不直接把监听函数<code>listener</code>添加到监听队列中，而是用一个<code>对象</code>来代表一个监听函数，对象的fn字段就是监听函数，once字段代表是否只能够执行一次.<br>在emit的时候就判断监听队列中的item的once字段是否为true，如果是的话就调用off方法.</p>\n<h2 id=\"添加一个验证listener参数的函数\"><a href=\"#添加一个验证listener参数的函数\" class=\"headerlink\" title=\"添加一个验证listener参数的函数\"></a>添加一个验证listener参数的函数</h2><p>在调用EventEmitter的各个方法时，如果有需要传一个<code>listener</code>的参数的话，在内部需要判断这个参数是否为函数，如果不是函数，则抛出一个TypeError.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isValid</span>(<span class=\"params\">listener</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> listener === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> listener === <span class=\"string\">'object'</span> &amp;&amp; listener) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isValid(listener.fn)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在各个方法需要传入listener参数的就可以添加以下代码进行验证</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!isValid(listener)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"listener must be a function!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现Allof方法\"><a href=\"#实现Allof方法\" class=\"headerlink\" title=\"实现Allof方法\"></a>实现Allof方法</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;string&#125; eventName 事件名称，如果事件名称为空则删除</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">proto.allOf = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventName</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果事件名称为空，则删除所有事件与监听函数的绑定关系。</span></span><br><span class=\"line\">    <span class=\"comment\">//若有指定某个事件，则删除此事件的监听队列，置为空。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!eventName) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._event = &#123;&#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(eventName &amp;&amp; <span class=\"keyword\">this</span>._event[eventName]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._event[eventName] = []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>暴露EventEmitter对象<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// eventEmitter.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = EventEmitter</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Test-js\"><a href=\"#Test-js\" class=\"headerlink\" title=\"Test.js\"></a>Test.js</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> eEmitter = <span class=\"built_in\">require</span>(<span class=\"string\">'./eventEmitter'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> event = <span class=\"keyword\">new</span> eEmitter();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> fn1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"fn1: \"</span>,arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> fn2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"fn2: \"</span>, arg)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> fn3 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"fn3: \"</span>, arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">event.on(<span class=\"string\">\"event1\"</span>, fn1)</span><br><span class=\"line\">    .on(<span class=\"string\">\"event1\"</span>, fn2)</span><br><span class=\"line\">    .once(<span class=\"string\">\"event2\"</span>, fn3)</span><br><span class=\"line\">    .on(<span class=\"string\">\"event1\"</span>, fn3)</span><br><span class=\"line\">    .on(<span class=\"string\">\"event3\"</span>, fn1)</span><br><span class=\"line\">    .on(<span class=\"string\">\"event3\"</span>, fn2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(event._event);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"--------------------------------\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">event.emit(<span class=\"string\">\"event1\"</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">    .emit(<span class=\"string\">\"event2\"</span>, <span class=\"string\">'once'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"--------------------------------\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">event.allOf(<span class=\"string\">\"event1\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(event._event);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"--------------------------------\"</span>)</span><br><span class=\"line\">event.off(<span class=\"string\">\"event3\"</span>,fn1)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(event._event)</span><br></pre></td></tr></table></figure>\n<h2 id=\"In-the-End\"><a href=\"#In-the-End\" class=\"headerlink\" title=\"In the End\"></a>In the End</h2><p>EventEmitter在Node.js的event模块中，而很多对象都是EventEmitter的实例，他们也就可以使用EventEmitter的方法.  </p>\n<p>对于<code>EventEmitter</code>来说，最主要的还是<code>on</code>和<code>emit</code>和<code>off</code>方法，其他的方法都是在这几个的基础上扩展出来的.</p>\n<p>通过这次实现，自己也学会了如何把一个任务拆解，并逐渐实现每个小任务，再对最后的结果加以适当的完善。</p>\n<p>还有就是需要对整个任务的轮廓有个大概的理解。</p>\n<p>呃…还是立个flag吧，实现一个Promise，现在只实现了简单的<code>then</code>和<code>resolve</code>。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"实现一个EventEmitter-事件触发器\"><a href=\"#实现一个EventEmitter-事件触发器\" class=\"headerlink\" title=\"实现一个EventEmitter (事件触发器)\"></a>实现一个EventEmitter (事件触发器)</h1><p>算是从现在开始自己模仿的第一个轮子把，加油.</p>\n<p>要实现一个EventEmitter，核心功能就是实现<code>on</code>，<code>emit</code>方法。</p>","more":"<p><code>on</code>方法用来为一个<code>事件</code>绑定一个<code>监听器</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"keyword\">new</span> EventEmitter()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> listener = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(arg)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第一个参数为事件名称，string类型</span></span><br><span class=\"line\"><span class=\"comment\">//第二个参数为想要绑定的监听器函数，这个函数在这个事件被触发时执行.</span></span><br><span class=\"line\">a.on(<span class=\"string\">\"sayHello\"</span>, listener)</span><br></pre></td></tr></table></figure></p>\n<p><code>emit</code>方法用来触发某个<code>事件</code>，并可以为这个事件所绑定的<code>监听器函数</code>传入参数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.emit(<span class=\"string\">\"sayHello\"</span>,<span class=\"string\">\"hello World\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// “hello World”</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"构造函数EventEmitter\"><a href=\"#构造函数EventEmitter\" class=\"headerlink\" title=\"构造函数EventEmitter\"></a>构造函数EventEmitter</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//eventEmitter.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">EventEmitter</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._event = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * 第一次设计的结构</span></span><br><span class=\"line\"><span class=\"comment\">     * &#123;</span></span><br><span class=\"line\"><span class=\"comment\">     *     \"event1\": [fn1,fn2,fn3],</span></span><br><span class=\"line\"><span class=\"comment\">     *     \"event2\": [fn1,fn2,fn3]</span></span><br><span class=\"line\"><span class=\"comment\">     * &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    **/</span></span><br><span class=\"line\">    <span class=\"comment\">/**第二次设计的结构</span></span><br><span class=\"line\"><span class=\"comment\">     * &#123;</span></span><br><span class=\"line\"><span class=\"comment\">     *      \"event1\": [&#123;fn:fn1, once: false&#125;]</span></span><br><span class=\"line\"><span class=\"comment\">     * &#125; </span></span><br><span class=\"line\"><span class=\"comment\">    **/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>this._event对象存储’事件’与’监听器’的关系，因为每一个事件都可以绑定多个监听器，所以采用数组的形式来存储一个监听队列。结构如上代码注释. </p>\n<h2 id=\"实现on方法\"><a href=\"#实现on方法\" class=\"headerlink\" title=\"实现on方法\"></a>实现on方法</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//eventEmitter.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> proto = EventEmitter.prototype</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;string&#125; eventName 事件名称</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;function&#125; listener 监听器函数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">proto.on = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventName, listener</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> listeners = <span class=\"keyword\">this</span>._event[eventName] =  <span class=\"keyword\">this</span>._event[eventName] || [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将传入的listener参数添加到listeners队列。</span></span><br><span class=\"line\">    listeners.push(listener)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//返回EventEmitter对象，从而可以进行链式调用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果传入的这个事件的监听队列存在，则直接将其赋值给<code>listeners</code>变量，若不存在，则给<code>listeners</code>创建一个新队列（空数组）。</p>\n<p>再在<code>listeners</code>进行操作，将listener添加到监听队列中。</p>\n<h2 id=\"实现emit方法\"><a href=\"#实现emit方法\" class=\"headerlink\" title=\"实现emit方法\"></a>实现emit方法</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proto.emit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventName, args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> listeners = <span class=\"keyword\">this</span>._event[eventName];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//如果emit的事件不存在，则直接返回；</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!listeners) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//遍历监听队列，将args传给监听函数并执行监听函数。</span></span><br><span class=\"line\">    listeners.forEach(<span class=\"function\"><span class=\"params\">listener</span> =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//如果args是数组，则转化为参数列表</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">Array</span>.isArray(args)) &#123;</span><br><span class=\"line\">            listener(...args)</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            listener(args)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//返回EventEmitter对象，从而可以进行链式调用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里就完成了一个简单的<code>EventEmitter</code>，后面就是进一步的完善了。</p>\n<h2 id=\"实现off方法\"><a href=\"#实现off方法\" class=\"headerlink\" title=\"实现off方法\"></a>实现off方法</h2><p>off方法用来移除某个事件的某个监听函数，需要传入参数为，<code>事件名</code>&amp;<code>监听函数</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proto.off = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventName, listener</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> listeners = <span class=\"keyword\">this</span>._event[eventName];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果事件对应的监听队列不存在，则直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!listeners) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//采用filter方法将监听队列中监听函数为listener的给筛选掉.</span></span><br><span class=\"line\">    listeners = listeners.filter(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(e !== listener) <span class=\"keyword\">return</span>  e;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"实现once方法\"><a href=\"#实现once方法\" class=\"headerlink\" title=\"实现once方法\"></a>实现once方法</h2><p>once方法对某个特定事件只执行一遍监听函数，执行完毕就将监听函数从监听队列中移除。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;string&#125; eventName </span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;function&#125; listener </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">proto.once = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventName, listener</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.on(eventName, listener, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>once</code>方法内部调用<code>on</code>方法，不过传参的时候多传了个<code>once</code>参数为ture，所以需要修改<code>on</code>方法来配合<code>once</code>方法.</p>\n<p><strong>修改后的on方法</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> proto.on = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventName, listener, once = false</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">//once参数默认为false</span></span><br><span class=\"line\">    <span class=\"comment\">//当某个事件监听队列的不存在时，创建一个空队列。存在则直接赋值给listeners</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> listeners = <span class=\"keyword\">this</span>._event[eventName] =  <span class=\"keyword\">this</span>._event[eventName] || [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将传入的listener参数添加到listeners队列。</span></span><br><span class=\"line\">    listeners.push(&#123;</span><br><span class=\"line\">        fn: listener,</span><br><span class=\"line\">        once: once</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//返回EventEmitter对象，从而可以进行链式调用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>变化的地方就是<code>on</code>方法现在接受三个参数，第三个参数为once，默认值为<code>fasle</code>。<code>once</code>方法调用<code>on</code>方法传过来一个once参数为<code>true</code>。</p>\n<p>现在不直接把监听函数<code>listener</code>添加到监听队列中，而是用一个<code>对象</code>来代表一个监听函数，对象的fn字段就是监听函数，once字段代表是否只能够执行一次.<br>在emit的时候就判断监听队列中的item的once字段是否为true，如果是的话就调用off方法.</p>\n<h2 id=\"添加一个验证listener参数的函数\"><a href=\"#添加一个验证listener参数的函数\" class=\"headerlink\" title=\"添加一个验证listener参数的函数\"></a>添加一个验证listener参数的函数</h2><p>在调用EventEmitter的各个方法时，如果有需要传一个<code>listener</code>的参数的话，在内部需要判断这个参数是否为函数，如果不是函数，则抛出一个TypeError.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isValid</span>(<span class=\"params\">listener</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> listener === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> listener === <span class=\"string\">'object'</span> &amp;&amp; listener) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isValid(listener.fn)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在各个方法需要传入listener参数的就可以添加以下代码进行验证</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!isValid(listener)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"listener must be a function!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现Allof方法\"><a href=\"#实现Allof方法\" class=\"headerlink\" title=\"实现Allof方法\"></a>实现Allof方法</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;string&#125; eventName 事件名称，如果事件名称为空则删除</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">proto.allOf = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventName</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果事件名称为空，则删除所有事件与监听函数的绑定关系。</span></span><br><span class=\"line\">    <span class=\"comment\">//若有指定某个事件，则删除此事件的监听队列，置为空。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!eventName) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._event = &#123;&#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(eventName &amp;&amp; <span class=\"keyword\">this</span>._event[eventName]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._event[eventName] = []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>暴露EventEmitter对象<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// eventEmitter.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = EventEmitter</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Test-js\"><a href=\"#Test-js\" class=\"headerlink\" title=\"Test.js\"></a>Test.js</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> eEmitter = <span class=\"built_in\">require</span>(<span class=\"string\">'./eventEmitter'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> event = <span class=\"keyword\">new</span> eEmitter();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> fn1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"fn1: \"</span>,arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> fn2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"fn2: \"</span>, arg)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> fn3 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"fn3: \"</span>, arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">event.on(<span class=\"string\">\"event1\"</span>, fn1)</span><br><span class=\"line\">    .on(<span class=\"string\">\"event1\"</span>, fn2)</span><br><span class=\"line\">    .once(<span class=\"string\">\"event2\"</span>, fn3)</span><br><span class=\"line\">    .on(<span class=\"string\">\"event1\"</span>, fn3)</span><br><span class=\"line\">    .on(<span class=\"string\">\"event3\"</span>, fn1)</span><br><span class=\"line\">    .on(<span class=\"string\">\"event3\"</span>, fn2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(event._event);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"--------------------------------\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">event.emit(<span class=\"string\">\"event1\"</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">    .emit(<span class=\"string\">\"event2\"</span>, <span class=\"string\">'once'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"--------------------------------\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">event.allOf(<span class=\"string\">\"event1\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(event._event);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"--------------------------------\"</span>)</span><br><span class=\"line\">event.off(<span class=\"string\">\"event3\"</span>,fn1)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(event._event)</span><br></pre></td></tr></table></figure>\n<h2 id=\"In-the-End\"><a href=\"#In-the-End\" class=\"headerlink\" title=\"In the End\"></a>In the End</h2><p>EventEmitter在Node.js的event模块中，而很多对象都是EventEmitter的实例，他们也就可以使用EventEmitter的方法.  </p>\n<p>对于<code>EventEmitter</code>来说，最主要的还是<code>on</code>和<code>emit</code>和<code>off</code>方法，其他的方法都是在这几个的基础上扩展出来的.</p>\n<p>通过这次实现，自己也学会了如何把一个任务拆解，并逐渐实现每个小任务，再对最后的结果加以适当的完善。</p>\n<p>还有就是需要对整个任务的轮廓有个大概的理解。</p>\n<p>呃…还是立个flag吧，实现一个Promise，现在只实现了简单的<code>then</code>和<code>resolve</code>。</p>"},{"title":"JavaScript函数","date":"2017-07-12T16:00:00.000Z","_content":"\n因为遇到个Bug发现自己了解的还是太少了,所以就重新回过头去学习了Function. 写了篇记录博客... \n<!-- more -->\n## 函数声明式 和 函数表达式\n```javascript\nconsole.log(fn(2)); //Error： fn is not a function \nconsole.log(fnName(2));  // 4\n//函数声明式\nfunction fnName(x) {\n\t return x*x;\n}\n//函数表达式\nvar fn = function(x) {\n\treturn x*x;\n} \n```\n之前遇到的一个bug...就是因为写了函数表达式而且调用函数写在了函数表达式的前面..所以就报错了..后来了解到，只有函数声明式存在函数声明提升，调用写在函数声明式的前面也不会报错，因为解析器已经先读取了函数声明，把函数声明放在顶部，所以函数调用不会出错。所以以后尽量写要注意把函数的定义要写在函数调用的前面...\n函数声明式存在函数声明提升（function declaration hoisting）， 解析器会先读取函数声明，而函数表达式必须等到JS引擎执行到它所在行时才会解析函数表达式。\n\n除了什么时候可以通过变量访问函数这点之外，函数声明式和函数表达式其实是一样的。\n\n## 立即执行函数\n立即执行函数，我的理解就是，函数在被解析器解析的时候就已经执行了.\n写法：\n```javascript\n(function(x){\n\tconsole.log(x*x*x);\n})(2);   // 8\n\n(function(x){\n\tconsole.log(x*x*x);\n}(2));  //8\n\n!function(x){\n\tconsole.log(x*x*x);\n}(2);\t//8\n\n+function(x){\n\tconsole.log(x*x*x);\n}(2);\t//8\n\n-function(x){\n\tconsole.log(x*x*x);\n}(2);\t//8\n\nvar fn = function(x){\n\tconsole.log(x*x*x);\n}(2);\t//8\n```\n\n（），！，+，-，=等运算符，都将函数声明转换为函数表达式，消除了JavaScript引擎识别函数表达式和函数声明的歧义，函数表达式可以在后面加括号，并立即执行.\n\n## 函数的方法\n\n### function.prototype.apply()\n>**用法:** fun.apply(thisArg, [args]); -----参考 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)\n\n```javascript \nfunction sayDeatil(a, b, c){\n\tconsole.log('name:' + this.name + ' ，' + a + ' ' + b + ' ' + c);\n}\n\nvar a = {\n\tname: 'apple',\n\tnums: [4, 3, 10]\n}\n\nvar o = {\n\tname: 'orange',\n\tnums: [2, 4, 8]\n}\nvar name = 'windows name';\nvar nums = [3, 3, 3];\n\nsayDeatil.apply(a, a.nums); // name:apple, 4 3 10\nsayDeatil.apply(o, o.nums); // name:orange, 2 4 8\nsayDeatil.apply(this, nums); //name: windows name, 3 3 3\nsayDeatil.apply(null, nums); //当前函数处于非严格模式下，thisArg这个参数赋为null或者undefined时会自动指向全局对象（浏览器中就是window对象）\n\n```\nfun.apply( )第一个参数传的是 函数体内this的指向（fun函数运行时指定的this值）。 上述例子分别指的是对象a，对象o和window 对象\n第二个参数是参数数组或者类数组对象。\n### function.prototype.call()\n>**用法：** fun.call(thisArg[, arg1[, arg2[, ...]]]) ------参考[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call)\n\ncall（）和apply（）类似。他们两者传的第一个个参数一样。都是fun函数运行时指定的this值。而call第二个参数往后传的是参数列表.\n```javascript \nfunction sayDeatil(a, b, c){\n\tconsole.log('name:' + this.name + ' ，' + a + ' ' + b + ' ' + c);\n}\nvar o = {\n\tname: 'orange',\n\tnums: [2, 4, 8]\n}\n\nsayDeatil.call(o, 2, 4, 8); // call 和 apply的不同就是apply传的是参数数组或者类数组对象 而call传的是参数列表\n```\n### 常用用法\n1.  **数组之间追加**\n```javascript \nvar array1 = [1, 2, 3, 4];\nvar array2 = [5, 6, 7, 8];\n\nArray.prototype.push.apply(array1,array2);  //将array2融合到array1 相当于  array1.push(5, 6, 7, 8);\nconsole.log(array1); // [1, 2, 3, 4, 5, 6, 7, 8];\n```\n2.  **获取数组中的最大值最小值**\n```javascript \nvar nums = [1, 2, 3, 5, 20];\n\nvar getMax = function(arg) {\n\tif(arg instanceof Array) {  //当arg是数组时\n\t\tlet max = Math.max.apply(this, arg);\n\t\tconsole.log(max);\n\t}\n\telse { //arg不是数组，而是参数列表时，利用arguments对象\n\t\tlet slice = Array.prototype.slice;\n\t\tlet argArray = slice.apply(arguments); //利用Array.prototype.slice.apply() 把类数组对象转为真正的数组.\n\t\tlet max = Math.max.apply(this, argArray); \n\t\tconsole.log(max);\n\t}\n}\ngetMax(nums); // 20\n//#  求最小值类似,使用内置函数Math.min\n\n```\n3.  **类数组对象转化为真正的数组**\n类数组对象最特殊的是function的arguments对象，具有length长度，不能使用pop,push等方法.. 解决办法就是将类数组对象转化\n```javascript \n+function fn(a,b,c){\n\tlet args = Array.prototype.slice.call(arguments);\n\tconsole.log(args); \n}(1, 2, 3)   // [1, 2, 3]\n```\n\n### 进一步提升\n```javascript  \n//定义个log方法，代理console.log方法\nfunction log(msg) {\n\tconsole.log.apply(this,arguments);\n};\n\nlog('asdasd2',4);  //asdasd2 4\n```\n### function.prototype.bind()\n>**用法:** &nbsp fun.bind(thisArg[, arg1[, arg2[, ...]]]) -----参考[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)\nbind( )方法创建一个新的**函数**，当被调用时，将其this关键字设置为提供的值,在调用新函数时，在任何提供之前提供一个给定的参数序列。\n```javascript \nvar aFun = {\n    x: 30,\n    getX:function(){\n        return this.x;\n    }\n}\n\nvar o = {\n    x: 20\n}\n\nvar newFun = aFun.getX.bind(o);  //\nconsole.log(newFun) // function() { return this.x; }  跟aFun.getX一样的函数体 只不过newFun的this指向是o对象. \ntypeof(newFun) // function\nnewFun();  // 20\n// # 修改o对象的x值\no.x = 233;\nnewFun();  //233\n```\n\n### apply、call、bind总结\n\n+  三者都是用来改变函数的this对象的指向的；\n+  三者第一个参数都是this要指向的对象，也就是想指定的上下文\n+  三者都可以利用后续参数传参\n+  **bind是返回一个新函数**，便于稍后调用；apply、call则是立即调用\n\n\n参考文章\n[【优雅代码】深入浅出 妙用Javascript中apply、call、bind](http://www.cnblogs.com/coco1s/p/4833199.html) \n \n[ MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/)\n\n>“对我来说，博客首先是一种知识管理工具，其次才是传播工具。我的技术文章，主要用来整理我还不懂的知识。我只写那些我还没有完全掌握的东西，那些我精通的东西，往往没有动力写。炫耀从来不是我的动机，好奇才是。\"    ——阮一峰\n>>  希望也成为我写记录博客的动力....\n\n\n\n","source":"_posts/Js-Function.md","raw":"---\ntitle: JavaScript函数\ncategory: JavaScript\ntags: [JavaScript, Function]\ndate: 2017-07-13\n---\n\n因为遇到个Bug发现自己了解的还是太少了,所以就重新回过头去学习了Function. 写了篇记录博客... \n<!-- more -->\n## 函数声明式 和 函数表达式\n```javascript\nconsole.log(fn(2)); //Error： fn is not a function \nconsole.log(fnName(2));  // 4\n//函数声明式\nfunction fnName(x) {\n\t return x*x;\n}\n//函数表达式\nvar fn = function(x) {\n\treturn x*x;\n} \n```\n之前遇到的一个bug...就是因为写了函数表达式而且调用函数写在了函数表达式的前面..所以就报错了..后来了解到，只有函数声明式存在函数声明提升，调用写在函数声明式的前面也不会报错，因为解析器已经先读取了函数声明，把函数声明放在顶部，所以函数调用不会出错。所以以后尽量写要注意把函数的定义要写在函数调用的前面...\n函数声明式存在函数声明提升（function declaration hoisting）， 解析器会先读取函数声明，而函数表达式必须等到JS引擎执行到它所在行时才会解析函数表达式。\n\n除了什么时候可以通过变量访问函数这点之外，函数声明式和函数表达式其实是一样的。\n\n## 立即执行函数\n立即执行函数，我的理解就是，函数在被解析器解析的时候就已经执行了.\n写法：\n```javascript\n(function(x){\n\tconsole.log(x*x*x);\n})(2);   // 8\n\n(function(x){\n\tconsole.log(x*x*x);\n}(2));  //8\n\n!function(x){\n\tconsole.log(x*x*x);\n}(2);\t//8\n\n+function(x){\n\tconsole.log(x*x*x);\n}(2);\t//8\n\n-function(x){\n\tconsole.log(x*x*x);\n}(2);\t//8\n\nvar fn = function(x){\n\tconsole.log(x*x*x);\n}(2);\t//8\n```\n\n（），！，+，-，=等运算符，都将函数声明转换为函数表达式，消除了JavaScript引擎识别函数表达式和函数声明的歧义，函数表达式可以在后面加括号，并立即执行.\n\n## 函数的方法\n\n### function.prototype.apply()\n>**用法:** fun.apply(thisArg, [args]); -----参考 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)\n\n```javascript \nfunction sayDeatil(a, b, c){\n\tconsole.log('name:' + this.name + ' ，' + a + ' ' + b + ' ' + c);\n}\n\nvar a = {\n\tname: 'apple',\n\tnums: [4, 3, 10]\n}\n\nvar o = {\n\tname: 'orange',\n\tnums: [2, 4, 8]\n}\nvar name = 'windows name';\nvar nums = [3, 3, 3];\n\nsayDeatil.apply(a, a.nums); // name:apple, 4 3 10\nsayDeatil.apply(o, o.nums); // name:orange, 2 4 8\nsayDeatil.apply(this, nums); //name: windows name, 3 3 3\nsayDeatil.apply(null, nums); //当前函数处于非严格模式下，thisArg这个参数赋为null或者undefined时会自动指向全局对象（浏览器中就是window对象）\n\n```\nfun.apply( )第一个参数传的是 函数体内this的指向（fun函数运行时指定的this值）。 上述例子分别指的是对象a，对象o和window 对象\n第二个参数是参数数组或者类数组对象。\n### function.prototype.call()\n>**用法：** fun.call(thisArg[, arg1[, arg2[, ...]]]) ------参考[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call)\n\ncall（）和apply（）类似。他们两者传的第一个个参数一样。都是fun函数运行时指定的this值。而call第二个参数往后传的是参数列表.\n```javascript \nfunction sayDeatil(a, b, c){\n\tconsole.log('name:' + this.name + ' ，' + a + ' ' + b + ' ' + c);\n}\nvar o = {\n\tname: 'orange',\n\tnums: [2, 4, 8]\n}\n\nsayDeatil.call(o, 2, 4, 8); // call 和 apply的不同就是apply传的是参数数组或者类数组对象 而call传的是参数列表\n```\n### 常用用法\n1.  **数组之间追加**\n```javascript \nvar array1 = [1, 2, 3, 4];\nvar array2 = [5, 6, 7, 8];\n\nArray.prototype.push.apply(array1,array2);  //将array2融合到array1 相当于  array1.push(5, 6, 7, 8);\nconsole.log(array1); // [1, 2, 3, 4, 5, 6, 7, 8];\n```\n2.  **获取数组中的最大值最小值**\n```javascript \nvar nums = [1, 2, 3, 5, 20];\n\nvar getMax = function(arg) {\n\tif(arg instanceof Array) {  //当arg是数组时\n\t\tlet max = Math.max.apply(this, arg);\n\t\tconsole.log(max);\n\t}\n\telse { //arg不是数组，而是参数列表时，利用arguments对象\n\t\tlet slice = Array.prototype.slice;\n\t\tlet argArray = slice.apply(arguments); //利用Array.prototype.slice.apply() 把类数组对象转为真正的数组.\n\t\tlet max = Math.max.apply(this, argArray); \n\t\tconsole.log(max);\n\t}\n}\ngetMax(nums); // 20\n//#  求最小值类似,使用内置函数Math.min\n\n```\n3.  **类数组对象转化为真正的数组**\n类数组对象最特殊的是function的arguments对象，具有length长度，不能使用pop,push等方法.. 解决办法就是将类数组对象转化\n```javascript \n+function fn(a,b,c){\n\tlet args = Array.prototype.slice.call(arguments);\n\tconsole.log(args); \n}(1, 2, 3)   // [1, 2, 3]\n```\n\n### 进一步提升\n```javascript  \n//定义个log方法，代理console.log方法\nfunction log(msg) {\n\tconsole.log.apply(this,arguments);\n};\n\nlog('asdasd2',4);  //asdasd2 4\n```\n### function.prototype.bind()\n>**用法:** &nbsp fun.bind(thisArg[, arg1[, arg2[, ...]]]) -----参考[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)\nbind( )方法创建一个新的**函数**，当被调用时，将其this关键字设置为提供的值,在调用新函数时，在任何提供之前提供一个给定的参数序列。\n```javascript \nvar aFun = {\n    x: 30,\n    getX:function(){\n        return this.x;\n    }\n}\n\nvar o = {\n    x: 20\n}\n\nvar newFun = aFun.getX.bind(o);  //\nconsole.log(newFun) // function() { return this.x; }  跟aFun.getX一样的函数体 只不过newFun的this指向是o对象. \ntypeof(newFun) // function\nnewFun();  // 20\n// # 修改o对象的x值\no.x = 233;\nnewFun();  //233\n```\n\n### apply、call、bind总结\n\n+  三者都是用来改变函数的this对象的指向的；\n+  三者第一个参数都是this要指向的对象，也就是想指定的上下文\n+  三者都可以利用后续参数传参\n+  **bind是返回一个新函数**，便于稍后调用；apply、call则是立即调用\n\n\n参考文章\n[【优雅代码】深入浅出 妙用Javascript中apply、call、bind](http://www.cnblogs.com/coco1s/p/4833199.html) \n \n[ MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/)\n\n>“对我来说，博客首先是一种知识管理工具，其次才是传播工具。我的技术文章，主要用来整理我还不懂的知识。我只写那些我还没有完全掌握的东西，那些我精通的东西，往往没有动力写。炫耀从来不是我的动机，好奇才是。\"    ——阮一峰\n>>  希望也成为我写记录博客的动力....\n\n\n\n","slug":"Js-Function","published":1,"updated":"2017-07-17T05:15:13.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf81eh770005v4efv6d2vkoo","content":"<p>因为遇到个Bug发现自己了解的还是太少了,所以就重新回过头去学习了Function. 写了篇记录博客…<br><a id=\"more\"></a></p>\n<h2 id=\"函数声明式-和-函数表达式\"><a href=\"#函数声明式-和-函数表达式\" class=\"headerlink\" title=\"函数声明式 和 函数表达式\"></a>函数声明式 和 函数表达式</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(fn(<span class=\"number\">2</span>)); <span class=\"comment\">//Error： fn is not a function </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fnName(<span class=\"number\">2</span>));  <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"comment\">//函数声明式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fnName</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">\t <span class=\"keyword\">return</span> x*x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x*x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之前遇到的一个bug…就是因为写了函数表达式而且调用函数写在了函数表达式的前面..所以就报错了..后来了解到，只有函数声明式存在函数声明提升，调用写在函数声明式的前面也不会报错，因为解析器已经先读取了函数声明，把函数声明放在顶部，所以函数调用不会出错。所以以后尽量写要注意把函数的定义要写在函数调用的前面…<br>函数声明式存在函数声明提升（function declaration hoisting）， 解析器会先读取函数声明，而函数表达式必须等到JS引擎执行到它所在行时才会解析函数表达式。</p>\n<p>除了什么时候可以通过变量访问函数这点之外，函数声明式和函数表达式其实是一样的。</p>\n<h2 id=\"立即执行函数\"><a href=\"#立即执行函数\" class=\"headerlink\" title=\"立即执行函数\"></a>立即执行函数</h2><p>立即执行函数，我的理解就是，函数在被解析器解析的时候就已经执行了.<br>写法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(x*x*x);</span><br><span class=\"line\">&#125;)(<span class=\"number\">2</span>);   <span class=\"comment\">// 8</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(x*x*x);</span><br><span class=\"line\">&#125;(<span class=\"number\">2</span>));  <span class=\"comment\">//8</span></span><br><span class=\"line\"></span><br><span class=\"line\">!<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(x*x*x);</span><br><span class=\"line\">&#125;(<span class=\"number\">2</span>);\t<span class=\"comment\">//8</span></span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(x*x*x);</span><br><span class=\"line\">&#125;(<span class=\"number\">2</span>);\t<span class=\"comment\">//8</span></span><br><span class=\"line\"></span><br><span class=\"line\">-<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(x*x*x);</span><br><span class=\"line\">&#125;(<span class=\"number\">2</span>);\t<span class=\"comment\">//8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(x*x*x);</span><br><span class=\"line\">&#125;(<span class=\"number\">2</span>);\t<span class=\"comment\">//8</span></span><br></pre></td></tr></table></figure></p>\n<p>（），！，+，-，=等运算符，都将函数声明转换为函数表达式，消除了JavaScript引擎识别函数表达式和函数声明的歧义，函数表达式可以在后面加括号，并立即执行.</p>\n<h2 id=\"函数的方法\"><a href=\"#函数的方法\" class=\"headerlink\" title=\"函数的方法\"></a>函数的方法</h2><h3 id=\"function-prototype-apply\"><a href=\"#function-prototype-apply\" class=\"headerlink\" title=\"function.prototype.apply()\"></a>function.prototype.apply()</h3><blockquote>\n<p><strong>用法:</strong> fun.apply(thisArg, [args]); —–参考 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayDeatil</span>(<span class=\"params\">a, b, c</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'name:'</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">' ，'</span> + a + <span class=\"string\">' '</span> + b + <span class=\"string\">' '</span> + c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">'apple'</span>,</span><br><span class=\"line\">\tnums: [<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">'orange'</span>,</span><br><span class=\"line\">\tnums: [<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'windows name'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> nums = [<span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">sayDeatil.apply(a, a.nums); <span class=\"comment\">// name:apple, 4 3 10</span></span><br><span class=\"line\">sayDeatil.apply(o, o.nums); <span class=\"comment\">// name:orange, 2 4 8</span></span><br><span class=\"line\">sayDeatil.apply(<span class=\"keyword\">this</span>, nums); <span class=\"comment\">//name: windows name, 3 3 3</span></span><br><span class=\"line\">sayDeatil.apply(<span class=\"literal\">null</span>, nums); <span class=\"comment\">//当前函数处于非严格模式下，thisArg这个参数赋为null或者undefined时会自动指向全局对象（浏览器中就是window对象）</span></span><br></pre></td></tr></table></figure>\n<p>fun.apply( )第一个参数传的是 函数体内this的指向（fun函数运行时指定的this值）。 上述例子分别指的是对象a，对象o和window 对象<br>第二个参数是参数数组或者类数组对象。</p>\n<h3 id=\"function-prototype-call\"><a href=\"#function-prototype-call\" class=\"headerlink\" title=\"function.prototype.call()\"></a>function.prototype.call()</h3><blockquote>\n<p><strong>用法：</strong> fun.call(thisArg[, arg1[, arg2[, …]]]) ——参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n</blockquote>\n<p>call（）和apply（）类似。他们两者传的第一个个参数一样。都是fun函数运行时指定的this值。而call第二个参数往后传的是参数列表.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayDeatil</span>(<span class=\"params\">a, b, c</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'name:'</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">' ，'</span> + a + <span class=\"string\">' '</span> + b + <span class=\"string\">' '</span> + c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">'orange'</span>,</span><br><span class=\"line\">\tnums: [<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sayDeatil.call(o, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>); <span class=\"comment\">// call 和 apply的不同就是apply传的是参数数组或者类数组对象 而call传的是参数列表</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"常用用法\"><a href=\"#常用用法\" class=\"headerlink\" title=\"常用用法\"></a>常用用法</h3><ol>\n<li><p><strong>数组之间追加</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> array2 = [<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.apply(array1,array2);  <span class=\"comment\">//将array2融合到array1 相当于  array1.push(5, 6, 7, 8);</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array1); <span class=\"comment\">// [1, 2, 3, 4, 5, 6, 7, 8];</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>获取数组中的最大值最小值</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nums = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">20</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getMax = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(arg <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>) &#123;  <span class=\"comment\">//当arg是数组时</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">let</span> max = <span class=\"built_in\">Math</span>.max.apply(<span class=\"keyword\">this</span>, arg);</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(max);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123; <span class=\"comment\">//arg不是数组，而是参数列表时，利用arguments对象</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">let</span> slice = <span class=\"built_in\">Array</span>.prototype.slice;</span><br><span class=\"line\">\t\t<span class=\"keyword\">let</span> argArray = slice.apply(<span class=\"built_in\">arguments</span>); <span class=\"comment\">//利用Array.prototype.slice.apply() 把类数组对象转为真正的数组.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">let</span> max = <span class=\"built_in\">Math</span>.max.apply(<span class=\"keyword\">this</span>, argArray); </span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(max);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getMax(nums); <span class=\"comment\">// 20</span></span><br><span class=\"line\"><span class=\"comment\">//#  求最小值类似,使用内置函数Math.min</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>类数组对象转化为真正的数组</strong><br>类数组对象最特殊的是function的arguments对象，具有length长度，不能使用pop,push等方法.. 解决办法就是将类数组对象转化</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">a,b,c</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(args); </span><br><span class=\"line\">&#125;(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)   <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"进一步提升\"><a href=\"#进一步提升\" class=\"headerlink\" title=\"进一步提升\"></a>进一步提升</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义个log方法，代理console.log方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">log(<span class=\"string\">'asdasd2'</span>,<span class=\"number\">4</span>);  <span class=\"comment\">//asdasd2 4</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"function-prototype-bind\"><a href=\"#function-prototype-bind\" class=\"headerlink\" title=\"function.prototype.bind()\"></a>function.prototype.bind()</h3><blockquote>\n<p><strong>用法:</strong> &amp;nbsp fun.bind(thisArg[, arg1[, arg2[, …]]]) —–参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\" rel=\"noopener\">MDN</a><br>bind( )方法创建一个新的<strong>函数</strong>，当被调用时，将其this关键字设置为提供的值,在调用新函数时，在任何提供之前提供一个给定的参数序列。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> aFun = &#123;</span><br><span class=\"line\">    x: <span class=\"number\">30</span>,</span><br><span class=\"line\">    getX:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">    x: <span class=\"number\">20</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> newFun = aFun.getX.bind(o);  <span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newFun) <span class=\"comment\">// function() &#123; return this.x; &#125;  跟aFun.getX一样的函数体 只不过newFun的this指向是o对象. </span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span>(newFun) <span class=\"comment\">// function</span></span><br><span class=\"line\">newFun();  <span class=\"comment\">// 20</span></span><br><span class=\"line\"><span class=\"comment\">// # 修改o对象的x值</span></span><br><span class=\"line\">o.x = <span class=\"number\">233</span>;</span><br><span class=\"line\">newFun();  <span class=\"comment\">//233</span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"apply、call、bind总结\"><a href=\"#apply、call、bind总结\" class=\"headerlink\" title=\"apply、call、bind总结\"></a>apply、call、bind总结</h3><ul>\n<li>三者都是用来改变函数的this对象的指向的；</li>\n<li>三者第一个参数都是this要指向的对象，也就是想指定的上下文</li>\n<li>三者都可以利用后续参数传参</li>\n<li><strong>bind是返回一个新函数</strong>，便于稍后调用；apply、call则是立即调用</li>\n</ul>\n<p>参考文章<br><a href=\"http://www.cnblogs.com/coco1s/p/4833199.html\" target=\"_blank\" rel=\"noopener\">【优雅代码】深入浅出 妙用Javascript中apply、call、bind</a> </p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/\" target=\"_blank\" rel=\"noopener\"> MDN</a></p>\n<blockquote>\n<p>“对我来说，博客首先是一种知识管理工具，其次才是传播工具。我的技术文章，主要用来整理我还不懂的知识。我只写那些我还没有完全掌握的东西，那些我精通的东西，往往没有动力写。炫耀从来不是我的动机，好奇才是。”    ——阮一峰</p>\n<blockquote>\n<p> 希望也成为我写记录博客的动力….</p>\n</blockquote>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>因为遇到个Bug发现自己了解的还是太少了,所以就重新回过头去学习了Function. 写了篇记录博客…<br>","more":"</p>\n<h2 id=\"函数声明式-和-函数表达式\"><a href=\"#函数声明式-和-函数表达式\" class=\"headerlink\" title=\"函数声明式 和 函数表达式\"></a>函数声明式 和 函数表达式</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(fn(<span class=\"number\">2</span>)); <span class=\"comment\">//Error： fn is not a function </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fnName(<span class=\"number\">2</span>));  <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"comment\">//函数声明式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fnName</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">\t <span class=\"keyword\">return</span> x*x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x*x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之前遇到的一个bug…就是因为写了函数表达式而且调用函数写在了函数表达式的前面..所以就报错了..后来了解到，只有函数声明式存在函数声明提升，调用写在函数声明式的前面也不会报错，因为解析器已经先读取了函数声明，把函数声明放在顶部，所以函数调用不会出错。所以以后尽量写要注意把函数的定义要写在函数调用的前面…<br>函数声明式存在函数声明提升（function declaration hoisting）， 解析器会先读取函数声明，而函数表达式必须等到JS引擎执行到它所在行时才会解析函数表达式。</p>\n<p>除了什么时候可以通过变量访问函数这点之外，函数声明式和函数表达式其实是一样的。</p>\n<h2 id=\"立即执行函数\"><a href=\"#立即执行函数\" class=\"headerlink\" title=\"立即执行函数\"></a>立即执行函数</h2><p>立即执行函数，我的理解就是，函数在被解析器解析的时候就已经执行了.<br>写法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(x*x*x);</span><br><span class=\"line\">&#125;)(<span class=\"number\">2</span>);   <span class=\"comment\">// 8</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(x*x*x);</span><br><span class=\"line\">&#125;(<span class=\"number\">2</span>));  <span class=\"comment\">//8</span></span><br><span class=\"line\"></span><br><span class=\"line\">!<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(x*x*x);</span><br><span class=\"line\">&#125;(<span class=\"number\">2</span>);\t<span class=\"comment\">//8</span></span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(x*x*x);</span><br><span class=\"line\">&#125;(<span class=\"number\">2</span>);\t<span class=\"comment\">//8</span></span><br><span class=\"line\"></span><br><span class=\"line\">-<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(x*x*x);</span><br><span class=\"line\">&#125;(<span class=\"number\">2</span>);\t<span class=\"comment\">//8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(x*x*x);</span><br><span class=\"line\">&#125;(<span class=\"number\">2</span>);\t<span class=\"comment\">//8</span></span><br></pre></td></tr></table></figure></p>\n<p>（），！，+，-，=等运算符，都将函数声明转换为函数表达式，消除了JavaScript引擎识别函数表达式和函数声明的歧义，函数表达式可以在后面加括号，并立即执行.</p>\n<h2 id=\"函数的方法\"><a href=\"#函数的方法\" class=\"headerlink\" title=\"函数的方法\"></a>函数的方法</h2><h3 id=\"function-prototype-apply\"><a href=\"#function-prototype-apply\" class=\"headerlink\" title=\"function.prototype.apply()\"></a>function.prototype.apply()</h3><blockquote>\n<p><strong>用法:</strong> fun.apply(thisArg, [args]); —–参考 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayDeatil</span>(<span class=\"params\">a, b, c</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'name:'</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">' ，'</span> + a + <span class=\"string\">' '</span> + b + <span class=\"string\">' '</span> + c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">'apple'</span>,</span><br><span class=\"line\">\tnums: [<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">'orange'</span>,</span><br><span class=\"line\">\tnums: [<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'windows name'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> nums = [<span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">sayDeatil.apply(a, a.nums); <span class=\"comment\">// name:apple, 4 3 10</span></span><br><span class=\"line\">sayDeatil.apply(o, o.nums); <span class=\"comment\">// name:orange, 2 4 8</span></span><br><span class=\"line\">sayDeatil.apply(<span class=\"keyword\">this</span>, nums); <span class=\"comment\">//name: windows name, 3 3 3</span></span><br><span class=\"line\">sayDeatil.apply(<span class=\"literal\">null</span>, nums); <span class=\"comment\">//当前函数处于非严格模式下，thisArg这个参数赋为null或者undefined时会自动指向全局对象（浏览器中就是window对象）</span></span><br></pre></td></tr></table></figure>\n<p>fun.apply( )第一个参数传的是 函数体内this的指向（fun函数运行时指定的this值）。 上述例子分别指的是对象a，对象o和window 对象<br>第二个参数是参数数组或者类数组对象。</p>\n<h3 id=\"function-prototype-call\"><a href=\"#function-prototype-call\" class=\"headerlink\" title=\"function.prototype.call()\"></a>function.prototype.call()</h3><blockquote>\n<p><strong>用法：</strong> fun.call(thisArg[, arg1[, arg2[, …]]]) ——参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n</blockquote>\n<p>call（）和apply（）类似。他们两者传的第一个个参数一样。都是fun函数运行时指定的this值。而call第二个参数往后传的是参数列表.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayDeatil</span>(<span class=\"params\">a, b, c</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'name:'</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">' ，'</span> + a + <span class=\"string\">' '</span> + b + <span class=\"string\">' '</span> + c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">'orange'</span>,</span><br><span class=\"line\">\tnums: [<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sayDeatil.call(o, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>); <span class=\"comment\">// call 和 apply的不同就是apply传的是参数数组或者类数组对象 而call传的是参数列表</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"常用用法\"><a href=\"#常用用法\" class=\"headerlink\" title=\"常用用法\"></a>常用用法</h3><ol>\n<li><p><strong>数组之间追加</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> array2 = [<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.apply(array1,array2);  <span class=\"comment\">//将array2融合到array1 相当于  array1.push(5, 6, 7, 8);</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array1); <span class=\"comment\">// [1, 2, 3, 4, 5, 6, 7, 8];</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>获取数组中的最大值最小值</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nums = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">20</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getMax = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(arg <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>) &#123;  <span class=\"comment\">//当arg是数组时</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">let</span> max = <span class=\"built_in\">Math</span>.max.apply(<span class=\"keyword\">this</span>, arg);</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(max);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123; <span class=\"comment\">//arg不是数组，而是参数列表时，利用arguments对象</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">let</span> slice = <span class=\"built_in\">Array</span>.prototype.slice;</span><br><span class=\"line\">\t\t<span class=\"keyword\">let</span> argArray = slice.apply(<span class=\"built_in\">arguments</span>); <span class=\"comment\">//利用Array.prototype.slice.apply() 把类数组对象转为真正的数组.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">let</span> max = <span class=\"built_in\">Math</span>.max.apply(<span class=\"keyword\">this</span>, argArray); </span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(max);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getMax(nums); <span class=\"comment\">// 20</span></span><br><span class=\"line\"><span class=\"comment\">//#  求最小值类似,使用内置函数Math.min</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>类数组对象转化为真正的数组</strong><br>类数组对象最特殊的是function的arguments对象，具有length长度，不能使用pop,push等方法.. 解决办法就是将类数组对象转化</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">a,b,c</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(args); </span><br><span class=\"line\">&#125;(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)   <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"进一步提升\"><a href=\"#进一步提升\" class=\"headerlink\" title=\"进一步提升\"></a>进一步提升</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义个log方法，代理console.log方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">log(<span class=\"string\">'asdasd2'</span>,<span class=\"number\">4</span>);  <span class=\"comment\">//asdasd2 4</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"function-prototype-bind\"><a href=\"#function-prototype-bind\" class=\"headerlink\" title=\"function.prototype.bind()\"></a>function.prototype.bind()</h3><blockquote>\n<p><strong>用法:</strong> &amp;nbsp fun.bind(thisArg[, arg1[, arg2[, …]]]) —–参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\" rel=\"noopener\">MDN</a><br>bind( )方法创建一个新的<strong>函数</strong>，当被调用时，将其this关键字设置为提供的值,在调用新函数时，在任何提供之前提供一个给定的参数序列。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> aFun = &#123;</span><br><span class=\"line\">    x: <span class=\"number\">30</span>,</span><br><span class=\"line\">    getX:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">    x: <span class=\"number\">20</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> newFun = aFun.getX.bind(o);  <span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newFun) <span class=\"comment\">// function() &#123; return this.x; &#125;  跟aFun.getX一样的函数体 只不过newFun的this指向是o对象. </span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span>(newFun) <span class=\"comment\">// function</span></span><br><span class=\"line\">newFun();  <span class=\"comment\">// 20</span></span><br><span class=\"line\"><span class=\"comment\">// # 修改o对象的x值</span></span><br><span class=\"line\">o.x = <span class=\"number\">233</span>;</span><br><span class=\"line\">newFun();  <span class=\"comment\">//233</span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"apply、call、bind总结\"><a href=\"#apply、call、bind总结\" class=\"headerlink\" title=\"apply、call、bind总结\"></a>apply、call、bind总结</h3><ul>\n<li>三者都是用来改变函数的this对象的指向的；</li>\n<li>三者第一个参数都是this要指向的对象，也就是想指定的上下文</li>\n<li>三者都可以利用后续参数传参</li>\n<li><strong>bind是返回一个新函数</strong>，便于稍后调用；apply、call则是立即调用</li>\n</ul>\n<p>参考文章<br><a href=\"http://www.cnblogs.com/coco1s/p/4833199.html\" target=\"_blank\" rel=\"noopener\">【优雅代码】深入浅出 妙用Javascript中apply、call、bind</a> </p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/\" target=\"_blank\" rel=\"noopener\"> MDN</a></p>\n<blockquote>\n<p>“对我来说，博客首先是一种知识管理工具，其次才是传播工具。我的技术文章，主要用来整理我还不懂的知识。我只写那些我还没有完全掌握的东西，那些我精通的东西，往往没有动力写。炫耀从来不是我的动机，好奇才是。”    ——阮一峰</p>\n<blockquote>\n<p> 希望也成为我写记录博客的动力….</p>\n</blockquote>\n</blockquote>"},{"title":"谈谈SSL吧","date":"2018-03-25T16:00:00.000Z","_content":"\nSSL? What is it?\n<!-- more -->\n\n今天跟花菜还有红莲去120搬显示器，在等师兄来盖章的过程中，讨论了下HTTPS协议和HTTP/2.0协议，收获颇丰，故写篇总结加深印象。\n\n## SSL是什么？\n> SSL（Secure Sockets Layer）是运行在应用层协议和TCP协议之间的`安全套接层`协议，在**传输层**对网络连接进行加密。SSL协议分为两层。**SSL记录协议**和**SSL握手协议**，`记录协议`建立在TCP协议上，为高层协议（HTTP等）提供数据封装，压缩，加密等基本功能的支持。`握手协议`，建立在SSL记录协议之上，在真正的数据传输开始之前，对通信双方的身份进行认证，协商加密算法，计算`对话密钥`等。\n\n## 为什么要有SSL\n\nHTTP 通信是明文的，没有加密的，存在着三大风险\n1. 窃听风险:  通信内容会被第三方获知\n2. 篡改风险:  通信内容存在被篡改的风险\n3. 冒充风险:  黑客可以冒充身份参与通信\n\n为了解决这三个风险，SSL就出生了。HTTPS就是利用了SSL协议.或者是升级了的SSL协议（TLS）\n\n## 对称加密是什么\n\n加密和解密使用一份相同的密钥，密钥泄漏的话，通信的内容就会被任何知道密钥的人解密。所以对称加密主要是要注意密钥的保密性。\n\n公式： \n\n发送方： E(明文，密钥) = 密文\n\n接收方： D(密文，密钥) = 明文\n\n对称加密算法有AES, DES等。用得比较多的是AES算法。\n\n## 非对称加密又是什么\n\n非对称加密是指，通信双方分别持有一个不同的密钥，称作`私钥`和`公钥`。一般来说，私钥和公钥是相对的，两者都可以用来加密解密，一般公开的就是公钥，而私密的不为人知的就是私钥了。公钥加密的数据只能被私钥解密，而私钥加密的数据，也只能被公钥解密。保证这种加密的可靠性就是需要保证私钥的保密性，公钥是明文传输的。\n\n公式：\n\nE(明文，公钥) = 密文  \n\nD(密文，私钥) = 明文\n\n或者也可以\n\nE(明文，私钥) = 密文\n\nD(密文，公钥) = 明文\n\n就是说，公钥和私钥都可以用来加密和解密，用一种密钥加密，只有另外一种密钥可以解密。公钥被人篡改怎么办呢？这时数字证书就出现了.看下面解释.\n\n## SSL用哪种加密算法？\n\nSSL协议握手阶段利用非对称加密来产生`对话密钥`（Session Secret），之后就利用`对话密钥`来对通信信息进行对称加密。\n\n所以说，SSL其实是两种加密算法都使用到了。\n\n## 如何解决三大风险呢？\n\n### 解决窃听风险\n\n将传输数据加密，接收方用密钥来解密数据.因此就算数据被监听到了，也无法知道具体含义，不过劫持数据的一方可以对服务器或者客户端进行`重放攻击`，就是将劫持到的加密数据原封不动地重新发送给接收方，从而达到攻击的目的。解决重放攻击的方法大概有三种： \n\n1. 添加时间戳。 发送方发送报文的时候需要加上当前时间的时间戳，接收方根据本地时间和接收到的报文的时间戳进行对比，如果不符合，则丢弃这个信息。\n2. 加随机数。每个报文都添加一个随机数（唯一的），如果某个随机数重复出现，则说明是遇到了重放攻击。\n3. 加流水号。递增的流水号，只要接收到不连续的流水号报文，就说明可能是重放攻击。\n\n\n### 解决篡改风险\n首先就是要先加密了，加密后的数据，没有密钥是修改不了的。再而就是可以用过`数字签名`。\n\n数字签名。 可以通过RSA加密算法来实现.\n\n具体实现步骤如下.\n\n假如是从客户端发送消息，将要发送的`信息`先用Hash函数（将任意长度的数据映射为固定长度）生成一份信息摘要，然后再用`公钥`把摘要加密，生成了`数字签名`，将数字签名跟消息一起发送。接收方（这里是服务端）收到报文就先把签名拿出来，用`私钥`解密签名，得到发送方发送的消息的摘要，再用与发送方一样的hash函数，对消息进行处理，得到接受到的消息的摘要，两者对比，就可以判断说数据是否改变。而原理呢就是利用hash函数的特性。一个数据只要修改了一点点，对应的hash值都会变化很大，所以可以用来比较是否被修改过。而且hash是不可逆的。\n\n画个图加深印象：\n\n同理服务端发送添加数字签名也是这样，只是是用私钥来加密，然后客户端用公钥来解密获得摘要并与收到的消息进行对比。\n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fppp2339aoj20pr0bg7ef.jpg)\n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fppp1dkadrj20rw0afwo4.jpg)\n\n个人觉得这里的消息可以是明文的也可以是加密过的。如果发送的是CA机构（证书颁发机构）颁发的数字证书的话，一般证书的内容会包含`证书颁发者的数字签名`（CA机构用自己的私钥来加密信息摘要）和一份被颁发对象的公钥，这份公钥就是明文的了。这就是明文的一种情况。还有一种情况就是，你发送的消息也需要加密，并且需要一份数字签名来防止被篡改，这时就需要\n\n### 解决冒充风险\n数字签名只是解决了发送数据有没有被篡改的问题，具体发送方是谁并没有办法知道，这时候只能让发送方出示它的身份证，也就是`数字证书`。\n配备数字证书。通过数字证书来识别身份。\n\n数字证书是网上的身份证明。\n\n对应的有客户端证书，服务端证书。\n#### CA & 数字证书\nCA：证书颁发机构\n一台服务器要为客户端提供SSL服务，首先得向CA申请一份证书，用于证明自己\n\n证书一般包括：\n\n* 申请者的域名\n* 签发机构CA\n* 有效期\n* 公钥\n* 指纹（签名）\n* 等等...如下图\n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fpqc63bjwbj20f3066jrd.jpg)\n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fpqc772eutj20d306zaac.jpg)\n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fpqc7vcgjaj203x01ngle.jpg)\n\n\n## SSL是如何做到的？& SSL握手阶段\nSSL四次握手。由客户端发起。\n\n1. clientHello：客户端向服务端sayHello，告诉服务端说想要建立SSL协议，并告诉它我支持的协议版本还有支持的加密算法（一般是RSA），并且还有发送一个随机数`RNc`（用于待会生成对话密钥）\n\n2. SeverHello：服务端先确认支持的协议版本，如果协议版本不符合，则关闭SSL握手。否则，还有发送一个随机数`RNs`（用于待会生成对话密钥），`服务器证书`，还有就是确认跟客户端一样的加密算法。并向客户端要求客户端证书（如果客户端有的话）来识别客户端身份\n\n3. clientEnd： 首先验证证书（TL;DR 客户端先取得证书里的数字签名，用`CA的公钥`（`一般浏览器会内置CA根证书，包含了CA的公钥`）解密，获得摘要，再将数字证书用hash函数进行处理，得到另一个摘要，与前者比较，若没有变化，说明证书有效，没被篡改），如果客户端有客户端证书就发送证书，若无，则发送客户端的公钥。再生成一个随机数`PMS` ( `pre-master-secret` ), 用`服务端的公钥`加密后发送，再发送一个签名`public key(hash(先前发的全部消息))`。\n\n4. serverEnd: 接受到客户端的消息，验证签名，由三个随机数使用与客户端约定好的某种计算方式来生成`对话密钥`，对话密钥不会传输，而是通信双方根据前面使用非对称加密来握手产生的三个随机数来生成，为什么要使用三个随机数？因为单独使用一个PMS来生成对话密钥的话，并不能保证说客户端每次生成的PMS都是一个新的随机数，所以就存在这个随机数可能被猜出来的可能性，用三个随机数来生成的话，三个随机数的随机度就基本可以保证每次会话的对话密钥都不一样。所以采用三个随机数来生成对话密钥。客户端此时也使用约定好的计算方法计算出对话密钥。\n\n之后的通信，都是采用对称加密，因为非对称加密比较耗性能，花费时间会增加，之前的SSL握手就是先利用非对称加密（RSA）来生成一个`对话密钥`，用于对称加密，对称加密的性能会更好，速度更快，同时这个对话密钥由于是如上生成的，所以也很安全。\n\n\n## SSL解决的问题\n\nSSL解决了三大风险\n窃听风险：  信息都是加密的。\n\n篡改风险：  利用RSA算法生成数字签名来规避这个风险\n\n冒充风险：  利用数字证书。可信的CA机构发布的数字证书就是一个服务端的身份证。而对于客户端的防冒充来说，如果没有客户端证书，服务端则得到的是客户端的公钥，那么只有拥有正确私钥的客户端才能解密消息，所以也规避了客户端冒充的风险。\n\n而平常通信的验证客户端的方式是给客户端分发一个sessionId.每次客户端发送消息都会带上这个sessionId（一般存在cookie里）\n\n\n## in the end\n\nHTTPS是未来的主流。得空把自己的网站搞个小绿锁。\n\n","source":"_posts/SSL.md","raw":"---\ntitle: 谈谈SSL吧\ncategory: HTTPS\ndate: 2018-03-26\ntags: [HTTPS, 网络]\n---\n\nSSL? What is it?\n<!-- more -->\n\n今天跟花菜还有红莲去120搬显示器，在等师兄来盖章的过程中，讨论了下HTTPS协议和HTTP/2.0协议，收获颇丰，故写篇总结加深印象。\n\n## SSL是什么？\n> SSL（Secure Sockets Layer）是运行在应用层协议和TCP协议之间的`安全套接层`协议，在**传输层**对网络连接进行加密。SSL协议分为两层。**SSL记录协议**和**SSL握手协议**，`记录协议`建立在TCP协议上，为高层协议（HTTP等）提供数据封装，压缩，加密等基本功能的支持。`握手协议`，建立在SSL记录协议之上，在真正的数据传输开始之前，对通信双方的身份进行认证，协商加密算法，计算`对话密钥`等。\n\n## 为什么要有SSL\n\nHTTP 通信是明文的，没有加密的，存在着三大风险\n1. 窃听风险:  通信内容会被第三方获知\n2. 篡改风险:  通信内容存在被篡改的风险\n3. 冒充风险:  黑客可以冒充身份参与通信\n\n为了解决这三个风险，SSL就出生了。HTTPS就是利用了SSL协议.或者是升级了的SSL协议（TLS）\n\n## 对称加密是什么\n\n加密和解密使用一份相同的密钥，密钥泄漏的话，通信的内容就会被任何知道密钥的人解密。所以对称加密主要是要注意密钥的保密性。\n\n公式： \n\n发送方： E(明文，密钥) = 密文\n\n接收方： D(密文，密钥) = 明文\n\n对称加密算法有AES, DES等。用得比较多的是AES算法。\n\n## 非对称加密又是什么\n\n非对称加密是指，通信双方分别持有一个不同的密钥，称作`私钥`和`公钥`。一般来说，私钥和公钥是相对的，两者都可以用来加密解密，一般公开的就是公钥，而私密的不为人知的就是私钥了。公钥加密的数据只能被私钥解密，而私钥加密的数据，也只能被公钥解密。保证这种加密的可靠性就是需要保证私钥的保密性，公钥是明文传输的。\n\n公式：\n\nE(明文，公钥) = 密文  \n\nD(密文，私钥) = 明文\n\n或者也可以\n\nE(明文，私钥) = 密文\n\nD(密文，公钥) = 明文\n\n就是说，公钥和私钥都可以用来加密和解密，用一种密钥加密，只有另外一种密钥可以解密。公钥被人篡改怎么办呢？这时数字证书就出现了.看下面解释.\n\n## SSL用哪种加密算法？\n\nSSL协议握手阶段利用非对称加密来产生`对话密钥`（Session Secret），之后就利用`对话密钥`来对通信信息进行对称加密。\n\n所以说，SSL其实是两种加密算法都使用到了。\n\n## 如何解决三大风险呢？\n\n### 解决窃听风险\n\n将传输数据加密，接收方用密钥来解密数据.因此就算数据被监听到了，也无法知道具体含义，不过劫持数据的一方可以对服务器或者客户端进行`重放攻击`，就是将劫持到的加密数据原封不动地重新发送给接收方，从而达到攻击的目的。解决重放攻击的方法大概有三种： \n\n1. 添加时间戳。 发送方发送报文的时候需要加上当前时间的时间戳，接收方根据本地时间和接收到的报文的时间戳进行对比，如果不符合，则丢弃这个信息。\n2. 加随机数。每个报文都添加一个随机数（唯一的），如果某个随机数重复出现，则说明是遇到了重放攻击。\n3. 加流水号。递增的流水号，只要接收到不连续的流水号报文，就说明可能是重放攻击。\n\n\n### 解决篡改风险\n首先就是要先加密了，加密后的数据，没有密钥是修改不了的。再而就是可以用过`数字签名`。\n\n数字签名。 可以通过RSA加密算法来实现.\n\n具体实现步骤如下.\n\n假如是从客户端发送消息，将要发送的`信息`先用Hash函数（将任意长度的数据映射为固定长度）生成一份信息摘要，然后再用`公钥`把摘要加密，生成了`数字签名`，将数字签名跟消息一起发送。接收方（这里是服务端）收到报文就先把签名拿出来，用`私钥`解密签名，得到发送方发送的消息的摘要，再用与发送方一样的hash函数，对消息进行处理，得到接受到的消息的摘要，两者对比，就可以判断说数据是否改变。而原理呢就是利用hash函数的特性。一个数据只要修改了一点点，对应的hash值都会变化很大，所以可以用来比较是否被修改过。而且hash是不可逆的。\n\n画个图加深印象：\n\n同理服务端发送添加数字签名也是这样，只是是用私钥来加密，然后客户端用公钥来解密获得摘要并与收到的消息进行对比。\n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fppp2339aoj20pr0bg7ef.jpg)\n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fppp1dkadrj20rw0afwo4.jpg)\n\n个人觉得这里的消息可以是明文的也可以是加密过的。如果发送的是CA机构（证书颁发机构）颁发的数字证书的话，一般证书的内容会包含`证书颁发者的数字签名`（CA机构用自己的私钥来加密信息摘要）和一份被颁发对象的公钥，这份公钥就是明文的了。这就是明文的一种情况。还有一种情况就是，你发送的消息也需要加密，并且需要一份数字签名来防止被篡改，这时就需要\n\n### 解决冒充风险\n数字签名只是解决了发送数据有没有被篡改的问题，具体发送方是谁并没有办法知道，这时候只能让发送方出示它的身份证，也就是`数字证书`。\n配备数字证书。通过数字证书来识别身份。\n\n数字证书是网上的身份证明。\n\n对应的有客户端证书，服务端证书。\n#### CA & 数字证书\nCA：证书颁发机构\n一台服务器要为客户端提供SSL服务，首先得向CA申请一份证书，用于证明自己\n\n证书一般包括：\n\n* 申请者的域名\n* 签发机构CA\n* 有效期\n* 公钥\n* 指纹（签名）\n* 等等...如下图\n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fpqc63bjwbj20f3066jrd.jpg)\n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fpqc772eutj20d306zaac.jpg)\n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fpqc7vcgjaj203x01ngle.jpg)\n\n\n## SSL是如何做到的？& SSL握手阶段\nSSL四次握手。由客户端发起。\n\n1. clientHello：客户端向服务端sayHello，告诉服务端说想要建立SSL协议，并告诉它我支持的协议版本还有支持的加密算法（一般是RSA），并且还有发送一个随机数`RNc`（用于待会生成对话密钥）\n\n2. SeverHello：服务端先确认支持的协议版本，如果协议版本不符合，则关闭SSL握手。否则，还有发送一个随机数`RNs`（用于待会生成对话密钥），`服务器证书`，还有就是确认跟客户端一样的加密算法。并向客户端要求客户端证书（如果客户端有的话）来识别客户端身份\n\n3. clientEnd： 首先验证证书（TL;DR 客户端先取得证书里的数字签名，用`CA的公钥`（`一般浏览器会内置CA根证书，包含了CA的公钥`）解密，获得摘要，再将数字证书用hash函数进行处理，得到另一个摘要，与前者比较，若没有变化，说明证书有效，没被篡改），如果客户端有客户端证书就发送证书，若无，则发送客户端的公钥。再生成一个随机数`PMS` ( `pre-master-secret` ), 用`服务端的公钥`加密后发送，再发送一个签名`public key(hash(先前发的全部消息))`。\n\n4. serverEnd: 接受到客户端的消息，验证签名，由三个随机数使用与客户端约定好的某种计算方式来生成`对话密钥`，对话密钥不会传输，而是通信双方根据前面使用非对称加密来握手产生的三个随机数来生成，为什么要使用三个随机数？因为单独使用一个PMS来生成对话密钥的话，并不能保证说客户端每次生成的PMS都是一个新的随机数，所以就存在这个随机数可能被猜出来的可能性，用三个随机数来生成的话，三个随机数的随机度就基本可以保证每次会话的对话密钥都不一样。所以采用三个随机数来生成对话密钥。客户端此时也使用约定好的计算方法计算出对话密钥。\n\n之后的通信，都是采用对称加密，因为非对称加密比较耗性能，花费时间会增加，之前的SSL握手就是先利用非对称加密（RSA）来生成一个`对话密钥`，用于对称加密，对称加密的性能会更好，速度更快，同时这个对话密钥由于是如上生成的，所以也很安全。\n\n\n## SSL解决的问题\n\nSSL解决了三大风险\n窃听风险：  信息都是加密的。\n\n篡改风险：  利用RSA算法生成数字签名来规避这个风险\n\n冒充风险：  利用数字证书。可信的CA机构发布的数字证书就是一个服务端的身份证。而对于客户端的防冒充来说，如果没有客户端证书，服务端则得到的是客户端的公钥，那么只有拥有正确私钥的客户端才能解密消息，所以也规避了客户端冒充的风险。\n\n而平常通信的验证客户端的方式是给客户端分发一个sessionId.每次客户端发送消息都会带上这个sessionId（一般存在cookie里）\n\n\n## in the end\n\nHTTPS是未来的主流。得空把自己的网站搞个小绿锁。\n\n","slug":"SSL","published":1,"updated":"2018-03-26T09:35:32.247Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf81eh7f0006v4eff723l019","content":"<p>SSL? What is it?<br><a id=\"more\"></a></p>\n<p>今天跟花菜还有红莲去120搬显示器，在等师兄来盖章的过程中，讨论了下HTTPS协议和HTTP/2.0协议，收获颇丰，故写篇总结加深印象。</p>\n<h2 id=\"SSL是什么？\"><a href=\"#SSL是什么？\" class=\"headerlink\" title=\"SSL是什么？\"></a>SSL是什么？</h2><blockquote>\n<p>SSL（Secure Sockets Layer）是运行在应用层协议和TCP协议之间的<code>安全套接层</code>协议，在<strong>传输层</strong>对网络连接进行加密。SSL协议分为两层。<strong>SSL记录协议</strong>和<strong>SSL握手协议</strong>，<code>记录协议</code>建立在TCP协议上，为高层协议（HTTP等）提供数据封装，压缩，加密等基本功能的支持。<code>握手协议</code>，建立在SSL记录协议之上，在真正的数据传输开始之前，对通信双方的身份进行认证，协商加密算法，计算<code>对话密钥</code>等。</p>\n</blockquote>\n<h2 id=\"为什么要有SSL\"><a href=\"#为什么要有SSL\" class=\"headerlink\" title=\"为什么要有SSL\"></a>为什么要有SSL</h2><p>HTTP 通信是明文的，没有加密的，存在着三大风险</p>\n<ol>\n<li>窃听风险:  通信内容会被第三方获知</li>\n<li>篡改风险:  通信内容存在被篡改的风险</li>\n<li>冒充风险:  黑客可以冒充身份参与通信</li>\n</ol>\n<p>为了解决这三个风险，SSL就出生了。HTTPS就是利用了SSL协议.或者是升级了的SSL协议（TLS）</p>\n<h2 id=\"对称加密是什么\"><a href=\"#对称加密是什么\" class=\"headerlink\" title=\"对称加密是什么\"></a>对称加密是什么</h2><p>加密和解密使用一份相同的密钥，密钥泄漏的话，通信的内容就会被任何知道密钥的人解密。所以对称加密主要是要注意密钥的保密性。</p>\n<p>公式： </p>\n<p>发送方： E(明文，密钥) = 密文</p>\n<p>接收方： D(密文，密钥) = 明文</p>\n<p>对称加密算法有AES, DES等。用得比较多的是AES算法。</p>\n<h2 id=\"非对称加密又是什么\"><a href=\"#非对称加密又是什么\" class=\"headerlink\" title=\"非对称加密又是什么\"></a>非对称加密又是什么</h2><p>非对称加密是指，通信双方分别持有一个不同的密钥，称作<code>私钥</code>和<code>公钥</code>。一般来说，私钥和公钥是相对的，两者都可以用来加密解密，一般公开的就是公钥，而私密的不为人知的就是私钥了。公钥加密的数据只能被私钥解密，而私钥加密的数据，也只能被公钥解密。保证这种加密的可靠性就是需要保证私钥的保密性，公钥是明文传输的。</p>\n<p>公式：</p>\n<p>E(明文，公钥) = 密文  </p>\n<p>D(密文，私钥) = 明文</p>\n<p>或者也可以</p>\n<p>E(明文，私钥) = 密文</p>\n<p>D(密文，公钥) = 明文</p>\n<p>就是说，公钥和私钥都可以用来加密和解密，用一种密钥加密，只有另外一种密钥可以解密。公钥被人篡改怎么办呢？这时数字证书就出现了.看下面解释.</p>\n<h2 id=\"SSL用哪种加密算法？\"><a href=\"#SSL用哪种加密算法？\" class=\"headerlink\" title=\"SSL用哪种加密算法？\"></a>SSL用哪种加密算法？</h2><p>SSL协议握手阶段利用非对称加密来产生<code>对话密钥</code>（Session Secret），之后就利用<code>对话密钥</code>来对通信信息进行对称加密。</p>\n<p>所以说，SSL其实是两种加密算法都使用到了。</p>\n<h2 id=\"如何解决三大风险呢？\"><a href=\"#如何解决三大风险呢？\" class=\"headerlink\" title=\"如何解决三大风险呢？\"></a>如何解决三大风险呢？</h2><h3 id=\"解决窃听风险\"><a href=\"#解决窃听风险\" class=\"headerlink\" title=\"解决窃听风险\"></a>解决窃听风险</h3><p>将传输数据加密，接收方用密钥来解密数据.因此就算数据被监听到了，也无法知道具体含义，不过劫持数据的一方可以对服务器或者客户端进行<code>重放攻击</code>，就是将劫持到的加密数据原封不动地重新发送给接收方，从而达到攻击的目的。解决重放攻击的方法大概有三种： </p>\n<ol>\n<li>添加时间戳。 发送方发送报文的时候需要加上当前时间的时间戳，接收方根据本地时间和接收到的报文的时间戳进行对比，如果不符合，则丢弃这个信息。</li>\n<li>加随机数。每个报文都添加一个随机数（唯一的），如果某个随机数重复出现，则说明是遇到了重放攻击。</li>\n<li>加流水号。递增的流水号，只要接收到不连续的流水号报文，就说明可能是重放攻击。</li>\n</ol>\n<h3 id=\"解决篡改风险\"><a href=\"#解决篡改风险\" class=\"headerlink\" title=\"解决篡改风险\"></a>解决篡改风险</h3><p>首先就是要先加密了，加密后的数据，没有密钥是修改不了的。再而就是可以用过<code>数字签名</code>。</p>\n<p>数字签名。 可以通过RSA加密算法来实现.</p>\n<p>具体实现步骤如下.</p>\n<p>假如是从客户端发送消息，将要发送的<code>信息</code>先用Hash函数（将任意长度的数据映射为固定长度）生成一份信息摘要，然后再用<code>公钥</code>把摘要加密，生成了<code>数字签名</code>，将数字签名跟消息一起发送。接收方（这里是服务端）收到报文就先把签名拿出来，用<code>私钥</code>解密签名，得到发送方发送的消息的摘要，再用与发送方一样的hash函数，对消息进行处理，得到接受到的消息的摘要，两者对比，就可以判断说数据是否改变。而原理呢就是利用hash函数的特性。一个数据只要修改了一点点，对应的hash值都会变化很大，所以可以用来比较是否被修改过。而且hash是不可逆的。</p>\n<p>画个图加深印象：</p>\n<p>同理服务端发送添加数字签名也是这样，只是是用私钥来加密，然后客户端用公钥来解密获得摘要并与收到的消息进行对比。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fppp2339aoj20pr0bg7ef.jpg\" alt=\"\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fppp1dkadrj20rw0afwo4.jpg\" alt=\"\"></p>\n<p>个人觉得这里的消息可以是明文的也可以是加密过的。如果发送的是CA机构（证书颁发机构）颁发的数字证书的话，一般证书的内容会包含<code>证书颁发者的数字签名</code>（CA机构用自己的私钥来加密信息摘要）和一份被颁发对象的公钥，这份公钥就是明文的了。这就是明文的一种情况。还有一种情况就是，你发送的消息也需要加密，并且需要一份数字签名来防止被篡改，这时就需要</p>\n<h3 id=\"解决冒充风险\"><a href=\"#解决冒充风险\" class=\"headerlink\" title=\"解决冒充风险\"></a>解决冒充风险</h3><p>数字签名只是解决了发送数据有没有被篡改的问题，具体发送方是谁并没有办法知道，这时候只能让发送方出示它的身份证，也就是<code>数字证书</code>。<br>配备数字证书。通过数字证书来识别身份。</p>\n<p>数字证书是网上的身份证明。</p>\n<p>对应的有客户端证书，服务端证书。</p>\n<h4 id=\"CA-amp-数字证书\"><a href=\"#CA-amp-数字证书\" class=\"headerlink\" title=\"CA &amp; 数字证书\"></a>CA &amp; 数字证书</h4><p>CA：证书颁发机构<br>一台服务器要为客户端提供SSL服务，首先得向CA申请一份证书，用于证明自己</p>\n<p>证书一般包括：</p>\n<ul>\n<li>申请者的域名</li>\n<li>签发机构CA</li>\n<li>有效期</li>\n<li>公钥</li>\n<li>指纹（签名）</li>\n<li>等等…如下图</li>\n</ul>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fpqc63bjwbj20f3066jrd.jpg\" alt=\"\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fpqc772eutj20d306zaac.jpg\" alt=\"\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fpqc7vcgjaj203x01ngle.jpg\" alt=\"\"></p>\n<h2 id=\"SSL是如何做到的？-amp-SSL握手阶段\"><a href=\"#SSL是如何做到的？-amp-SSL握手阶段\" class=\"headerlink\" title=\"SSL是如何做到的？&amp; SSL握手阶段\"></a>SSL是如何做到的？&amp; SSL握手阶段</h2><p>SSL四次握手。由客户端发起。</p>\n<ol>\n<li><p>clientHello：客户端向服务端sayHello，告诉服务端说想要建立SSL协议，并告诉它我支持的协议版本还有支持的加密算法（一般是RSA），并且还有发送一个随机数<code>RNc</code>（用于待会生成对话密钥）</p>\n</li>\n<li><p>SeverHello：服务端先确认支持的协议版本，如果协议版本不符合，则关闭SSL握手。否则，还有发送一个随机数<code>RNs</code>（用于待会生成对话密钥），<code>服务器证书</code>，还有就是确认跟客户端一样的加密算法。并向客户端要求客户端证书（如果客户端有的话）来识别客户端身份</p>\n</li>\n<li><p>clientEnd： 首先验证证书（TL;DR 客户端先取得证书里的数字签名，用<code>CA的公钥</code>（<code>一般浏览器会内置CA根证书，包含了CA的公钥</code>）解密，获得摘要，再将数字证书用hash函数进行处理，得到另一个摘要，与前者比较，若没有变化，说明证书有效，没被篡改），如果客户端有客户端证书就发送证书，若无，则发送客户端的公钥。再生成一个随机数<code>PMS</code> ( <code>pre-master-secret</code> ), 用<code>服务端的公钥</code>加密后发送，再发送一个签名<code>public key(hash(先前发的全部消息))</code>。</p>\n</li>\n<li><p>serverEnd: 接受到客户端的消息，验证签名，由三个随机数使用与客户端约定好的某种计算方式来生成<code>对话密钥</code>，对话密钥不会传输，而是通信双方根据前面使用非对称加密来握手产生的三个随机数来生成，为什么要使用三个随机数？因为单独使用一个PMS来生成对话密钥的话，并不能保证说客户端每次生成的PMS都是一个新的随机数，所以就存在这个随机数可能被猜出来的可能性，用三个随机数来生成的话，三个随机数的随机度就基本可以保证每次会话的对话密钥都不一样。所以采用三个随机数来生成对话密钥。客户端此时也使用约定好的计算方法计算出对话密钥。</p>\n</li>\n</ol>\n<p>之后的通信，都是采用对称加密，因为非对称加密比较耗性能，花费时间会增加，之前的SSL握手就是先利用非对称加密（RSA）来生成一个<code>对话密钥</code>，用于对称加密，对称加密的性能会更好，速度更快，同时这个对话密钥由于是如上生成的，所以也很安全。</p>\n<h2 id=\"SSL解决的问题\"><a href=\"#SSL解决的问题\" class=\"headerlink\" title=\"SSL解决的问题\"></a>SSL解决的问题</h2><p>SSL解决了三大风险<br>窃听风险：  信息都是加密的。</p>\n<p>篡改风险：  利用RSA算法生成数字签名来规避这个风险</p>\n<p>冒充风险：  利用数字证书。可信的CA机构发布的数字证书就是一个服务端的身份证。而对于客户端的防冒充来说，如果没有客户端证书，服务端则得到的是客户端的公钥，那么只有拥有正确私钥的客户端才能解密消息，所以也规避了客户端冒充的风险。</p>\n<p>而平常通信的验证客户端的方式是给客户端分发一个sessionId.每次客户端发送消息都会带上这个sessionId（一般存在cookie里）</p>\n<h2 id=\"in-the-end\"><a href=\"#in-the-end\" class=\"headerlink\" title=\"in the end\"></a>in the end</h2><p>HTTPS是未来的主流。得空把自己的网站搞个小绿锁。</p>\n","site":{"data":{}},"excerpt":"<p>SSL? What is it?<br>","more":"</p>\n<p>今天跟花菜还有红莲去120搬显示器，在等师兄来盖章的过程中，讨论了下HTTPS协议和HTTP/2.0协议，收获颇丰，故写篇总结加深印象。</p>\n<h2 id=\"SSL是什么？\"><a href=\"#SSL是什么？\" class=\"headerlink\" title=\"SSL是什么？\"></a>SSL是什么？</h2><blockquote>\n<p>SSL（Secure Sockets Layer）是运行在应用层协议和TCP协议之间的<code>安全套接层</code>协议，在<strong>传输层</strong>对网络连接进行加密。SSL协议分为两层。<strong>SSL记录协议</strong>和<strong>SSL握手协议</strong>，<code>记录协议</code>建立在TCP协议上，为高层协议（HTTP等）提供数据封装，压缩，加密等基本功能的支持。<code>握手协议</code>，建立在SSL记录协议之上，在真正的数据传输开始之前，对通信双方的身份进行认证，协商加密算法，计算<code>对话密钥</code>等。</p>\n</blockquote>\n<h2 id=\"为什么要有SSL\"><a href=\"#为什么要有SSL\" class=\"headerlink\" title=\"为什么要有SSL\"></a>为什么要有SSL</h2><p>HTTP 通信是明文的，没有加密的，存在着三大风险</p>\n<ol>\n<li>窃听风险:  通信内容会被第三方获知</li>\n<li>篡改风险:  通信内容存在被篡改的风险</li>\n<li>冒充风险:  黑客可以冒充身份参与通信</li>\n</ol>\n<p>为了解决这三个风险，SSL就出生了。HTTPS就是利用了SSL协议.或者是升级了的SSL协议（TLS）</p>\n<h2 id=\"对称加密是什么\"><a href=\"#对称加密是什么\" class=\"headerlink\" title=\"对称加密是什么\"></a>对称加密是什么</h2><p>加密和解密使用一份相同的密钥，密钥泄漏的话，通信的内容就会被任何知道密钥的人解密。所以对称加密主要是要注意密钥的保密性。</p>\n<p>公式： </p>\n<p>发送方： E(明文，密钥) = 密文</p>\n<p>接收方： D(密文，密钥) = 明文</p>\n<p>对称加密算法有AES, DES等。用得比较多的是AES算法。</p>\n<h2 id=\"非对称加密又是什么\"><a href=\"#非对称加密又是什么\" class=\"headerlink\" title=\"非对称加密又是什么\"></a>非对称加密又是什么</h2><p>非对称加密是指，通信双方分别持有一个不同的密钥，称作<code>私钥</code>和<code>公钥</code>。一般来说，私钥和公钥是相对的，两者都可以用来加密解密，一般公开的就是公钥，而私密的不为人知的就是私钥了。公钥加密的数据只能被私钥解密，而私钥加密的数据，也只能被公钥解密。保证这种加密的可靠性就是需要保证私钥的保密性，公钥是明文传输的。</p>\n<p>公式：</p>\n<p>E(明文，公钥) = 密文  </p>\n<p>D(密文，私钥) = 明文</p>\n<p>或者也可以</p>\n<p>E(明文，私钥) = 密文</p>\n<p>D(密文，公钥) = 明文</p>\n<p>就是说，公钥和私钥都可以用来加密和解密，用一种密钥加密，只有另外一种密钥可以解密。公钥被人篡改怎么办呢？这时数字证书就出现了.看下面解释.</p>\n<h2 id=\"SSL用哪种加密算法？\"><a href=\"#SSL用哪种加密算法？\" class=\"headerlink\" title=\"SSL用哪种加密算法？\"></a>SSL用哪种加密算法？</h2><p>SSL协议握手阶段利用非对称加密来产生<code>对话密钥</code>（Session Secret），之后就利用<code>对话密钥</code>来对通信信息进行对称加密。</p>\n<p>所以说，SSL其实是两种加密算法都使用到了。</p>\n<h2 id=\"如何解决三大风险呢？\"><a href=\"#如何解决三大风险呢？\" class=\"headerlink\" title=\"如何解决三大风险呢？\"></a>如何解决三大风险呢？</h2><h3 id=\"解决窃听风险\"><a href=\"#解决窃听风险\" class=\"headerlink\" title=\"解决窃听风险\"></a>解决窃听风险</h3><p>将传输数据加密，接收方用密钥来解密数据.因此就算数据被监听到了，也无法知道具体含义，不过劫持数据的一方可以对服务器或者客户端进行<code>重放攻击</code>，就是将劫持到的加密数据原封不动地重新发送给接收方，从而达到攻击的目的。解决重放攻击的方法大概有三种： </p>\n<ol>\n<li>添加时间戳。 发送方发送报文的时候需要加上当前时间的时间戳，接收方根据本地时间和接收到的报文的时间戳进行对比，如果不符合，则丢弃这个信息。</li>\n<li>加随机数。每个报文都添加一个随机数（唯一的），如果某个随机数重复出现，则说明是遇到了重放攻击。</li>\n<li>加流水号。递增的流水号，只要接收到不连续的流水号报文，就说明可能是重放攻击。</li>\n</ol>\n<h3 id=\"解决篡改风险\"><a href=\"#解决篡改风险\" class=\"headerlink\" title=\"解决篡改风险\"></a>解决篡改风险</h3><p>首先就是要先加密了，加密后的数据，没有密钥是修改不了的。再而就是可以用过<code>数字签名</code>。</p>\n<p>数字签名。 可以通过RSA加密算法来实现.</p>\n<p>具体实现步骤如下.</p>\n<p>假如是从客户端发送消息，将要发送的<code>信息</code>先用Hash函数（将任意长度的数据映射为固定长度）生成一份信息摘要，然后再用<code>公钥</code>把摘要加密，生成了<code>数字签名</code>，将数字签名跟消息一起发送。接收方（这里是服务端）收到报文就先把签名拿出来，用<code>私钥</code>解密签名，得到发送方发送的消息的摘要，再用与发送方一样的hash函数，对消息进行处理，得到接受到的消息的摘要，两者对比，就可以判断说数据是否改变。而原理呢就是利用hash函数的特性。一个数据只要修改了一点点，对应的hash值都会变化很大，所以可以用来比较是否被修改过。而且hash是不可逆的。</p>\n<p>画个图加深印象：</p>\n<p>同理服务端发送添加数字签名也是这样，只是是用私钥来加密，然后客户端用公钥来解密获得摘要并与收到的消息进行对比。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fppp2339aoj20pr0bg7ef.jpg\" alt=\"\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fppp1dkadrj20rw0afwo4.jpg\" alt=\"\"></p>\n<p>个人觉得这里的消息可以是明文的也可以是加密过的。如果发送的是CA机构（证书颁发机构）颁发的数字证书的话，一般证书的内容会包含<code>证书颁发者的数字签名</code>（CA机构用自己的私钥来加密信息摘要）和一份被颁发对象的公钥，这份公钥就是明文的了。这就是明文的一种情况。还有一种情况就是，你发送的消息也需要加密，并且需要一份数字签名来防止被篡改，这时就需要</p>\n<h3 id=\"解决冒充风险\"><a href=\"#解决冒充风险\" class=\"headerlink\" title=\"解决冒充风险\"></a>解决冒充风险</h3><p>数字签名只是解决了发送数据有没有被篡改的问题，具体发送方是谁并没有办法知道，这时候只能让发送方出示它的身份证，也就是<code>数字证书</code>。<br>配备数字证书。通过数字证书来识别身份。</p>\n<p>数字证书是网上的身份证明。</p>\n<p>对应的有客户端证书，服务端证书。</p>\n<h4 id=\"CA-amp-数字证书\"><a href=\"#CA-amp-数字证书\" class=\"headerlink\" title=\"CA &amp; 数字证书\"></a>CA &amp; 数字证书</h4><p>CA：证书颁发机构<br>一台服务器要为客户端提供SSL服务，首先得向CA申请一份证书，用于证明自己</p>\n<p>证书一般包括：</p>\n<ul>\n<li>申请者的域名</li>\n<li>签发机构CA</li>\n<li>有效期</li>\n<li>公钥</li>\n<li>指纹（签名）</li>\n<li>等等…如下图</li>\n</ul>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fpqc63bjwbj20f3066jrd.jpg\" alt=\"\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fpqc772eutj20d306zaac.jpg\" alt=\"\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fpqc7vcgjaj203x01ngle.jpg\" alt=\"\"></p>\n<h2 id=\"SSL是如何做到的？-amp-SSL握手阶段\"><a href=\"#SSL是如何做到的？-amp-SSL握手阶段\" class=\"headerlink\" title=\"SSL是如何做到的？&amp; SSL握手阶段\"></a>SSL是如何做到的？&amp; SSL握手阶段</h2><p>SSL四次握手。由客户端发起。</p>\n<ol>\n<li><p>clientHello：客户端向服务端sayHello，告诉服务端说想要建立SSL协议，并告诉它我支持的协议版本还有支持的加密算法（一般是RSA），并且还有发送一个随机数<code>RNc</code>（用于待会生成对话密钥）</p>\n</li>\n<li><p>SeverHello：服务端先确认支持的协议版本，如果协议版本不符合，则关闭SSL握手。否则，还有发送一个随机数<code>RNs</code>（用于待会生成对话密钥），<code>服务器证书</code>，还有就是确认跟客户端一样的加密算法。并向客户端要求客户端证书（如果客户端有的话）来识别客户端身份</p>\n</li>\n<li><p>clientEnd： 首先验证证书（TL;DR 客户端先取得证书里的数字签名，用<code>CA的公钥</code>（<code>一般浏览器会内置CA根证书，包含了CA的公钥</code>）解密，获得摘要，再将数字证书用hash函数进行处理，得到另一个摘要，与前者比较，若没有变化，说明证书有效，没被篡改），如果客户端有客户端证书就发送证书，若无，则发送客户端的公钥。再生成一个随机数<code>PMS</code> ( <code>pre-master-secret</code> ), 用<code>服务端的公钥</code>加密后发送，再发送一个签名<code>public key(hash(先前发的全部消息))</code>。</p>\n</li>\n<li><p>serverEnd: 接受到客户端的消息，验证签名，由三个随机数使用与客户端约定好的某种计算方式来生成<code>对话密钥</code>，对话密钥不会传输，而是通信双方根据前面使用非对称加密来握手产生的三个随机数来生成，为什么要使用三个随机数？因为单独使用一个PMS来生成对话密钥的话，并不能保证说客户端每次生成的PMS都是一个新的随机数，所以就存在这个随机数可能被猜出来的可能性，用三个随机数来生成的话，三个随机数的随机度就基本可以保证每次会话的对话密钥都不一样。所以采用三个随机数来生成对话密钥。客户端此时也使用约定好的计算方法计算出对话密钥。</p>\n</li>\n</ol>\n<p>之后的通信，都是采用对称加密，因为非对称加密比较耗性能，花费时间会增加，之前的SSL握手就是先利用非对称加密（RSA）来生成一个<code>对话密钥</code>，用于对称加密，对称加密的性能会更好，速度更快，同时这个对话密钥由于是如上生成的，所以也很安全。</p>\n<h2 id=\"SSL解决的问题\"><a href=\"#SSL解决的问题\" class=\"headerlink\" title=\"SSL解决的问题\"></a>SSL解决的问题</h2><p>SSL解决了三大风险<br>窃听风险：  信息都是加密的。</p>\n<p>篡改风险：  利用RSA算法生成数字签名来规避这个风险</p>\n<p>冒充风险：  利用数字证书。可信的CA机构发布的数字证书就是一个服务端的身份证。而对于客户端的防冒充来说，如果没有客户端证书，服务端则得到的是客户端的公钥，那么只有拥有正确私钥的客户端才能解密消息，所以也规避了客户端冒充的风险。</p>\n<p>而平常通信的验证客户端的方式是给客户端分发一个sessionId.每次客户端发送消息都会带上这个sessionId（一般存在cookie里）</p>\n<h2 id=\"in-the-end\"><a href=\"#in-the-end\" class=\"headerlink\" title=\"in the end\"></a>in the end</h2><p>HTTPS是未来的主流。得空把自己的网站搞个小绿锁。</p>"},{"title":"2017-NW-暑假-奇妙之旅","date":"2017-08-13T16:00:00.000Z","tabs":["暑假",2017],"_content":"\n\n这个暑假, 是真的充实.\n<!-- more -->\n那天在回家的车上就想码点什么,可是一直码不出来,索性睡觉,回到家,颓了两天,幸好有带键盘回来,不然的话,感觉我的手指一点也不想码字.估计只想拿着西瓜一边吃一边看电视了.\n2017这个暑假啊,呃...我总结为这几个词, `填坑`, `踩坑`,`重聚`,`玩耍`  \n\n## 填坑\n\n说来真是惭愧,之前学的东西一直没去刻意地去使用去复习它,所以..很多都忘了.这个暑假啊,一开始就是在填坑,都是自己之前没有认真学习给自己挖下的坑.这个也是一个教训,希望儿子们平常要向红莲学习,多码点东西.  \n(阿莲真的很严格).   \n\n这填坑啊,也让自己也复习了比较基础的东西,这也算是一个..弥补吧.人啊,总是在感叹世上有没有后悔药,事实是没有的,可是,我们可以亡羊补牢...慢慢填坑,可你在填坑的时候,你就没办法去踩别的坑了.(学习新的知识),所以,还是一开始就不要给自己挖坑了,保持学习(停下来又得回去找状态,很难受的).\n\n## 踩坑\n\n这暑假新接触了微信小程序, 买了个VPS(有空就可以折腾), 学习工程化, 学习Node, 跟风看了点FP(没真正吸收), 总结起来还是觉得微信小程序和前端工程化搞得比较多. 虽然真正学的东西不是很多,我也不想重蹈覆辙,所以接下来就是要尽量去使用了,巩固知识.\n\n## 重聚\n\n从1月份放寒假到我们6/1搬过去120,因为场地问题,我们有好长时间没有在一起,我也感觉我个人受周围环境影响比较多,...很容易就浮躁,不想学东西.在中间这段真空期后,我们重新聚在一起学习,coding了,我感觉很好哈哈哈.毕竟有红莲带飞.虽然可以这样说是因为\"Moka\",我们才有得场地可以用.但是还是谢谢师兄.做项目时,其实红莲一个人抗得挺多的.隐约感觉我自己,还有大家都有点依赖红莲了呃... 不行,(阿莲觉得不行).呃..要加油靠自己.(谢谢我们的CTO,给了大家很多帮助)  \n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fiihsznyooj22o03k04qs.jpg)\n\n也很感谢红莲,花菜,momo,JamesZhong, 兔子的陪伴.这一年大家在一起学习,玩耍,很是开心.\n\n## 玩耍\n\n新捞仔们很是有趣,因为你们也让这整个暑假充满了欢声笑语.   \n结束我们的夏令营,开始顺德之旅,吃得很开心,玩得也很开心.\n心疼下debug的两位大佬.  \n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fiihrluk2pj22ao2aoqv5.jpg)  \n吃了挺多好吃的, 毋米粥, 双皮奶, 私房菜, 茶餐厅, 伦教糕...等等.\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fiiivaegwwj20no0hswh1.jpg)\n\n晚上我们给郁卓过生日, 蛋糕是真好吃啊. \n  \n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fiihpd4gtzj20zk0zkwfb.jpg)\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fiihs6f3egj22ao2aou0x.jpg)\n  \n\n12人UNO,大家各种针对,玩到空气都变热了... 狼人也玩得很high, 结束战局, 我的内心还久久不能平息, 再来一把,我要狼牌!  \n\n荣耀都已经开心到模糊了.\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fiichk59vlj20qo0zkdid.jpg)  \n\n呃.....不可描述\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fiihphguwgj20qo0zkwh3.jpg)\n\n回来岛内还去了科中看战狼2,在公交车上还遇到一个精神有点问题的走失的女人, 第一次打派出所的电话,紧张到公交车站都说错了, 这真是这整个暑假的奇妙的结局.\n\n## 结尾\n\n已经是大三狗了, 时间也不等人, 自己也要抓紧了.  \n\n大二的捞仔们, 我能告诉你们的就是 要保持学习, 保持coding. 一旦停滞,荒废度过, 还得花时间填坑, 那还不如一开始就好好学,好好练习呢.前方道路远又远又远.加油. \nNight's Watch 靠你们了.(呃...画风不太对) \n\n我们这个暑假唯一的合照,还是勉强在KFC拍的.(大家真稳,去顺德还真的只是吃而已,没想到拍照留念哈哈哈) \n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fiiishdoemj20zk0qo7ds.jpg) \n溜了溜了.. 学车真是苦. 希望...不要黑成碳就好了","source":"_posts/Summer-Vacation.md","raw":"---\ntitle: 2017-NW-暑假-奇妙之旅\ncategory: 日常生活\ndate: 2017-8-14\ntabs: [暑假, 2017]\n---\n\n\n这个暑假, 是真的充实.\n<!-- more -->\n那天在回家的车上就想码点什么,可是一直码不出来,索性睡觉,回到家,颓了两天,幸好有带键盘回来,不然的话,感觉我的手指一点也不想码字.估计只想拿着西瓜一边吃一边看电视了.\n2017这个暑假啊,呃...我总结为这几个词, `填坑`, `踩坑`,`重聚`,`玩耍`  \n\n## 填坑\n\n说来真是惭愧,之前学的东西一直没去刻意地去使用去复习它,所以..很多都忘了.这个暑假啊,一开始就是在填坑,都是自己之前没有认真学习给自己挖下的坑.这个也是一个教训,希望儿子们平常要向红莲学习,多码点东西.  \n(阿莲真的很严格).   \n\n这填坑啊,也让自己也复习了比较基础的东西,这也算是一个..弥补吧.人啊,总是在感叹世上有没有后悔药,事实是没有的,可是,我们可以亡羊补牢...慢慢填坑,可你在填坑的时候,你就没办法去踩别的坑了.(学习新的知识),所以,还是一开始就不要给自己挖坑了,保持学习(停下来又得回去找状态,很难受的).\n\n## 踩坑\n\n这暑假新接触了微信小程序, 买了个VPS(有空就可以折腾), 学习工程化, 学习Node, 跟风看了点FP(没真正吸收), 总结起来还是觉得微信小程序和前端工程化搞得比较多. 虽然真正学的东西不是很多,我也不想重蹈覆辙,所以接下来就是要尽量去使用了,巩固知识.\n\n## 重聚\n\n从1月份放寒假到我们6/1搬过去120,因为场地问题,我们有好长时间没有在一起,我也感觉我个人受周围环境影响比较多,...很容易就浮躁,不想学东西.在中间这段真空期后,我们重新聚在一起学习,coding了,我感觉很好哈哈哈.毕竟有红莲带飞.虽然可以这样说是因为\"Moka\",我们才有得场地可以用.但是还是谢谢师兄.做项目时,其实红莲一个人抗得挺多的.隐约感觉我自己,还有大家都有点依赖红莲了呃... 不行,(阿莲觉得不行).呃..要加油靠自己.(谢谢我们的CTO,给了大家很多帮助)  \n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fiihsznyooj22o03k04qs.jpg)\n\n也很感谢红莲,花菜,momo,JamesZhong, 兔子的陪伴.这一年大家在一起学习,玩耍,很是开心.\n\n## 玩耍\n\n新捞仔们很是有趣,因为你们也让这整个暑假充满了欢声笑语.   \n结束我们的夏令营,开始顺德之旅,吃得很开心,玩得也很开心.\n心疼下debug的两位大佬.  \n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fiihrluk2pj22ao2aoqv5.jpg)  \n吃了挺多好吃的, 毋米粥, 双皮奶, 私房菜, 茶餐厅, 伦教糕...等等.\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fiiivaegwwj20no0hswh1.jpg)\n\n晚上我们给郁卓过生日, 蛋糕是真好吃啊. \n  \n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fiihpd4gtzj20zk0zkwfb.jpg)\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fiihs6f3egj22ao2aou0x.jpg)\n  \n\n12人UNO,大家各种针对,玩到空气都变热了... 狼人也玩得很high, 结束战局, 我的内心还久久不能平息, 再来一把,我要狼牌!  \n\n荣耀都已经开心到模糊了.\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fiichk59vlj20qo0zkdid.jpg)  \n\n呃.....不可描述\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fiihphguwgj20qo0zkwh3.jpg)\n\n回来岛内还去了科中看战狼2,在公交车上还遇到一个精神有点问题的走失的女人, 第一次打派出所的电话,紧张到公交车站都说错了, 这真是这整个暑假的奇妙的结局.\n\n## 结尾\n\n已经是大三狗了, 时间也不等人, 自己也要抓紧了.  \n\n大二的捞仔们, 我能告诉你们的就是 要保持学习, 保持coding. 一旦停滞,荒废度过, 还得花时间填坑, 那还不如一开始就好好学,好好练习呢.前方道路远又远又远.加油. \nNight's Watch 靠你们了.(呃...画风不太对) \n\n我们这个暑假唯一的合照,还是勉强在KFC拍的.(大家真稳,去顺德还真的只是吃而已,没想到拍照留念哈哈哈) \n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fiiishdoemj20zk0qo7ds.jpg) \n溜了溜了.. 学车真是苦. 希望...不要黑成碳就好了","slug":"Summer-Vacation","published":1,"updated":"2017-08-13T23:47:04.616Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf81eh7j0009v4efjvnc2qfd","content":"<p>这个暑假, 是真的充实.<br><a id=\"more\"></a><br>那天在回家的车上就想码点什么,可是一直码不出来,索性睡觉,回到家,颓了两天,幸好有带键盘回来,不然的话,感觉我的手指一点也不想码字.估计只想拿着西瓜一边吃一边看电视了.<br>2017这个暑假啊,呃…我总结为这几个词, <code>填坑</code>, <code>踩坑</code>,<code>重聚</code>,<code>玩耍</code>  </p>\n<h2 id=\"填坑\"><a href=\"#填坑\" class=\"headerlink\" title=\"填坑\"></a>填坑</h2><p>说来真是惭愧,之前学的东西一直没去刻意地去使用去复习它,所以..很多都忘了.这个暑假啊,一开始就是在填坑,都是自己之前没有认真学习给自己挖下的坑.这个也是一个教训,希望儿子们平常要向红莲学习,多码点东西.<br>(阿莲真的很严格).   </p>\n<p>这填坑啊,也让自己也复习了比较基础的东西,这也算是一个..弥补吧.人啊,总是在感叹世上有没有后悔药,事实是没有的,可是,我们可以亡羊补牢…慢慢填坑,可你在填坑的时候,你就没办法去踩别的坑了.(学习新的知识),所以,还是一开始就不要给自己挖坑了,保持学习(停下来又得回去找状态,很难受的).</p>\n<h2 id=\"踩坑\"><a href=\"#踩坑\" class=\"headerlink\" title=\"踩坑\"></a>踩坑</h2><p>这暑假新接触了微信小程序, 买了个VPS(有空就可以折腾), 学习工程化, 学习Node, 跟风看了点FP(没真正吸收), 总结起来还是觉得微信小程序和前端工程化搞得比较多. 虽然真正学的东西不是很多,我也不想重蹈覆辙,所以接下来就是要尽量去使用了,巩固知识.</p>\n<h2 id=\"重聚\"><a href=\"#重聚\" class=\"headerlink\" title=\"重聚\"></a>重聚</h2><p>从1月份放寒假到我们6/1搬过去120,因为场地问题,我们有好长时间没有在一起,我也感觉我个人受周围环境影响比较多,…很容易就浮躁,不想学东西.在中间这段真空期后,我们重新聚在一起学习,coding了,我感觉很好哈哈哈.毕竟有红莲带飞.虽然可以这样说是因为”Moka”,我们才有得场地可以用.但是还是谢谢师兄.做项目时,其实红莲一个人抗得挺多的.隐约感觉我自己,还有大家都有点依赖红莲了呃… 不行,(阿莲觉得不行).呃..要加油靠自己.(谢谢我们的CTO,给了大家很多帮助)  </p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fiihsznyooj22o03k04qs.jpg\" alt=\"\"></p>\n<p>也很感谢红莲,花菜,momo,JamesZhong, 兔子的陪伴.这一年大家在一起学习,玩耍,很是开心.</p>\n<h2 id=\"玩耍\"><a href=\"#玩耍\" class=\"headerlink\" title=\"玩耍\"></a>玩耍</h2><p>新捞仔们很是有趣,因为你们也让这整个暑假充满了欢声笑语.<br>结束我们的夏令营,开始顺德之旅,吃得很开心,玩得也很开心.<br>心疼下debug的两位大佬.  </p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fiihrluk2pj22ao2aoqv5.jpg\" alt=\"\"><br>吃了挺多好吃的, 毋米粥, 双皮奶, 私房菜, 茶餐厅, 伦教糕…等等.<br><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fiiivaegwwj20no0hswh1.jpg\" alt=\"\"></p>\n<p>晚上我们给郁卓过生日, 蛋糕是真好吃啊. </p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fiihpd4gtzj20zk0zkwfb.jpg\" alt=\"\"><br><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fiihs6f3egj22ao2aou0x.jpg\" alt=\"\"></p>\n<p>12人UNO,大家各种针对,玩到空气都变热了… 狼人也玩得很high, 结束战局, 我的内心还久久不能平息, 再来一把,我要狼牌!  </p>\n<p>荣耀都已经开心到模糊了.<br><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fiichk59vlj20qo0zkdid.jpg\" alt=\"\">  </p>\n<p>呃…..不可描述<br><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fiihphguwgj20qo0zkwh3.jpg\" alt=\"\"></p>\n<p>回来岛内还去了科中看战狼2,在公交车上还遇到一个精神有点问题的走失的女人, 第一次打派出所的电话,紧张到公交车站都说错了, 这真是这整个暑假的奇妙的结局.</p>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>已经是大三狗了, 时间也不等人, 自己也要抓紧了.  </p>\n<p>大二的捞仔们, 我能告诉你们的就是 要保持学习, 保持coding. 一旦停滞,荒废度过, 还得花时间填坑, 那还不如一开始就好好学,好好练习呢.前方道路远又远又远.加油.<br>Night’s Watch 靠你们了.(呃…画风不太对) </p>\n<p>我们这个暑假唯一的合照,还是勉强在KFC拍的.(大家真稳,去顺德还真的只是吃而已,没想到拍照留念哈哈哈) </p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fiiishdoemj20zk0qo7ds.jpg\" alt=\"\"><br>溜了溜了.. 学车真是苦. 希望…不要黑成碳就好了</p>\n","site":{"data":{}},"excerpt":"<p>这个暑假, 是真的充实.<br>","more":"<br>那天在回家的车上就想码点什么,可是一直码不出来,索性睡觉,回到家,颓了两天,幸好有带键盘回来,不然的话,感觉我的手指一点也不想码字.估计只想拿着西瓜一边吃一边看电视了.<br>2017这个暑假啊,呃…我总结为这几个词, <code>填坑</code>, <code>踩坑</code>,<code>重聚</code>,<code>玩耍</code>  </p>\n<h2 id=\"填坑\"><a href=\"#填坑\" class=\"headerlink\" title=\"填坑\"></a>填坑</h2><p>说来真是惭愧,之前学的东西一直没去刻意地去使用去复习它,所以..很多都忘了.这个暑假啊,一开始就是在填坑,都是自己之前没有认真学习给自己挖下的坑.这个也是一个教训,希望儿子们平常要向红莲学习,多码点东西.<br>(阿莲真的很严格).   </p>\n<p>这填坑啊,也让自己也复习了比较基础的东西,这也算是一个..弥补吧.人啊,总是在感叹世上有没有后悔药,事实是没有的,可是,我们可以亡羊补牢…慢慢填坑,可你在填坑的时候,你就没办法去踩别的坑了.(学习新的知识),所以,还是一开始就不要给自己挖坑了,保持学习(停下来又得回去找状态,很难受的).</p>\n<h2 id=\"踩坑\"><a href=\"#踩坑\" class=\"headerlink\" title=\"踩坑\"></a>踩坑</h2><p>这暑假新接触了微信小程序, 买了个VPS(有空就可以折腾), 学习工程化, 学习Node, 跟风看了点FP(没真正吸收), 总结起来还是觉得微信小程序和前端工程化搞得比较多. 虽然真正学的东西不是很多,我也不想重蹈覆辙,所以接下来就是要尽量去使用了,巩固知识.</p>\n<h2 id=\"重聚\"><a href=\"#重聚\" class=\"headerlink\" title=\"重聚\"></a>重聚</h2><p>从1月份放寒假到我们6/1搬过去120,因为场地问题,我们有好长时间没有在一起,我也感觉我个人受周围环境影响比较多,…很容易就浮躁,不想学东西.在中间这段真空期后,我们重新聚在一起学习,coding了,我感觉很好哈哈哈.毕竟有红莲带飞.虽然可以这样说是因为”Moka”,我们才有得场地可以用.但是还是谢谢师兄.做项目时,其实红莲一个人抗得挺多的.隐约感觉我自己,还有大家都有点依赖红莲了呃… 不行,(阿莲觉得不行).呃..要加油靠自己.(谢谢我们的CTO,给了大家很多帮助)  </p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fiihsznyooj22o03k04qs.jpg\" alt=\"\"></p>\n<p>也很感谢红莲,花菜,momo,JamesZhong, 兔子的陪伴.这一年大家在一起学习,玩耍,很是开心.</p>\n<h2 id=\"玩耍\"><a href=\"#玩耍\" class=\"headerlink\" title=\"玩耍\"></a>玩耍</h2><p>新捞仔们很是有趣,因为你们也让这整个暑假充满了欢声笑语.<br>结束我们的夏令营,开始顺德之旅,吃得很开心,玩得也很开心.<br>心疼下debug的两位大佬.  </p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fiihrluk2pj22ao2aoqv5.jpg\" alt=\"\"><br>吃了挺多好吃的, 毋米粥, 双皮奶, 私房菜, 茶餐厅, 伦教糕…等等.<br><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fiiivaegwwj20no0hswh1.jpg\" alt=\"\"></p>\n<p>晚上我们给郁卓过生日, 蛋糕是真好吃啊. </p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fiihpd4gtzj20zk0zkwfb.jpg\" alt=\"\"><br><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fiihs6f3egj22ao2aou0x.jpg\" alt=\"\"></p>\n<p>12人UNO,大家各种针对,玩到空气都变热了… 狼人也玩得很high, 结束战局, 我的内心还久久不能平息, 再来一把,我要狼牌!  </p>\n<p>荣耀都已经开心到模糊了.<br><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fiichk59vlj20qo0zkdid.jpg\" alt=\"\">  </p>\n<p>呃…..不可描述<br><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fiihphguwgj20qo0zkwh3.jpg\" alt=\"\"></p>\n<p>回来岛内还去了科中看战狼2,在公交车上还遇到一个精神有点问题的走失的女人, 第一次打派出所的电话,紧张到公交车站都说错了, 这真是这整个暑假的奇妙的结局.</p>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>已经是大三狗了, 时间也不等人, 自己也要抓紧了.  </p>\n<p>大二的捞仔们, 我能告诉你们的就是 要保持学习, 保持coding. 一旦停滞,荒废度过, 还得花时间填坑, 那还不如一开始就好好学,好好练习呢.前方道路远又远又远.加油.<br>Night’s Watch 靠你们了.(呃…画风不太对) </p>\n<p>我们这个暑假唯一的合照,还是勉强在KFC拍的.(大家真稳,去顺德还真的只是吃而已,没想到拍照留念哈哈哈) </p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fiiishdoemj20zk0qo7ds.jpg\" alt=\"\"><br>溜了溜了.. 学车真是苦. 希望…不要黑成碳就好了</p>"},{"title":"Ubuntu使用SS的方法总结","date":"2017-07-16T16:00:00.000Z","_content":"\n# Ubuntu安装使用ss的方法.\n\n前些日子想在Ubuntu上搞SS翻墙用下谷歌,在网上找了好多方法..(如下载SS-qt5版客户端等)都没搞定...所以索性回到windows系统学习和开发了...\n暑假的某一天晚上又想用回ubuntu,这次下载了SS python版的客户端  \nhttps://github.com/breakwa11/shadowsocks-rss/wiki/Python-client-setup-(Mult-language)  \n在红莲的的帮忙下,实现了我去墙外了解世界的梦想.(滑稽.jpg); 下面就是安装和配置步骤了..\n\n以上是摘要  \n\n<!-- more -->\n\n\n## 获取源代码(安装SS,python客户端)\n首先是装git,我已经装了git的,所以这步骤跳过.  \n新建一个文件夹,进入命令行界面,执行代码\n``` bash \ngit clone -b manyuser https://github.com/shadowsocksr/shadowsocksr.git\n\n```\n进入子目录:\n``` bash \ncd shadowsocksr/shadowsocks\n```\n\n我这里是通过配置文件运行的,所以我先写好配置文件ss.json,并把配置文件放到此目录下..\n配置文件写入以下内容:  \n**注意**: json文件不能有注释代码...\n\n```\n{\n    \"server\":\"0.0.0.0\",\n    \"server_ipv6\": \"::\",\n    \"server_port\":8388,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"mypassword\",\n    \"timeout\":300,\n    \"udp_timeout\": 60,\n    \"method\":\"aes-256-cfb\",\n    \"protocol\": \"auth_aes128_md5\",\n    \"protocol_param\": \"\",\n    \"obfs\":\"http_simple\",\n    \"obfs_param\": \"\",\n    \"fast_open\": false,\n    \"workers\": 1\n}\n```\n一般需要更改的有 服务器地址,端口号,密码,加密方式,使用协议.\n\n然后就运行这个配置文件,命令如下  \n后台运行:  \n\n``` bash \npython local.py -c ./ss.json -d start\n```\n为了方便我把此命令写入be.sh文件方便调用. 如下  \n``` bash\nvim be.sh\n```\n*be.sh*\n``` bash \npython local.py -c ./ss.json -d start\n```\n:wq 保存退出  \n\n给be.sh 增加权限,修改be.sh为可执行文件 (chmod +x filename)\n``` bash\nchmod +x be.sh\n```\n然后运行be.sh文件\n``` bash \n./be.sh\n```\n此时ss已经开启,墙外的世界已经连上了...\n\n然后使用google搜索,不出意外,应该可以成功使用.  \n\n## 配置PAC代理\n然后就是配置PAC代理了\n\n**安装genpac**  \n这是基于gfwlist的代理自动配置Proxy Auto-config)文件生成工具,支持自定义规则..  \n选择生成文件的存放位置进入命令行,我是放在~/etc/里面的  \n执行命令\n\n``` bash \nsudo pip install genpac\n```\n进入生成文件的位置\n``` bash \ncd ~/etc/vpnPAC\n\nsudo genpac --proxy=\"SOCKS5 127.0.0.1:1080\" -o autoproxy.pac --gfwlist-url=\"https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt\"\n```\n然后可以看到生成了一个文件autoproxy.pac  \n执行pwd命令查看文件所在路径待会需要用到\n```\npwd\n```\n我这里是/home/chenpengteng/etc/vpnPAC/\n\n### 将代理应用到整个系统\n\n系统设置=>网络=>网络代理  \n\"方法\"选择**自动**,\"配置URL\"填写 file:///home/chenpengteng/etc/vpnPAC/autoproxy.pac  \n点击\"应用到整个系统\",整个步骤将完成了,此时进入baidu是秒进,进入谷歌也可以进入..说明已经配置成功...  \n好了,可以使用google了,美滋滋,话说...在安装配置ss的过程中,在baidu搜有关ss的几乎都被屏蔽了..不得已使用红莲的电脑使用google搜索...\n\n\n>参考文章: http://blog.csdn.net/u012810317/article/details/52139361  \n> https://github.com/breakwa11/shadowsocks-rss/wiki/Python-client-setup-(Mult-language)","source":"_posts/Ubuntu-install-Shadowsocks.md","raw":"---\ntitle: Ubuntu使用SS的方法总结\ncategory: Ubuntu\ntags: [Ubuntu, Shadowsocks]\ndate: 2017-07-17\n---\n\n# Ubuntu安装使用ss的方法.\n\n前些日子想在Ubuntu上搞SS翻墙用下谷歌,在网上找了好多方法..(如下载SS-qt5版客户端等)都没搞定...所以索性回到windows系统学习和开发了...\n暑假的某一天晚上又想用回ubuntu,这次下载了SS python版的客户端  \nhttps://github.com/breakwa11/shadowsocks-rss/wiki/Python-client-setup-(Mult-language)  \n在红莲的的帮忙下,实现了我去墙外了解世界的梦想.(滑稽.jpg); 下面就是安装和配置步骤了..\n\n以上是摘要  \n\n<!-- more -->\n\n\n## 获取源代码(安装SS,python客户端)\n首先是装git,我已经装了git的,所以这步骤跳过.  \n新建一个文件夹,进入命令行界面,执行代码\n``` bash \ngit clone -b manyuser https://github.com/shadowsocksr/shadowsocksr.git\n\n```\n进入子目录:\n``` bash \ncd shadowsocksr/shadowsocks\n```\n\n我这里是通过配置文件运行的,所以我先写好配置文件ss.json,并把配置文件放到此目录下..\n配置文件写入以下内容:  \n**注意**: json文件不能有注释代码...\n\n```\n{\n    \"server\":\"0.0.0.0\",\n    \"server_ipv6\": \"::\",\n    \"server_port\":8388,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"mypassword\",\n    \"timeout\":300,\n    \"udp_timeout\": 60,\n    \"method\":\"aes-256-cfb\",\n    \"protocol\": \"auth_aes128_md5\",\n    \"protocol_param\": \"\",\n    \"obfs\":\"http_simple\",\n    \"obfs_param\": \"\",\n    \"fast_open\": false,\n    \"workers\": 1\n}\n```\n一般需要更改的有 服务器地址,端口号,密码,加密方式,使用协议.\n\n然后就运行这个配置文件,命令如下  \n后台运行:  \n\n``` bash \npython local.py -c ./ss.json -d start\n```\n为了方便我把此命令写入be.sh文件方便调用. 如下  \n``` bash\nvim be.sh\n```\n*be.sh*\n``` bash \npython local.py -c ./ss.json -d start\n```\n:wq 保存退出  \n\n给be.sh 增加权限,修改be.sh为可执行文件 (chmod +x filename)\n``` bash\nchmod +x be.sh\n```\n然后运行be.sh文件\n``` bash \n./be.sh\n```\n此时ss已经开启,墙外的世界已经连上了...\n\n然后使用google搜索,不出意外,应该可以成功使用.  \n\n## 配置PAC代理\n然后就是配置PAC代理了\n\n**安装genpac**  \n这是基于gfwlist的代理自动配置Proxy Auto-config)文件生成工具,支持自定义规则..  \n选择生成文件的存放位置进入命令行,我是放在~/etc/里面的  \n执行命令\n\n``` bash \nsudo pip install genpac\n```\n进入生成文件的位置\n``` bash \ncd ~/etc/vpnPAC\n\nsudo genpac --proxy=\"SOCKS5 127.0.0.1:1080\" -o autoproxy.pac --gfwlist-url=\"https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt\"\n```\n然后可以看到生成了一个文件autoproxy.pac  \n执行pwd命令查看文件所在路径待会需要用到\n```\npwd\n```\n我这里是/home/chenpengteng/etc/vpnPAC/\n\n### 将代理应用到整个系统\n\n系统设置=>网络=>网络代理  \n\"方法\"选择**自动**,\"配置URL\"填写 file:///home/chenpengteng/etc/vpnPAC/autoproxy.pac  \n点击\"应用到整个系统\",整个步骤将完成了,此时进入baidu是秒进,进入谷歌也可以进入..说明已经配置成功...  \n好了,可以使用google了,美滋滋,话说...在安装配置ss的过程中,在baidu搜有关ss的几乎都被屏蔽了..不得已使用红莲的电脑使用google搜索...\n\n\n>参考文章: http://blog.csdn.net/u012810317/article/details/52139361  \n> https://github.com/breakwa11/shadowsocks-rss/wiki/Python-client-setup-(Mult-language)","slug":"Ubuntu-install-Shadowsocks","published":1,"updated":"2017-07-17T05:13:00.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf81eh7n000av4ef08apzmei","content":"<h1 id=\"Ubuntu安装使用ss的方法\"><a href=\"#Ubuntu安装使用ss的方法\" class=\"headerlink\" title=\"Ubuntu安装使用ss的方法.\"></a>Ubuntu安装使用ss的方法.</h1><p>前些日子想在Ubuntu上搞SS翻墙用下谷歌,在网上找了好多方法..(如下载SS-qt5版客户端等)都没搞定…所以索性回到windows系统学习和开发了…<br>暑假的某一天晚上又想用回ubuntu,这次下载了SS python版的客户端<br><a href=\"https://github.com/breakwa11/shadowsocks-rss/wiki/Python-client-setup-(Mult-language)\" target=\"_blank\" rel=\"noopener\">https://github.com/breakwa11/shadowsocks-rss/wiki/Python-client-setup-(Mult-language)</a><br>在红莲的的帮忙下,实现了我去墙外了解世界的梦想.(滑稽.jpg); 下面就是安装和配置步骤了..</p>\n<p>以上是摘要  </p>\n<a id=\"more\"></a>\n<h2 id=\"获取源代码-安装SS-python客户端\"><a href=\"#获取源代码-安装SS-python客户端\" class=\"headerlink\" title=\"获取源代码(安装SS,python客户端)\"></a>获取源代码(安装SS,python客户端)</h2><p>首先是装git,我已经装了git的,所以这步骤跳过.<br>新建一个文件夹,进入命令行界面,执行代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> -b manyuser https://github.com/shadowsocksr/shadowsocksr.git</span><br></pre></td></tr></table></figure></p>\n<p>进入子目录:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> shadowsocksr/shadowsocks</span><br></pre></td></tr></table></figure></p>\n<p>我这里是通过配置文件运行的,所以我先写好配置文件ss.json,并把配置文件放到此目录下..<br>配置文件写入以下内容:<br><strong>注意</strong>: json文件不能有注释代码…</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class=\"line\">    &quot;server_ipv6&quot;: &quot;::&quot;,</span><br><span class=\"line\">    &quot;server_port&quot;:8388,</span><br><span class=\"line\">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class=\"line\">    &quot;local_port&quot;:1080,</span><br><span class=\"line\">    &quot;password&quot;:&quot;mypassword&quot;,</span><br><span class=\"line\">    &quot;timeout&quot;:300,</span><br><span class=\"line\">    &quot;udp_timeout&quot;: 60,</span><br><span class=\"line\">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class=\"line\">    &quot;protocol&quot;: &quot;auth_aes128_md5&quot;,</span><br><span class=\"line\">    &quot;protocol_param&quot;: &quot;&quot;,</span><br><span class=\"line\">    &quot;obfs&quot;:&quot;http_simple&quot;,</span><br><span class=\"line\">    &quot;obfs_param&quot;: &quot;&quot;,</span><br><span class=\"line\">    &quot;fast_open&quot;: false,</span><br><span class=\"line\">    &quot;workers&quot;: 1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一般需要更改的有 服务器地址,端口号,密码,加密方式,使用协议.</p>\n<p>然后就运行这个配置文件,命令如下<br>后台运行:  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python local.py -c ./ss.json -d start</span><br></pre></td></tr></table></figure>\n<p>为了方便我把此命令写入be.sh文件方便调用. 如下<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim be.sh</span><br></pre></td></tr></table></figure></p>\n<p><em>be.sh</em><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python local.py -c ./ss.json -d start</span><br></pre></td></tr></table></figure></p>\n<p>:wq 保存退出  </p>\n<p>给be.sh 增加权限,修改be.sh为可执行文件 (chmod +x filename)<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x be.sh</span><br></pre></td></tr></table></figure></p>\n<p>然后运行be.sh文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./be.sh</span><br></pre></td></tr></table></figure></p>\n<p>此时ss已经开启,墙外的世界已经连上了…</p>\n<p>然后使用google搜索,不出意外,应该可以成功使用.  </p>\n<h2 id=\"配置PAC代理\"><a href=\"#配置PAC代理\" class=\"headerlink\" title=\"配置PAC代理\"></a>配置PAC代理</h2><p>然后就是配置PAC代理了</p>\n<p><strong>安装genpac</strong><br>这是基于gfwlist的代理自动配置Proxy Auto-config)文件生成工具,支持自定义规则..<br>选择生成文件的存放位置进入命令行,我是放在~/etc/里面的<br>执行命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo pip install genpac</span><br></pre></td></tr></table></figure>\n<p>进入生成文件的位置<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~/etc/vpnPAC</span><br><span class=\"line\"></span><br><span class=\"line\">sudo genpac --proxy=<span class=\"string\">\"SOCKS5 127.0.0.1:1080\"</span> -o autoproxy.pac --gfwlist-url=<span class=\"string\">\"https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt\"</span></span><br></pre></td></tr></table></figure></p>\n<p>然后可以看到生成了一个文件autoproxy.pac<br>执行pwd命令查看文件所在路径待会需要用到<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwd</span><br></pre></td></tr></table></figure></p>\n<p>我这里是/home/chenpengteng/etc/vpnPAC/</p>\n<h3 id=\"将代理应用到整个系统\"><a href=\"#将代理应用到整个系统\" class=\"headerlink\" title=\"将代理应用到整个系统\"></a>将代理应用到整个系统</h3><p>系统设置=&gt;网络=&gt;网络代理<br>“方法”选择<strong>自动</strong>,”配置URL”填写 file:///home/chenpengteng/etc/vpnPAC/autoproxy.pac<br>点击”应用到整个系统”,整个步骤将完成了,此时进入baidu是秒进,进入谷歌也可以进入..说明已经配置成功…<br>好了,可以使用google了,美滋滋,话说…在安装配置ss的过程中,在baidu搜有关ss的几乎都被屏蔽了..不得已使用红莲的电脑使用google搜索…</p>\n<blockquote>\n<p>参考文章: <a href=\"http://blog.csdn.net/u012810317/article/details/52139361\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/u012810317/article/details/52139361</a><br><a href=\"https://github.com/breakwa11/shadowsocks-rss/wiki/Python-client-setup-(Mult-language)\" target=\"_blank\" rel=\"noopener\">https://github.com/breakwa11/shadowsocks-rss/wiki/Python-client-setup-(Mult-language)</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"Ubuntu安装使用ss的方法\"><a href=\"#Ubuntu安装使用ss的方法\" class=\"headerlink\" title=\"Ubuntu安装使用ss的方法.\"></a>Ubuntu安装使用ss的方法.</h1><p>前些日子想在Ubuntu上搞SS翻墙用下谷歌,在网上找了好多方法..(如下载SS-qt5版客户端等)都没搞定…所以索性回到windows系统学习和开发了…<br>暑假的某一天晚上又想用回ubuntu,这次下载了SS python版的客户端<br><a href=\"https://github.com/breakwa11/shadowsocks-rss/wiki/Python-client-setup-(Mult-language)\" target=\"_blank\" rel=\"noopener\">https://github.com/breakwa11/shadowsocks-rss/wiki/Python-client-setup-(Mult-language)</a><br>在红莲的的帮忙下,实现了我去墙外了解世界的梦想.(滑稽.jpg); 下面就是安装和配置步骤了..</p>\n<p>以上是摘要  </p>","more":"<h2 id=\"获取源代码-安装SS-python客户端\"><a href=\"#获取源代码-安装SS-python客户端\" class=\"headerlink\" title=\"获取源代码(安装SS,python客户端)\"></a>获取源代码(安装SS,python客户端)</h2><p>首先是装git,我已经装了git的,所以这步骤跳过.<br>新建一个文件夹,进入命令行界面,执行代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> -b manyuser https://github.com/shadowsocksr/shadowsocksr.git</span><br></pre></td></tr></table></figure></p>\n<p>进入子目录:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> shadowsocksr/shadowsocks</span><br></pre></td></tr></table></figure></p>\n<p>我这里是通过配置文件运行的,所以我先写好配置文件ss.json,并把配置文件放到此目录下..<br>配置文件写入以下内容:<br><strong>注意</strong>: json文件不能有注释代码…</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class=\"line\">    &quot;server_ipv6&quot;: &quot;::&quot;,</span><br><span class=\"line\">    &quot;server_port&quot;:8388,</span><br><span class=\"line\">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class=\"line\">    &quot;local_port&quot;:1080,</span><br><span class=\"line\">    &quot;password&quot;:&quot;mypassword&quot;,</span><br><span class=\"line\">    &quot;timeout&quot;:300,</span><br><span class=\"line\">    &quot;udp_timeout&quot;: 60,</span><br><span class=\"line\">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class=\"line\">    &quot;protocol&quot;: &quot;auth_aes128_md5&quot;,</span><br><span class=\"line\">    &quot;protocol_param&quot;: &quot;&quot;,</span><br><span class=\"line\">    &quot;obfs&quot;:&quot;http_simple&quot;,</span><br><span class=\"line\">    &quot;obfs_param&quot;: &quot;&quot;,</span><br><span class=\"line\">    &quot;fast_open&quot;: false,</span><br><span class=\"line\">    &quot;workers&quot;: 1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一般需要更改的有 服务器地址,端口号,密码,加密方式,使用协议.</p>\n<p>然后就运行这个配置文件,命令如下<br>后台运行:  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python local.py -c ./ss.json -d start</span><br></pre></td></tr></table></figure>\n<p>为了方便我把此命令写入be.sh文件方便调用. 如下<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim be.sh</span><br></pre></td></tr></table></figure></p>\n<p><em>be.sh</em><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python local.py -c ./ss.json -d start</span><br></pre></td></tr></table></figure></p>\n<p>:wq 保存退出  </p>\n<p>给be.sh 增加权限,修改be.sh为可执行文件 (chmod +x filename)<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x be.sh</span><br></pre></td></tr></table></figure></p>\n<p>然后运行be.sh文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./be.sh</span><br></pre></td></tr></table></figure></p>\n<p>此时ss已经开启,墙外的世界已经连上了…</p>\n<p>然后使用google搜索,不出意外,应该可以成功使用.  </p>\n<h2 id=\"配置PAC代理\"><a href=\"#配置PAC代理\" class=\"headerlink\" title=\"配置PAC代理\"></a>配置PAC代理</h2><p>然后就是配置PAC代理了</p>\n<p><strong>安装genpac</strong><br>这是基于gfwlist的代理自动配置Proxy Auto-config)文件生成工具,支持自定义规则..<br>选择生成文件的存放位置进入命令行,我是放在~/etc/里面的<br>执行命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo pip install genpac</span><br></pre></td></tr></table></figure>\n<p>进入生成文件的位置<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~/etc/vpnPAC</span><br><span class=\"line\"></span><br><span class=\"line\">sudo genpac --proxy=<span class=\"string\">\"SOCKS5 127.0.0.1:1080\"</span> -o autoproxy.pac --gfwlist-url=<span class=\"string\">\"https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt\"</span></span><br></pre></td></tr></table></figure></p>\n<p>然后可以看到生成了一个文件autoproxy.pac<br>执行pwd命令查看文件所在路径待会需要用到<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwd</span><br></pre></td></tr></table></figure></p>\n<p>我这里是/home/chenpengteng/etc/vpnPAC/</p>\n<h3 id=\"将代理应用到整个系统\"><a href=\"#将代理应用到整个系统\" class=\"headerlink\" title=\"将代理应用到整个系统\"></a>将代理应用到整个系统</h3><p>系统设置=&gt;网络=&gt;网络代理<br>“方法”选择<strong>自动</strong>,”配置URL”填写 file:///home/chenpengteng/etc/vpnPAC/autoproxy.pac<br>点击”应用到整个系统”,整个步骤将完成了,此时进入baidu是秒进,进入谷歌也可以进入..说明已经配置成功…<br>好了,可以使用google了,美滋滋,话说…在安装配置ss的过程中,在baidu搜有关ss的几乎都被屏蔽了..不得已使用红莲的电脑使用google搜索…</p>\n<blockquote>\n<p>参考文章: <a href=\"http://blog.csdn.net/u012810317/article/details/52139361\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/u012810317/article/details/52139361</a><br><a href=\"https://github.com/breakwa11/shadowsocks-rss/wiki/Python-client-setup-(Mult-language)\" target=\"_blank\" rel=\"noopener\">https://github.com/breakwa11/shadowsocks-rss/wiki/Python-client-setup-(Mult-language)</a></p>\n</blockquote>"},{"title":"canvas元素的学习笔记","date":"2016-07-25T17:16:50.000Z","_content":"\n\n## 什么是canvas\nHTML5新增了 canvas元素，专门用来绘制图形，在页面上放置一个canvas元素，相当于在页面上放置一块\"画布\"，画布是一个矩形区域，你可以在其中进行图形的绘制。canvas元素放在html页面中，跟其他标签没太大区别。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。\n## 创建canvas元素\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Canvas~</title>\n</head>\n<body>\n\t<canvas id=\"mycanvas\" width=\"200\" height=\"200\"></canvas>\n</body>\n</html\n```\ncanvas 需指定 ID、width、height 三个属性值\n### 绘制矩形\n**canvas本身是没有绘制能力的，需要通过JavaScript来进行绘制。\n用canvas元素绘制图形时，步骤如下**\n\n - 取得canvas元素（创建canvas元素）\n\n```javascript\nvar canvas = document.getElementById(\"mycanvas\");\n```\n - 取得上下文对象\n```javascript\nvar context = canvas.getContext(\"2d\"); \n```\n利用canvas对象的getContext方法来获得图形上下文，将参数设为“2d”,不能够设置为3d或4d。\n>getContext(\"2d\") 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。\n\n - 设定绘图样式\n```javascript\ncontext.fillStyle = \"AAA\";  //填充的样式,填入填充的颜色值\ncontext.strokeStyle = \"FF0000\"; //图形边框的样式,填入边框的颜色值\n```\n - 绘制图形\n```javascript\ncontext.fillRect(0, 0, 50, 50) // 填充矩形\ncontext.strokeRect(0, 0, 50, 50) //绘制矩形边框\n```\n**x指矩形起点的横坐标，y指矩形起点的纵坐标，width指矩形的长度，height指矩形的高度**\n```\ncontext.clearRect(x,y,width,height)\n```\nclearRect ，该方法可以擦除指定的矩形区域的图形，使得该区域中的颜色全部变为透明。\n\n**设定绘图样式必须在绘制图形之前，如果在绘制图形之后的话，绘图样式会使用默认值，而不是我们设定的那个值**\n```javascript\ncontext.fillRect(0, 0, 50, 50);\ncontext.fillStyle(\"FF0000\");\n//最终图形显示的填充颜色值是默认的黑色而不是我们设定的红色（#FF0000）\n```\n## 使用路径\n### 绘制圆形\n\n 1. 开始创建路径\n 2. 创建圆形路径\n 3. 路径创建完成后，关闭路径\n 4. 设定绘制样式，调用绘制方法，绘制路径\n```javascript\nvar canvas = document.getElmentById(\"mycanvas\");\nvar context = canvas.getContext(\"2d\");\n\ncontext.beginPath();    //创建路径\ncontext.arc(50, 50, 50, 0, Math.PI*2, true);    //创建圆形路径\ncontext.closePath();  //关闭路径\ncontext.fillStyle = \"rgba(100,100,100,0.2)\";    //填充样式，给定颜色值\ncontext.strokeStyle = \"#000\";   //绘制图形边框样式，给定颜色值\ncontext.fill();     //因为路径已经确定了图形的大小，所以不用再使用参数去指定图形的大小,也可以使用stroke 方法\n```\n如果没有关闭路径，创建的路径会永远保留着，如果进行多次绘制，则创建的图形会一次又一次地进行重叠。\n```javascript\nvar canvas = document.getElementById(\"mycanvas\");\nvar context = canvas.getContext(\"2d\");\n\ncontext.fillStyle = \"#EEEEFF\";\ncontext.fillRect(0, 0,500, 500);\nfor(var i = 0;i < 10; i++)\n{\n    context.arc(i*25, i*25, i*10, 0, Math.PI*2, true);\n    context.fillStyle = \"rgba(100,100,100,0.2)\";\n    context.fill();\n}\n```\n如图\n![image](http://note.youdao.com/yws/res/557/WEBRESOURCE880df486be209ef49fe78dd2b41739e1)\n### 绘制直线\n\n 1. moveTo (x,y)  将光标移动到指定坐标点，绘制直线的时候以这个坐标点为起点\n 2. lineTo (x,y)   以moveTo方法设定的点为起点，到自己的参数中指定的点之间绘制一条直线  x表示直线终点的横坐标，y表示终点纵坐标\n\n```javascript\nvar canvas = document.getElementById(\"mycanvas\");\nvar context = canvas.getContext(\"2d\");\ncontext.beginPath();\ncontext.moveTo(20,20);\ncontext,lineTo(50,100);\ncontext.lineWidth = 3;  //设置直线的宽度   ps：需要在stroke前面调用\ncontext.stokeStyle = \"#FF0000\";\ncontext.stroke(); //绘制直线\n``` \n### 绘制渐变图形\n#### 绘制线性渐变\n使用图形上下文的createLinearGradient方法\ncontext.createLinearGradient(xStart, yStart, xEnd, yEnd);\n然后再使用LinearGradient对象的addColorStop方法\naddColorStop(offset, color);\noffset为设定的颜色离开渐变起始点的偏移量，范围为0~1；\n```javascript\nvar g1 = context.createLinearGradient(0, 0, 200, 200);\ng1.addColorStop(0,\"#FF0000\"）;  //起点偏移量为0，颜色为红色\ng1.addColorStop(1,\"#FFF\"); //终点偏移量为1，颜色为白色\n```\n如图：\n![image](http://note.youdao.com/yws/res/560/WEBRESOURCEd2681bd319ed28c140e09ac9e4f84fac)\n#### 绘制径向渐变\n使用图形上下文的createRadiaGradient方法\ncontext.createLinearGradient(xStart, yStart, radiusStart, xEnd, yEnd, radiusEnd);\nxStart为渐变开始圆的圆心横坐标，yStart为圆心纵坐标\n同理xEnd，yEnd为渐变结束圆的圆心横纵坐标。\nradiusStart为渐变开始圆的半径，radiusEnd 为渐变结束圆的半径\n```javascript\nvar canvas = document.getElementById(\"mycanvas\");\nvar context = canvas.getContext(\"2d\");\nvar g2 = context.createRadialGradient(40,40,50,500,500,300);\ng2.addColorStop(0,\"blue\");\ng2.addColorStop(0.8,\"red\");\ng2.addColorStop(1,\"rgba(100,100,105,0.5)\");\ncontext.fillStyle = g2;\ncontext.fillRect(0, 0,500, 500);\n```\n![image](http://note.youdao.com/yws/res/554/WEBRESOURCEec11c248c50ee94447354dc148bbf7f1)\n### 绘制变形图形\n#### 坐标变换\n\n - 平移  context.translate(x,y);\n - 扩大 context.scale(x,y) x为水平方向扩大的放大倍数，y是垂直方向的放大倍数\n - 旋转 context.rotate(angle);  angle 是指旋转的角度\n利用这个坐标变换我们可以做很多好玩的图形。\n```javascript\n\tvar canvas = document.getElementById(\"mycanvas\");\n\tvar context = canvas.getContext(\"2d\");\n\n\tcontext.fillStyle = \"#888\";\n\tcontext.fillRect(0,0,500,500);\n\tcontext.translate(250,100);\n\tcontext.fillStyle = \"rgba(255,0,0,0.25)\";\n\tfor(var i = 0;i<60; i++)\n\t{\n\t\tcontext.translate(25,25);\n\t\tcontext.scale(0.93,0.95);\n\t\tcontext.rotate(Math.PI/10);\n\t\tcontext.fillRect(0,0,150,40);\n\t}\n```\n如此图\n![image](http://note.youdao.com/yws/res/548/WEBRESOURCEf56b01eeb0973467321aee9dee3a7d1b)\n未完待续...\n\n","source":"_posts/canvas.md","raw":"---\ntitle: canvas元素的学习笔记\ndate: 2016-07-26 01:16:50\ntags: canvas\ncategory: HTML 5\n---\n\n\n## 什么是canvas\nHTML5新增了 canvas元素，专门用来绘制图形，在页面上放置一个canvas元素，相当于在页面上放置一块\"画布\"，画布是一个矩形区域，你可以在其中进行图形的绘制。canvas元素放在html页面中，跟其他标签没太大区别。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。\n## 创建canvas元素\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Canvas~</title>\n</head>\n<body>\n\t<canvas id=\"mycanvas\" width=\"200\" height=\"200\"></canvas>\n</body>\n</html\n```\ncanvas 需指定 ID、width、height 三个属性值\n### 绘制矩形\n**canvas本身是没有绘制能力的，需要通过JavaScript来进行绘制。\n用canvas元素绘制图形时，步骤如下**\n\n - 取得canvas元素（创建canvas元素）\n\n```javascript\nvar canvas = document.getElementById(\"mycanvas\");\n```\n - 取得上下文对象\n```javascript\nvar context = canvas.getContext(\"2d\"); \n```\n利用canvas对象的getContext方法来获得图形上下文，将参数设为“2d”,不能够设置为3d或4d。\n>getContext(\"2d\") 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。\n\n - 设定绘图样式\n```javascript\ncontext.fillStyle = \"AAA\";  //填充的样式,填入填充的颜色值\ncontext.strokeStyle = \"FF0000\"; //图形边框的样式,填入边框的颜色值\n```\n - 绘制图形\n```javascript\ncontext.fillRect(0, 0, 50, 50) // 填充矩形\ncontext.strokeRect(0, 0, 50, 50) //绘制矩形边框\n```\n**x指矩形起点的横坐标，y指矩形起点的纵坐标，width指矩形的长度，height指矩形的高度**\n```\ncontext.clearRect(x,y,width,height)\n```\nclearRect ，该方法可以擦除指定的矩形区域的图形，使得该区域中的颜色全部变为透明。\n\n**设定绘图样式必须在绘制图形之前，如果在绘制图形之后的话，绘图样式会使用默认值，而不是我们设定的那个值**\n```javascript\ncontext.fillRect(0, 0, 50, 50);\ncontext.fillStyle(\"FF0000\");\n//最终图形显示的填充颜色值是默认的黑色而不是我们设定的红色（#FF0000）\n```\n## 使用路径\n### 绘制圆形\n\n 1. 开始创建路径\n 2. 创建圆形路径\n 3. 路径创建完成后，关闭路径\n 4. 设定绘制样式，调用绘制方法，绘制路径\n```javascript\nvar canvas = document.getElmentById(\"mycanvas\");\nvar context = canvas.getContext(\"2d\");\n\ncontext.beginPath();    //创建路径\ncontext.arc(50, 50, 50, 0, Math.PI*2, true);    //创建圆形路径\ncontext.closePath();  //关闭路径\ncontext.fillStyle = \"rgba(100,100,100,0.2)\";    //填充样式，给定颜色值\ncontext.strokeStyle = \"#000\";   //绘制图形边框样式，给定颜色值\ncontext.fill();     //因为路径已经确定了图形的大小，所以不用再使用参数去指定图形的大小,也可以使用stroke 方法\n```\n如果没有关闭路径，创建的路径会永远保留着，如果进行多次绘制，则创建的图形会一次又一次地进行重叠。\n```javascript\nvar canvas = document.getElementById(\"mycanvas\");\nvar context = canvas.getContext(\"2d\");\n\ncontext.fillStyle = \"#EEEEFF\";\ncontext.fillRect(0, 0,500, 500);\nfor(var i = 0;i < 10; i++)\n{\n    context.arc(i*25, i*25, i*10, 0, Math.PI*2, true);\n    context.fillStyle = \"rgba(100,100,100,0.2)\";\n    context.fill();\n}\n```\n如图\n![image](http://note.youdao.com/yws/res/557/WEBRESOURCE880df486be209ef49fe78dd2b41739e1)\n### 绘制直线\n\n 1. moveTo (x,y)  将光标移动到指定坐标点，绘制直线的时候以这个坐标点为起点\n 2. lineTo (x,y)   以moveTo方法设定的点为起点，到自己的参数中指定的点之间绘制一条直线  x表示直线终点的横坐标，y表示终点纵坐标\n\n```javascript\nvar canvas = document.getElementById(\"mycanvas\");\nvar context = canvas.getContext(\"2d\");\ncontext.beginPath();\ncontext.moveTo(20,20);\ncontext,lineTo(50,100);\ncontext.lineWidth = 3;  //设置直线的宽度   ps：需要在stroke前面调用\ncontext.stokeStyle = \"#FF0000\";\ncontext.stroke(); //绘制直线\n``` \n### 绘制渐变图形\n#### 绘制线性渐变\n使用图形上下文的createLinearGradient方法\ncontext.createLinearGradient(xStart, yStart, xEnd, yEnd);\n然后再使用LinearGradient对象的addColorStop方法\naddColorStop(offset, color);\noffset为设定的颜色离开渐变起始点的偏移量，范围为0~1；\n```javascript\nvar g1 = context.createLinearGradient(0, 0, 200, 200);\ng1.addColorStop(0,\"#FF0000\"）;  //起点偏移量为0，颜色为红色\ng1.addColorStop(1,\"#FFF\"); //终点偏移量为1，颜色为白色\n```\n如图：\n![image](http://note.youdao.com/yws/res/560/WEBRESOURCEd2681bd319ed28c140e09ac9e4f84fac)\n#### 绘制径向渐变\n使用图形上下文的createRadiaGradient方法\ncontext.createLinearGradient(xStart, yStart, radiusStart, xEnd, yEnd, radiusEnd);\nxStart为渐变开始圆的圆心横坐标，yStart为圆心纵坐标\n同理xEnd，yEnd为渐变结束圆的圆心横纵坐标。\nradiusStart为渐变开始圆的半径，radiusEnd 为渐变结束圆的半径\n```javascript\nvar canvas = document.getElementById(\"mycanvas\");\nvar context = canvas.getContext(\"2d\");\nvar g2 = context.createRadialGradient(40,40,50,500,500,300);\ng2.addColorStop(0,\"blue\");\ng2.addColorStop(0.8,\"red\");\ng2.addColorStop(1,\"rgba(100,100,105,0.5)\");\ncontext.fillStyle = g2;\ncontext.fillRect(0, 0,500, 500);\n```\n![image](http://note.youdao.com/yws/res/554/WEBRESOURCEec11c248c50ee94447354dc148bbf7f1)\n### 绘制变形图形\n#### 坐标变换\n\n - 平移  context.translate(x,y);\n - 扩大 context.scale(x,y) x为水平方向扩大的放大倍数，y是垂直方向的放大倍数\n - 旋转 context.rotate(angle);  angle 是指旋转的角度\n利用这个坐标变换我们可以做很多好玩的图形。\n```javascript\n\tvar canvas = document.getElementById(\"mycanvas\");\n\tvar context = canvas.getContext(\"2d\");\n\n\tcontext.fillStyle = \"#888\";\n\tcontext.fillRect(0,0,500,500);\n\tcontext.translate(250,100);\n\tcontext.fillStyle = \"rgba(255,0,0,0.25)\";\n\tfor(var i = 0;i<60; i++)\n\t{\n\t\tcontext.translate(25,25);\n\t\tcontext.scale(0.93,0.95);\n\t\tcontext.rotate(Math.PI/10);\n\t\tcontext.fillRect(0,0,150,40);\n\t}\n```\n如此图\n![image](http://note.youdao.com/yws/res/548/WEBRESOURCEf56b01eeb0973467321aee9dee3a7d1b)\n未完待续...\n\n","slug":"canvas","published":1,"updated":"2017-07-13T15:37:00.130Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf81eh7r000ev4ef1j33bg5g","content":"<h2 id=\"什么是canvas\"><a href=\"#什么是canvas\" class=\"headerlink\" title=\"什么是canvas\"></a>什么是canvas</h2><p>HTML5新增了 canvas元素，专门用来绘制图形，在页面上放置一个canvas元素，相当于在页面上放置一块”画布”，画布是一个矩形区域，你可以在其中进行图形的绘制。canvas元素放在html页面中，跟其他标签没太大区别。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</p>\n<h2 id=\"创建canvas元素\"><a href=\"#创建canvas元素\" class=\"headerlink\" title=\"创建canvas元素\"></a>创建canvas元素</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Canvas~<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mycanvas\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"200\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"200\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span></span></span><br></pre></td></tr></table></figure>\n<p>canvas 需指定 ID、width、height 三个属性值</p>\n<h3 id=\"绘制矩形\"><a href=\"#绘制矩形\" class=\"headerlink\" title=\"绘制矩形\"></a>绘制矩形</h3><p><strong>canvas本身是没有绘制能力的，需要通过JavaScript来进行绘制。<br>用canvas元素绘制图形时，步骤如下</strong></p>\n<ul>\n<li>取得canvas元素（创建canvas元素）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"mycanvas\"</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>取得上下文对象<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> context = canvas.getContext(<span class=\"string\">\"2d\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>利用canvas对象的getContext方法来获得图形上下文，将参数设为“2d”,不能够设置为3d或4d。</p>\n<blockquote>\n<p>getContext(“2d”) 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</p>\n</blockquote>\n<ul>\n<li><p>设定绘图样式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context.fillStyle = <span class=\"string\">\"AAA\"</span>;  <span class=\"comment\">//填充的样式,填入填充的颜色值</span></span><br><span class=\"line\">context.strokeStyle = <span class=\"string\">\"FF0000\"</span>; <span class=\"comment\">//图形边框的样式,填入边框的颜色值</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>绘制图形</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context.fillRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">50</span>) <span class=\"comment\">// 填充矩形</span></span><br><span class=\"line\">context.strokeRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">50</span>) <span class=\"comment\">//绘制矩形边框</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>x指矩形起点的横坐标，y指矩形起点的纵坐标，width指矩形的长度，height指矩形的高度</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context.clearRect(x,y,width,height)</span><br></pre></td></tr></table></figure></p>\n<p>clearRect ，该方法可以擦除指定的矩形区域的图形，使得该区域中的颜色全部变为透明。</p>\n<p><strong>设定绘图样式必须在绘制图形之前，如果在绘制图形之后的话，绘图样式会使用默认值，而不是我们设定的那个值</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context.fillRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">context.fillStyle(<span class=\"string\">\"FF0000\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//最终图形显示的填充颜色值是默认的黑色而不是我们设定的红色（#FF0000）</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用路径\"><a href=\"#使用路径\" class=\"headerlink\" title=\"使用路径\"></a>使用路径</h2><h3 id=\"绘制圆形\"><a href=\"#绘制圆形\" class=\"headerlink\" title=\"绘制圆形\"></a>绘制圆形</h3><ol>\n<li>开始创建路径</li>\n<li>创建圆形路径</li>\n<li>路径创建完成后，关闭路径</li>\n<li>设定绘制样式，调用绘制方法，绘制路径<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.getElmentById(<span class=\"string\">\"mycanvas\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> context = canvas.getContext(<span class=\"string\">\"2d\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">context.beginPath();    <span class=\"comment\">//创建路径</span></span><br><span class=\"line\">context.arc(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">0</span>, <span class=\"built_in\">Math</span>.PI*<span class=\"number\">2</span>, <span class=\"literal\">true</span>);    <span class=\"comment\">//创建圆形路径</span></span><br><span class=\"line\">context.closePath();  <span class=\"comment\">//关闭路径</span></span><br><span class=\"line\">context.fillStyle = <span class=\"string\">\"rgba(100,100,100,0.2)\"</span>;    <span class=\"comment\">//填充样式，给定颜色值</span></span><br><span class=\"line\">context.strokeStyle = <span class=\"string\">\"#000\"</span>;   <span class=\"comment\">//绘制图形边框样式，给定颜色值</span></span><br><span class=\"line\">context.fill();     <span class=\"comment\">//因为路径已经确定了图形的大小，所以不用再使用参数去指定图形的大小,也可以使用stroke 方法</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如果没有关闭路径，创建的路径会永远保留着，如果进行多次绘制，则创建的图形会一次又一次地进行重叠。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"mycanvas\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> context = canvas.getContext(<span class=\"string\">\"2d\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">context.fillStyle = <span class=\"string\">\"#EEEEFF\"</span>;</span><br><span class=\"line\">context.fillRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>,<span class=\"number\">500</span>, <span class=\"number\">500</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    context.arc(i*<span class=\"number\">25</span>, i*<span class=\"number\">25</span>, i*<span class=\"number\">10</span>, <span class=\"number\">0</span>, <span class=\"built_in\">Math</span>.PI*<span class=\"number\">2</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    context.fillStyle = <span class=\"string\">\"rgba(100,100,100,0.2)\"</span>;</span><br><span class=\"line\">    context.fill();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如图<br><img src=\"http://note.youdao.com/yws/res/557/WEBRESOURCE880df486be209ef49fe78dd2b41739e1\" alt=\"image\"></p>\n<h3 id=\"绘制直线\"><a href=\"#绘制直线\" class=\"headerlink\" title=\"绘制直线\"></a>绘制直线</h3><ol>\n<li>moveTo (x,y)  将光标移动到指定坐标点，绘制直线的时候以这个坐标点为起点</li>\n<li>lineTo (x,y)   以moveTo方法设定的点为起点，到自己的参数中指定的点之间绘制一条直线  x表示直线终点的横坐标，y表示终点纵坐标</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"mycanvas\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> context = canvas.getContext(<span class=\"string\">\"2d\"</span>);</span><br><span class=\"line\">context.beginPath();</span><br><span class=\"line\">context.moveTo(<span class=\"number\">20</span>,<span class=\"number\">20</span>);</span><br><span class=\"line\">context,lineTo(<span class=\"number\">50</span>,<span class=\"number\">100</span>);</span><br><span class=\"line\">context.lineWidth = <span class=\"number\">3</span>;  <span class=\"comment\">//设置直线的宽度   ps：需要在stroke前面调用</span></span><br><span class=\"line\">context.stokeStyle = <span class=\"string\">\"#FF0000\"</span>;</span><br><span class=\"line\">context.stroke(); <span class=\"comment\">//绘制直线</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\">### 绘制渐变图形</span></span><br><span class=\"line\"><span class=\"string\">#### 绘制线性渐变</span></span><br><span class=\"line\"><span class=\"string\">使用图形上下文的createLinearGradient方法</span></span><br><span class=\"line\"><span class=\"string\">context.createLinearGradient(xStart, yStart, xEnd, yEnd);</span></span><br><span class=\"line\"><span class=\"string\">然后再使用LinearGradient对象的addColorStop方法</span></span><br><span class=\"line\"><span class=\"string\">addColorStop(offset, color);</span></span><br><span class=\"line\"><span class=\"string\">offset为设定的颜色离开渐变起始点的偏移量，范围为0~1；</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\"><span class=\"keyword\">var</span> g1 = context.createLinearGradient(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">200</span>, <span class=\"number\">200</span>);</span><br><span class=\"line\">g1.addColorStop(<span class=\"number\">0</span>,<span class=\"string\">\"#FF0000\"</span>）;  <span class=\"comment\">//起点偏移量为0，颜色为红色</span></span><br><span class=\"line\">g1.addColorStop(<span class=\"number\">1</span>,<span class=\"string\">\"#FFF\"</span>); <span class=\"comment\">//终点偏移量为1，颜色为白色</span></span><br></pre></td></tr></table></figure>\n<p>如图：<br><img src=\"http://note.youdao.com/yws/res/560/WEBRESOURCEd2681bd319ed28c140e09ac9e4f84fac\" alt=\"image\"></p>\n<h4 id=\"绘制径向渐变\"><a href=\"#绘制径向渐变\" class=\"headerlink\" title=\"绘制径向渐变\"></a>绘制径向渐变</h4><p>使用图形上下文的createRadiaGradient方法<br>context.createLinearGradient(xStart, yStart, radiusStart, xEnd, yEnd, radiusEnd);<br>xStart为渐变开始圆的圆心横坐标，yStart为圆心纵坐标<br>同理xEnd，yEnd为渐变结束圆的圆心横纵坐标。<br>radiusStart为渐变开始圆的半径，radiusEnd 为渐变结束圆的半径<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"mycanvas\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> context = canvas.getContext(<span class=\"string\">\"2d\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> g2 = context.createRadialGradient(<span class=\"number\">40</span>,<span class=\"number\">40</span>,<span class=\"number\">50</span>,<span class=\"number\">500</span>,<span class=\"number\">500</span>,<span class=\"number\">300</span>);</span><br><span class=\"line\">g2.addColorStop(<span class=\"number\">0</span>,<span class=\"string\">\"blue\"</span>);</span><br><span class=\"line\">g2.addColorStop(<span class=\"number\">0.8</span>,<span class=\"string\">\"red\"</span>);</span><br><span class=\"line\">g2.addColorStop(<span class=\"number\">1</span>,<span class=\"string\">\"rgba(100,100,105,0.5)\"</span>);</span><br><span class=\"line\">context.fillStyle = g2;</span><br><span class=\"line\">context.fillRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>,<span class=\"number\">500</span>, <span class=\"number\">500</span>);</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://note.youdao.com/yws/res/554/WEBRESOURCEec11c248c50ee94447354dc148bbf7f1\" alt=\"image\"></p>\n<h3 id=\"绘制变形图形\"><a href=\"#绘制变形图形\" class=\"headerlink\" title=\"绘制变形图形\"></a>绘制变形图形</h3><h4 id=\"坐标变换\"><a href=\"#坐标变换\" class=\"headerlink\" title=\"坐标变换\"></a>坐标变换</h4><ul>\n<li>平移  context.translate(x,y);</li>\n<li>扩大 context.scale(x,y) x为水平方向扩大的放大倍数，y是垂直方向的放大倍数</li>\n<li>旋转 context.rotate(angle);  angle 是指旋转的角度<br>利用这个坐标变换我们可以做很多好玩的图形。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"mycanvas\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> context = canvas.getContext(<span class=\"string\">\"2d\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">context.fillStyle = <span class=\"string\">\"#888\"</span>;</span><br><span class=\"line\">context.fillRect(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">500</span>,<span class=\"number\">500</span>);</span><br><span class=\"line\">context.translate(<span class=\"number\">250</span>,<span class=\"number\">100</span>);</span><br><span class=\"line\">context.fillStyle = <span class=\"string\">\"rgba(255,0,0,0.25)\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">60</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tcontext.translate(<span class=\"number\">25</span>,<span class=\"number\">25</span>);</span><br><span class=\"line\">\tcontext.scale(<span class=\"number\">0.93</span>,<span class=\"number\">0.95</span>);</span><br><span class=\"line\">\tcontext.rotate(<span class=\"built_in\">Math</span>.PI/<span class=\"number\">10</span>);</span><br><span class=\"line\">\tcontext.fillRect(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">150</span>,<span class=\"number\">40</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如此图<br><img src=\"http://note.youdao.com/yws/res/548/WEBRESOURCEf56b01eeb0973467321aee9dee3a7d1b\" alt=\"image\"><br>未完待续…</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是canvas\"><a href=\"#什么是canvas\" class=\"headerlink\" title=\"什么是canvas\"></a>什么是canvas</h2><p>HTML5新增了 canvas元素，专门用来绘制图形，在页面上放置一个canvas元素，相当于在页面上放置一块”画布”，画布是一个矩形区域，你可以在其中进行图形的绘制。canvas元素放在html页面中，跟其他标签没太大区别。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</p>\n<h2 id=\"创建canvas元素\"><a href=\"#创建canvas元素\" class=\"headerlink\" title=\"创建canvas元素\"></a>创建canvas元素</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Canvas~<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mycanvas\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"200\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"200\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span></span></span><br></pre></td></tr></table></figure>\n<p>canvas 需指定 ID、width、height 三个属性值</p>\n<h3 id=\"绘制矩形\"><a href=\"#绘制矩形\" class=\"headerlink\" title=\"绘制矩形\"></a>绘制矩形</h3><p><strong>canvas本身是没有绘制能力的，需要通过JavaScript来进行绘制。<br>用canvas元素绘制图形时，步骤如下</strong></p>\n<ul>\n<li>取得canvas元素（创建canvas元素）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"mycanvas\"</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>取得上下文对象<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> context = canvas.getContext(<span class=\"string\">\"2d\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>利用canvas对象的getContext方法来获得图形上下文，将参数设为“2d”,不能够设置为3d或4d。</p>\n<blockquote>\n<p>getContext(“2d”) 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</p>\n</blockquote>\n<ul>\n<li><p>设定绘图样式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context.fillStyle = <span class=\"string\">\"AAA\"</span>;  <span class=\"comment\">//填充的样式,填入填充的颜色值</span></span><br><span class=\"line\">context.strokeStyle = <span class=\"string\">\"FF0000\"</span>; <span class=\"comment\">//图形边框的样式,填入边框的颜色值</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>绘制图形</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context.fillRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">50</span>) <span class=\"comment\">// 填充矩形</span></span><br><span class=\"line\">context.strokeRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">50</span>) <span class=\"comment\">//绘制矩形边框</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>x指矩形起点的横坐标，y指矩形起点的纵坐标，width指矩形的长度，height指矩形的高度</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context.clearRect(x,y,width,height)</span><br></pre></td></tr></table></figure></p>\n<p>clearRect ，该方法可以擦除指定的矩形区域的图形，使得该区域中的颜色全部变为透明。</p>\n<p><strong>设定绘图样式必须在绘制图形之前，如果在绘制图形之后的话，绘图样式会使用默认值，而不是我们设定的那个值</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context.fillRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">context.fillStyle(<span class=\"string\">\"FF0000\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//最终图形显示的填充颜色值是默认的黑色而不是我们设定的红色（#FF0000）</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用路径\"><a href=\"#使用路径\" class=\"headerlink\" title=\"使用路径\"></a>使用路径</h2><h3 id=\"绘制圆形\"><a href=\"#绘制圆形\" class=\"headerlink\" title=\"绘制圆形\"></a>绘制圆形</h3><ol>\n<li>开始创建路径</li>\n<li>创建圆形路径</li>\n<li>路径创建完成后，关闭路径</li>\n<li>设定绘制样式，调用绘制方法，绘制路径<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.getElmentById(<span class=\"string\">\"mycanvas\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> context = canvas.getContext(<span class=\"string\">\"2d\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">context.beginPath();    <span class=\"comment\">//创建路径</span></span><br><span class=\"line\">context.arc(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">0</span>, <span class=\"built_in\">Math</span>.PI*<span class=\"number\">2</span>, <span class=\"literal\">true</span>);    <span class=\"comment\">//创建圆形路径</span></span><br><span class=\"line\">context.closePath();  <span class=\"comment\">//关闭路径</span></span><br><span class=\"line\">context.fillStyle = <span class=\"string\">\"rgba(100,100,100,0.2)\"</span>;    <span class=\"comment\">//填充样式，给定颜色值</span></span><br><span class=\"line\">context.strokeStyle = <span class=\"string\">\"#000\"</span>;   <span class=\"comment\">//绘制图形边框样式，给定颜色值</span></span><br><span class=\"line\">context.fill();     <span class=\"comment\">//因为路径已经确定了图形的大小，所以不用再使用参数去指定图形的大小,也可以使用stroke 方法</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如果没有关闭路径，创建的路径会永远保留着，如果进行多次绘制，则创建的图形会一次又一次地进行重叠。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"mycanvas\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> context = canvas.getContext(<span class=\"string\">\"2d\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">context.fillStyle = <span class=\"string\">\"#EEEEFF\"</span>;</span><br><span class=\"line\">context.fillRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>,<span class=\"number\">500</span>, <span class=\"number\">500</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    context.arc(i*<span class=\"number\">25</span>, i*<span class=\"number\">25</span>, i*<span class=\"number\">10</span>, <span class=\"number\">0</span>, <span class=\"built_in\">Math</span>.PI*<span class=\"number\">2</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    context.fillStyle = <span class=\"string\">\"rgba(100,100,100,0.2)\"</span>;</span><br><span class=\"line\">    context.fill();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如图<br><img src=\"http://note.youdao.com/yws/res/557/WEBRESOURCE880df486be209ef49fe78dd2b41739e1\" alt=\"image\"></p>\n<h3 id=\"绘制直线\"><a href=\"#绘制直线\" class=\"headerlink\" title=\"绘制直线\"></a>绘制直线</h3><ol>\n<li>moveTo (x,y)  将光标移动到指定坐标点，绘制直线的时候以这个坐标点为起点</li>\n<li>lineTo (x,y)   以moveTo方法设定的点为起点，到自己的参数中指定的点之间绘制一条直线  x表示直线终点的横坐标，y表示终点纵坐标</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"mycanvas\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> context = canvas.getContext(<span class=\"string\">\"2d\"</span>);</span><br><span class=\"line\">context.beginPath();</span><br><span class=\"line\">context.moveTo(<span class=\"number\">20</span>,<span class=\"number\">20</span>);</span><br><span class=\"line\">context,lineTo(<span class=\"number\">50</span>,<span class=\"number\">100</span>);</span><br><span class=\"line\">context.lineWidth = <span class=\"number\">3</span>;  <span class=\"comment\">//设置直线的宽度   ps：需要在stroke前面调用</span></span><br><span class=\"line\">context.stokeStyle = <span class=\"string\">\"#FF0000\"</span>;</span><br><span class=\"line\">context.stroke(); <span class=\"comment\">//绘制直线</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\">### 绘制渐变图形</span></span><br><span class=\"line\"><span class=\"string\">#### 绘制线性渐变</span></span><br><span class=\"line\"><span class=\"string\">使用图形上下文的createLinearGradient方法</span></span><br><span class=\"line\"><span class=\"string\">context.createLinearGradient(xStart, yStart, xEnd, yEnd);</span></span><br><span class=\"line\"><span class=\"string\">然后再使用LinearGradient对象的addColorStop方法</span></span><br><span class=\"line\"><span class=\"string\">addColorStop(offset, color);</span></span><br><span class=\"line\"><span class=\"string\">offset为设定的颜色离开渐变起始点的偏移量，范围为0~1；</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\"><span class=\"keyword\">var</span> g1 = context.createLinearGradient(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">200</span>, <span class=\"number\">200</span>);</span><br><span class=\"line\">g1.addColorStop(<span class=\"number\">0</span>,<span class=\"string\">\"#FF0000\"</span>）;  <span class=\"comment\">//起点偏移量为0，颜色为红色</span></span><br><span class=\"line\">g1.addColorStop(<span class=\"number\">1</span>,<span class=\"string\">\"#FFF\"</span>); <span class=\"comment\">//终点偏移量为1，颜色为白色</span></span><br></pre></td></tr></table></figure>\n<p>如图：<br><img src=\"http://note.youdao.com/yws/res/560/WEBRESOURCEd2681bd319ed28c140e09ac9e4f84fac\" alt=\"image\"></p>\n<h4 id=\"绘制径向渐变\"><a href=\"#绘制径向渐变\" class=\"headerlink\" title=\"绘制径向渐变\"></a>绘制径向渐变</h4><p>使用图形上下文的createRadiaGradient方法<br>context.createLinearGradient(xStart, yStart, radiusStart, xEnd, yEnd, radiusEnd);<br>xStart为渐变开始圆的圆心横坐标，yStart为圆心纵坐标<br>同理xEnd，yEnd为渐变结束圆的圆心横纵坐标。<br>radiusStart为渐变开始圆的半径，radiusEnd 为渐变结束圆的半径<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"mycanvas\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> context = canvas.getContext(<span class=\"string\">\"2d\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> g2 = context.createRadialGradient(<span class=\"number\">40</span>,<span class=\"number\">40</span>,<span class=\"number\">50</span>,<span class=\"number\">500</span>,<span class=\"number\">500</span>,<span class=\"number\">300</span>);</span><br><span class=\"line\">g2.addColorStop(<span class=\"number\">0</span>,<span class=\"string\">\"blue\"</span>);</span><br><span class=\"line\">g2.addColorStop(<span class=\"number\">0.8</span>,<span class=\"string\">\"red\"</span>);</span><br><span class=\"line\">g2.addColorStop(<span class=\"number\">1</span>,<span class=\"string\">\"rgba(100,100,105,0.5)\"</span>);</span><br><span class=\"line\">context.fillStyle = g2;</span><br><span class=\"line\">context.fillRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>,<span class=\"number\">500</span>, <span class=\"number\">500</span>);</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://note.youdao.com/yws/res/554/WEBRESOURCEec11c248c50ee94447354dc148bbf7f1\" alt=\"image\"></p>\n<h3 id=\"绘制变形图形\"><a href=\"#绘制变形图形\" class=\"headerlink\" title=\"绘制变形图形\"></a>绘制变形图形</h3><h4 id=\"坐标变换\"><a href=\"#坐标变换\" class=\"headerlink\" title=\"坐标变换\"></a>坐标变换</h4><ul>\n<li>平移  context.translate(x,y);</li>\n<li>扩大 context.scale(x,y) x为水平方向扩大的放大倍数，y是垂直方向的放大倍数</li>\n<li>旋转 context.rotate(angle);  angle 是指旋转的角度<br>利用这个坐标变换我们可以做很多好玩的图形。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"mycanvas\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> context = canvas.getContext(<span class=\"string\">\"2d\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">context.fillStyle = <span class=\"string\">\"#888\"</span>;</span><br><span class=\"line\">context.fillRect(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">500</span>,<span class=\"number\">500</span>);</span><br><span class=\"line\">context.translate(<span class=\"number\">250</span>,<span class=\"number\">100</span>);</span><br><span class=\"line\">context.fillStyle = <span class=\"string\">\"rgba(255,0,0,0.25)\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">60</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tcontext.translate(<span class=\"number\">25</span>,<span class=\"number\">25</span>);</span><br><span class=\"line\">\tcontext.scale(<span class=\"number\">0.93</span>,<span class=\"number\">0.95</span>);</span><br><span class=\"line\">\tcontext.rotate(<span class=\"built_in\">Math</span>.PI/<span class=\"number\">10</span>);</span><br><span class=\"line\">\tcontext.fillRect(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">150</span>,<span class=\"number\">40</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如此图<br><img src=\"http://note.youdao.com/yws/res/548/WEBRESOURCEf56b01eeb0973467321aee9dee3a7d1b\" alt=\"image\"><br>未完待续…</p>\n"},{"title":"函数柯里化 & 偏函数应用","date":"2017-07-11T17:16:50.000Z","_content":"\n在学习function.prototype.bind()方法的时候看到了bind() 的一个作用是实现偏函数应用,顺便了解到了函数柯里化.\n<!-- more -->\n\n## 函数柯里化（Currying）& 偏函数应用（Partial Application）\n偏函数解决的问题是，如果有函数是具有多个参数的，希望能固定其中某几个参数的值。\n而函数柯里化，由数学家curry发明的这种使用技巧，所以以他的名字命名。（滑稽.jpg）（库里不但会投三分还会数学哇）。函数柯里化是将一个接受多个参数的函数转变为一组支持链式调用的函数链，其中每个函数仅有一个入参。也可以说，将单参数函数实现为多参数函数的方法。\n\n### 偏函数应用\n>**引用mdn**：mdn上的bind( )的其中一种用法就是实现偏函数应用。\n>bind( )简单用法之一就是使一个函数拥有预设的初始参数，这些参数作为bind( )二个参数跟在this（或者其他对象）后面，之后它们会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在他们后面。\n\n```javascript\n// bind()实现偏函数应用1.\n// Array.prototype.slice的应用之一：把类数组对象转化为真正的数组。\nvar slice = Array.prototype.slice;\n\nfunction fn() {\n\t// arguments对象是一个类数组对象，除了长度之外没有任何数组属性。但是可以被转换为一个真正的数组\n\treturn slice.call(arguments);  \n}\n\nvar fn1 = fn(1, 2, 3);\n\nvar fn37 = fn.bind(undefined, 37);  \n\nfn37(1, 2, 3);  // [37, 1, 2, 3]  cause：37会插入到目标函数的参数列表的开始位置，而1,2,3是传给绑定函数即fn37()的参数\n\n// bind()实现偏函数应用2.\nfunction fun(a, v, c) {\n\treturn a-v+c;\n}\n\nvar fun38 = fun.bind(undefined, 37);\n\n// fun38此时就是fun的一个偏函数.\nconsole.log(fun38(1,3));  // 37-1+3 == 39，37会插入到目标函数的参数列表的开始位置，所以形参a对应的实参就是37.\n\n```\n\n### 函数柯里化\n```javascript\n//js函数可以接收多个参数\nfunction(a, v, c) {\n\treturn a-v+c;\n}\n\n//柯里化\n\nfunction wow(a) {\n\treturn function(b) {\n\t\treturn function(c){\n\t\t\treturn a-b+c;\n\t\t}\n\t}\n}\n\nwow(1)(2)(3);  // 1-2+3 == 2;\n\n```\n至于对于柯里化的应用，等到 以后有接触到再把文章补充完吧.. 写这个笔记主要是为了理解这两者的意义。\n\n","source":"_posts/currying&partial-application.md","raw":"---\ntitle: 函数柯里化 & 偏函数应用\ndate: 2017-07-12 01:16:50\ntags: [JavaScript,Function]\ncategory: JavaScript\n---\n\n在学习function.prototype.bind()方法的时候看到了bind() 的一个作用是实现偏函数应用,顺便了解到了函数柯里化.\n<!-- more -->\n\n## 函数柯里化（Currying）& 偏函数应用（Partial Application）\n偏函数解决的问题是，如果有函数是具有多个参数的，希望能固定其中某几个参数的值。\n而函数柯里化，由数学家curry发明的这种使用技巧，所以以他的名字命名。（滑稽.jpg）（库里不但会投三分还会数学哇）。函数柯里化是将一个接受多个参数的函数转变为一组支持链式调用的函数链，其中每个函数仅有一个入参。也可以说，将单参数函数实现为多参数函数的方法。\n\n### 偏函数应用\n>**引用mdn**：mdn上的bind( )的其中一种用法就是实现偏函数应用。\n>bind( )简单用法之一就是使一个函数拥有预设的初始参数，这些参数作为bind( )二个参数跟在this（或者其他对象）后面，之后它们会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在他们后面。\n\n```javascript\n// bind()实现偏函数应用1.\n// Array.prototype.slice的应用之一：把类数组对象转化为真正的数组。\nvar slice = Array.prototype.slice;\n\nfunction fn() {\n\t// arguments对象是一个类数组对象，除了长度之外没有任何数组属性。但是可以被转换为一个真正的数组\n\treturn slice.call(arguments);  \n}\n\nvar fn1 = fn(1, 2, 3);\n\nvar fn37 = fn.bind(undefined, 37);  \n\nfn37(1, 2, 3);  // [37, 1, 2, 3]  cause：37会插入到目标函数的参数列表的开始位置，而1,2,3是传给绑定函数即fn37()的参数\n\n// bind()实现偏函数应用2.\nfunction fun(a, v, c) {\n\treturn a-v+c;\n}\n\nvar fun38 = fun.bind(undefined, 37);\n\n// fun38此时就是fun的一个偏函数.\nconsole.log(fun38(1,3));  // 37-1+3 == 39，37会插入到目标函数的参数列表的开始位置，所以形参a对应的实参就是37.\n\n```\n\n### 函数柯里化\n```javascript\n//js函数可以接收多个参数\nfunction(a, v, c) {\n\treturn a-v+c;\n}\n\n//柯里化\n\nfunction wow(a) {\n\treturn function(b) {\n\t\treturn function(c){\n\t\t\treturn a-b+c;\n\t\t}\n\t}\n}\n\nwow(1)(2)(3);  // 1-2+3 == 2;\n\n```\n至于对于柯里化的应用，等到 以后有接触到再把文章补充完吧.. 写这个笔记主要是为了理解这两者的意义。\n\n","slug":"currying&partial-application","published":1,"updated":"2017-07-17T05:15:31.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf81eh7v000fv4ef7ohn5v69","content":"<p>在学习function.prototype.bind()方法的时候看到了bind() 的一个作用是实现偏函数应用,顺便了解到了函数柯里化.<br><a id=\"more\"></a></p>\n<h2 id=\"函数柯里化（Currying）-amp-偏函数应用（Partial-Application）\"><a href=\"#函数柯里化（Currying）-amp-偏函数应用（Partial-Application）\" class=\"headerlink\" title=\"函数柯里化（Currying）&amp; 偏函数应用（Partial Application）\"></a>函数柯里化（Currying）&amp; 偏函数应用（Partial Application）</h2><p>偏函数解决的问题是，如果有函数是具有多个参数的，希望能固定其中某几个参数的值。<br>而函数柯里化，由数学家curry发明的这种使用技巧，所以以他的名字命名。（滑稽.jpg）（库里不但会投三分还会数学哇）。函数柯里化是将一个接受多个参数的函数转变为一组支持链式调用的函数链，其中每个函数仅有一个入参。也可以说，将单参数函数实现为多参数函数的方法。</p>\n<h3 id=\"偏函数应用\"><a href=\"#偏函数应用\" class=\"headerlink\" title=\"偏函数应用\"></a>偏函数应用</h3><blockquote>\n<p><strong>引用mdn</strong>：mdn上的bind( )的其中一种用法就是实现偏函数应用。<br>bind( )简单用法之一就是使一个函数拥有预设的初始参数，这些参数作为bind( )二个参数跟在this（或者其他对象）后面，之后它们会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在他们后面。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bind()实现偏函数应用1.</span></span><br><span class=\"line\"><span class=\"comment\">// Array.prototype.slice的应用之一：把类数组对象转化为真正的数组。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> slice = <span class=\"built_in\">Array</span>.prototype.slice;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// arguments对象是一个类数组对象，除了长度之外没有任何数组属性。但是可以被转换为一个真正的数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> slice.call(<span class=\"built_in\">arguments</span>);  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn1 = fn(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn37 = fn.bind(<span class=\"literal\">undefined</span>, <span class=\"number\">37</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\">fn37(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// [37, 1, 2, 3]  cause：37会插入到目标函数的参数列表的开始位置，而1,2,3是传给绑定函数即fn37()的参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// bind()实现偏函数应用2.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\">a, v, c</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a-v+c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fun38 = fun.bind(<span class=\"literal\">undefined</span>, <span class=\"number\">37</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// fun38此时就是fun的一个偏函数.</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fun38(<span class=\"number\">1</span>,<span class=\"number\">3</span>));  <span class=\"comment\">// 37-1+3 == 39，37会插入到目标函数的参数列表的开始位置，所以形参a对应的实参就是37.</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"函数柯里化\"><a href=\"#函数柯里化\" class=\"headerlink\" title=\"函数柯里化\"></a>函数柯里化</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//js函数可以接收多个参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, v, c</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a-v+c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//柯里化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wow</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">c</span>)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> a-b+c;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">wow(<span class=\"number\">1</span>)(<span class=\"number\">2</span>)(<span class=\"number\">3</span>);  <span class=\"comment\">// 1-2+3 == 2;</span></span><br></pre></td></tr></table></figure>\n<p>至于对于柯里化的应用，等到 以后有接触到再把文章补充完吧.. 写这个笔记主要是为了理解这两者的意义。</p>\n","site":{"data":{}},"excerpt":"<p>在学习function.prototype.bind()方法的时候看到了bind() 的一个作用是实现偏函数应用,顺便了解到了函数柯里化.<br>","more":"</p>\n<h2 id=\"函数柯里化（Currying）-amp-偏函数应用（Partial-Application）\"><a href=\"#函数柯里化（Currying）-amp-偏函数应用（Partial-Application）\" class=\"headerlink\" title=\"函数柯里化（Currying）&amp; 偏函数应用（Partial Application）\"></a>函数柯里化（Currying）&amp; 偏函数应用（Partial Application）</h2><p>偏函数解决的问题是，如果有函数是具有多个参数的，希望能固定其中某几个参数的值。<br>而函数柯里化，由数学家curry发明的这种使用技巧，所以以他的名字命名。（滑稽.jpg）（库里不但会投三分还会数学哇）。函数柯里化是将一个接受多个参数的函数转变为一组支持链式调用的函数链，其中每个函数仅有一个入参。也可以说，将单参数函数实现为多参数函数的方法。</p>\n<h3 id=\"偏函数应用\"><a href=\"#偏函数应用\" class=\"headerlink\" title=\"偏函数应用\"></a>偏函数应用</h3><blockquote>\n<p><strong>引用mdn</strong>：mdn上的bind( )的其中一种用法就是实现偏函数应用。<br>bind( )简单用法之一就是使一个函数拥有预设的初始参数，这些参数作为bind( )二个参数跟在this（或者其他对象）后面，之后它们会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在他们后面。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bind()实现偏函数应用1.</span></span><br><span class=\"line\"><span class=\"comment\">// Array.prototype.slice的应用之一：把类数组对象转化为真正的数组。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> slice = <span class=\"built_in\">Array</span>.prototype.slice;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// arguments对象是一个类数组对象，除了长度之外没有任何数组属性。但是可以被转换为一个真正的数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> slice.call(<span class=\"built_in\">arguments</span>);  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn1 = fn(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn37 = fn.bind(<span class=\"literal\">undefined</span>, <span class=\"number\">37</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\">fn37(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// [37, 1, 2, 3]  cause：37会插入到目标函数的参数列表的开始位置，而1,2,3是传给绑定函数即fn37()的参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// bind()实现偏函数应用2.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\">a, v, c</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a-v+c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fun38 = fun.bind(<span class=\"literal\">undefined</span>, <span class=\"number\">37</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// fun38此时就是fun的一个偏函数.</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fun38(<span class=\"number\">1</span>,<span class=\"number\">3</span>));  <span class=\"comment\">// 37-1+3 == 39，37会插入到目标函数的参数列表的开始位置，所以形参a对应的实参就是37.</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"函数柯里化\"><a href=\"#函数柯里化\" class=\"headerlink\" title=\"函数柯里化\"></a>函数柯里化</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//js函数可以接收多个参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, v, c</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a-v+c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//柯里化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wow</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">c</span>)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> a-b+c;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">wow(<span class=\"number\">1</span>)(<span class=\"number\">2</span>)(<span class=\"number\">3</span>);  <span class=\"comment\">// 1-2+3 == 2;</span></span><br></pre></td></tr></table></figure>\n<p>至于对于柯里化的应用，等到 以后有接触到再把文章补充完吧.. 写这个笔记主要是为了理解这两者的意义。</p>"},{"title":"hello world","date":"2016-07-25T16:52:36.000Z","_content":"","source":"_posts/hello-world.md","raw":"---\ntitle: hello world\ndate: 2016-07-26 00:52:36\ntags:\n---\n","slug":"hello-world","published":1,"updated":"2016-07-25T16:52:36.603Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf81eh81000jv4efmxf0cxf9","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"database","date":"2018-01-18T16:00:00.000Z","_content":"\n数据库课设笔记\n\n<!-- more -->\n\n# 前言\n\n这学期学习了 **数据库系统** 这门课程, 学习到了关于数据库的知识, 因为课堂学习的是SQL的知识, 做实验也是用到SQL Server, 所以这次课设就选择了MySQL来写,首先当然是知识准备咯.MySQL的语法跟SQL的语法一样.在课堂学习的时候就学习了SQL的语法，先用phpStudy的adminer把数据库及表建立起来，学习Node.js连接MySQL，前端利用ElementUI来快速完成页面的设计.\n\n# 设计过程\n因为选题选的是学生信息管理系统,而做实验的时候就有类似的学生信息系统,所以参考实验并加以修改,总共有 Student,Department,Speciality,Class,Course,SC,User7个表.\n其他就不着重讲了.课程设计报告有详细的。\n\n# 服务端笔记\nExpress采用**body-parser**,一个HTTP请求体解析中间件,使用这个模块可以解析JSON、Raw、文本、URL-encoded格式的请求体.\n``` javascript\nconst bodyParser = require('body-parser');\nconst express = require('express');\nconst app = express();\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({extended: false}))\n```\n引入mysql\n``` javascript\nvar mysql = require('mysql');\nvar conn mysql.createConnection(models.mysql);  //建立MySQL连接\n```\n设计API接口 (使用express的router)\n``` javascript\nvar router = express.Router(); //引入 router\n\nrouter.post('/selectAll', (req, res) => {\n    var params = req.body;  // 前端传过来的参数，进行提取\n    var sql = `SELECT * from ${params.table}`; //使用模版字符串写SQL语句\n    //进行对数据库的查询\n    conn.query(sql, function(err, result) {\n        if(err) {\n            console.log(err);\n            res.send(500,{error: '出错: '+err.sqlMessage});\n        }\n        if(result) {\n            res.json({\n                code: 200,\n                data: result,\n                msg: '查询成功'\n            })\n        }\n    })\n})\n\n\n```\n当查询出错时，一直不了解怎么返回提示信息给前端，后面观察服务端的node进程，`console.log(err)` 打印了一些出错信息，有个字段为sqlMessage，所以就把这个`err.sqlMessage`直接传给前端，有时候出错信息比较复杂，这个因为时间原因没有对这个信息再进行加工，就直接服务端数据库报什么错就直接传给前端了，有点不妥。 \n\n``` javascript\nif(result) {\n    if(result.affectedRows>0){\n        res.json({\n            code: 200,\n            data: result,\n            msg: '删除成功'\n        })\n    }\n    if(result.affectedRows ===0){\n        res.json({\n            code: 200,\n            data: result,\n            msg: '操作没有影响，删除的数据原本就不存在~'\n        })\n    }\n}\n            \n``` \n\n设计*修改*，*删除*API时，对数据库的操作成功会返回个result对象，其有个affectedRows字段，代表操作后所影响到的表的数据的行数，当`affectedRows > 0`说明数据有受到影响，而其为0时，则操作并没有对数据库产生修改，从侧面说明欲修改、删除的数据本就不存在，返回`操作没有影响到数据库，数据不存在`给前端。\n\n# 前端笔记\n前端采用Vue-cli 和 vue-router\n\n整个的管理页面只有中间的具体操作的部分是根据管理模块的类型来按需显示的，又因为管理模块的类型已经在`side-menu`分得很清楚，点击菜单栏上的某个管理模块，中间的部分就显示特定的内容。一开始没有什么思路，后面查阅到`ElementUI`的`el-menu`支持路由模式，点击菜单栏的item，路由会跳转到特定的此item的index值，如下\n```html\n<el-menu\nrouter >\n<el-submenu index=\"1\">\n\t\t<template slot=\"title\">\n\t\t<i class=\"el-icon-setting\"></i>\n\t\t<span>学生管理</span>\n\t\t</template>\n\t\t<el-menu-item index=\"add_student\" v-if=\"userType === 2\">新增学生</el-menu-item>\n\t\t<el-menu-item index=\"search_student\" >查询学生信息</el-menu-item>\n\t\t<el-menu-item index=\"update_student\" v-if=\"userType === 2\">修改学生信息</el-menu-item>\n        <el-menu-item index=\"delete_student\" v-if=\"userType === 2\">删除学生</el-menu-item>\n\t</el-submenu>\n<el-menu>\n```\n所以就在`management`组件，也就是管理页面上检测路由变化来进行中间部分特定模块的显示\n\n```\n// management.vue\nexport default {\n    ...\n    watch: {\n        $route(to, from){\n            this.index = to.params.msg;\n\t\t\tthis.table = this.index.split('_')[1];\n        }\n    }\n}\n```\nindex 可以获取到跳转后的路由，似`add_student` ， 从而 `this.table`的值为 student，所以中间的数据部分显示student表。\n\n# 心得\n\n","source":"_posts/database.md","raw":"---\ntitle: database\ncategory: database\ndate: 2018-1-19\ntags: [数据库,课设]\n---\n\n数据库课设笔记\n\n<!-- more -->\n\n# 前言\n\n这学期学习了 **数据库系统** 这门课程, 学习到了关于数据库的知识, 因为课堂学习的是SQL的知识, 做实验也是用到SQL Server, 所以这次课设就选择了MySQL来写,首先当然是知识准备咯.MySQL的语法跟SQL的语法一样.在课堂学习的时候就学习了SQL的语法，先用phpStudy的adminer把数据库及表建立起来，学习Node.js连接MySQL，前端利用ElementUI来快速完成页面的设计.\n\n# 设计过程\n因为选题选的是学生信息管理系统,而做实验的时候就有类似的学生信息系统,所以参考实验并加以修改,总共有 Student,Department,Speciality,Class,Course,SC,User7个表.\n其他就不着重讲了.课程设计报告有详细的。\n\n# 服务端笔记\nExpress采用**body-parser**,一个HTTP请求体解析中间件,使用这个模块可以解析JSON、Raw、文本、URL-encoded格式的请求体.\n``` javascript\nconst bodyParser = require('body-parser');\nconst express = require('express');\nconst app = express();\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({extended: false}))\n```\n引入mysql\n``` javascript\nvar mysql = require('mysql');\nvar conn mysql.createConnection(models.mysql);  //建立MySQL连接\n```\n设计API接口 (使用express的router)\n``` javascript\nvar router = express.Router(); //引入 router\n\nrouter.post('/selectAll', (req, res) => {\n    var params = req.body;  // 前端传过来的参数，进行提取\n    var sql = `SELECT * from ${params.table}`; //使用模版字符串写SQL语句\n    //进行对数据库的查询\n    conn.query(sql, function(err, result) {\n        if(err) {\n            console.log(err);\n            res.send(500,{error: '出错: '+err.sqlMessage});\n        }\n        if(result) {\n            res.json({\n                code: 200,\n                data: result,\n                msg: '查询成功'\n            })\n        }\n    })\n})\n\n\n```\n当查询出错时，一直不了解怎么返回提示信息给前端，后面观察服务端的node进程，`console.log(err)` 打印了一些出错信息，有个字段为sqlMessage，所以就把这个`err.sqlMessage`直接传给前端，有时候出错信息比较复杂，这个因为时间原因没有对这个信息再进行加工，就直接服务端数据库报什么错就直接传给前端了，有点不妥。 \n\n``` javascript\nif(result) {\n    if(result.affectedRows>0){\n        res.json({\n            code: 200,\n            data: result,\n            msg: '删除成功'\n        })\n    }\n    if(result.affectedRows ===0){\n        res.json({\n            code: 200,\n            data: result,\n            msg: '操作没有影响，删除的数据原本就不存在~'\n        })\n    }\n}\n            \n``` \n\n设计*修改*，*删除*API时，对数据库的操作成功会返回个result对象，其有个affectedRows字段，代表操作后所影响到的表的数据的行数，当`affectedRows > 0`说明数据有受到影响，而其为0时，则操作并没有对数据库产生修改，从侧面说明欲修改、删除的数据本就不存在，返回`操作没有影响到数据库，数据不存在`给前端。\n\n# 前端笔记\n前端采用Vue-cli 和 vue-router\n\n整个的管理页面只有中间的具体操作的部分是根据管理模块的类型来按需显示的，又因为管理模块的类型已经在`side-menu`分得很清楚，点击菜单栏上的某个管理模块，中间的部分就显示特定的内容。一开始没有什么思路，后面查阅到`ElementUI`的`el-menu`支持路由模式，点击菜单栏的item，路由会跳转到特定的此item的index值，如下\n```html\n<el-menu\nrouter >\n<el-submenu index=\"1\">\n\t\t<template slot=\"title\">\n\t\t<i class=\"el-icon-setting\"></i>\n\t\t<span>学生管理</span>\n\t\t</template>\n\t\t<el-menu-item index=\"add_student\" v-if=\"userType === 2\">新增学生</el-menu-item>\n\t\t<el-menu-item index=\"search_student\" >查询学生信息</el-menu-item>\n\t\t<el-menu-item index=\"update_student\" v-if=\"userType === 2\">修改学生信息</el-menu-item>\n        <el-menu-item index=\"delete_student\" v-if=\"userType === 2\">删除学生</el-menu-item>\n\t</el-submenu>\n<el-menu>\n```\n所以就在`management`组件，也就是管理页面上检测路由变化来进行中间部分特定模块的显示\n\n```\n// management.vue\nexport default {\n    ...\n    watch: {\n        $route(to, from){\n            this.index = to.params.msg;\n\t\t\tthis.table = this.index.split('_')[1];\n        }\n    }\n}\n```\nindex 可以获取到跳转后的路由，似`add_student` ， 从而 `this.table`的值为 student，所以中间的数据部分显示student表。\n\n# 心得\n\n","slug":"database","published":1,"updated":"2018-03-15T07:55:53.148Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf81eh85000lv4eflu6hqkes","content":"<p>数据库课设笔记</p>\n<a id=\"more\"></a>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>这学期学习了 <strong>数据库系统</strong> 这门课程, 学习到了关于数据库的知识, 因为课堂学习的是SQL的知识, 做实验也是用到SQL Server, 所以这次课设就选择了MySQL来写,首先当然是知识准备咯.MySQL的语法跟SQL的语法一样.在课堂学习的时候就学习了SQL的语法，先用phpStudy的adminer把数据库及表建立起来，学习Node.js连接MySQL，前端利用ElementUI来快速完成页面的设计.</p>\n<h1 id=\"设计过程\"><a href=\"#设计过程\" class=\"headerlink\" title=\"设计过程\"></a>设计过程</h1><p>因为选题选的是学生信息管理系统,而做实验的时候就有类似的学生信息系统,所以参考实验并加以修改,总共有 Student,Department,Speciality,Class,Course,SC,User7个表.<br>其他就不着重讲了.课程设计报告有详细的。</p>\n<h1 id=\"服务端笔记\"><a href=\"#服务端笔记\" class=\"headerlink\" title=\"服务端笔记\"></a>服务端笔记</h1><p>Express采用<strong>body-parser</strong>,一个HTTP请求体解析中间件,使用这个模块可以解析JSON、Raw、文本、URL-encoded格式的请求体.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(bodyParser.json());</span><br><span class=\"line\">app.use(bodyParser.urlencoded(&#123;<span class=\"attr\">extended</span>: <span class=\"literal\">false</span>&#125;))</span><br></pre></td></tr></table></figure></p>\n<p>引入mysql<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mysql = <span class=\"built_in\">require</span>(<span class=\"string\">'mysql'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> conn mysql.createConnection(models.mysql);  <span class=\"comment\">//建立MySQL连接</span></span><br></pre></td></tr></table></figure></p>\n<p>设计API接口 (使用express的router)<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> router = express.Router(); <span class=\"comment\">//引入 router</span></span><br><span class=\"line\"></span><br><span class=\"line\">router.post(<span class=\"string\">'/selectAll'</span>, (req, res) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> params = req.body;  <span class=\"comment\">// 前端传过来的参数，进行提取</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> sql = <span class=\"string\">`SELECT * from <span class=\"subst\">$&#123;params.table&#125;</span>`</span>; <span class=\"comment\">//使用模版字符串写SQL语句</span></span><br><span class=\"line\">    <span class=\"comment\">//进行对数据库的查询</span></span><br><span class=\"line\">    conn.query(sql, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(err) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">            res.send(<span class=\"number\">500</span>,&#123;<span class=\"attr\">error</span>: <span class=\"string\">'出错: '</span>+err.sqlMessage&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(result) &#123;</span><br><span class=\"line\">            res.json(&#123;</span><br><span class=\"line\">                code: <span class=\"number\">200</span>,</span><br><span class=\"line\">                data: result,</span><br><span class=\"line\">                msg: <span class=\"string\">'查询成功'</span></span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>当查询出错时，一直不了解怎么返回提示信息给前端，后面观察服务端的node进程，<code>console.log(err)</code> 打印了一些出错信息，有个字段为sqlMessage，所以就把这个<code>err.sqlMessage</code>直接传给前端，有时候出错信息比较复杂，这个因为时间原因没有对这个信息再进行加工，就直接服务端数据库报什么错就直接传给前端了，有点不妥。 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(result) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(result.affectedRows&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        res.json(&#123;</span><br><span class=\"line\">            code: <span class=\"number\">200</span>,</span><br><span class=\"line\">            data: result,</span><br><span class=\"line\">            msg: <span class=\"string\">'删除成功'</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(result.affectedRows ===<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        res.json(&#123;</span><br><span class=\"line\">            code: <span class=\"number\">200</span>,</span><br><span class=\"line\">            data: result,</span><br><span class=\"line\">            msg: <span class=\"string\">'操作没有影响，删除的数据原本就不存在~'</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">设计*修改*，*删除*API时，对数据库的操作成功会返回个result对象，其有个affectedRows字段，代表操作后所影响到的表的数据的行数，当`</span>affectedRows &gt; <span class=\"number\">0</span><span class=\"string\">`说明数据有受到影响，而其为0时，则操作并没有对数据库产生修改，从侧面说明欲修改、删除的数据本就不存在，返回`</span>操作没有影响到数据库，数据不存在<span class=\"string\">`给前端。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"># 前端笔记</span></span><br><span class=\"line\"><span class=\"string\">前端采用Vue-cli 和 vue-router</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">整个的管理页面只有中间的具体操作的部分是根据管理模块的类型来按需显示的，又因为管理模块的类型已经在`</span>side-menu<span class=\"string\">`分得很清楚，点击菜单栏上的某个管理模块，中间的部分就显示特定的内容。一开始没有什么思路，后面查阅到`</span>ElementUI<span class=\"string\">`的`</span>el-menu<span class=\"string\">`支持路由模式，点击菜单栏的item，路由会跳转到特定的此item的index值，如下</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>html</span><br><span class=\"line\">&lt;el-menu</span><br><span class=\"line\">router &gt;</span><br><span class=\"line\">&lt;el-submenu index=<span class=\"string\">\"1\"</span>&gt;</span><br><span class=\"line\">\t\t&lt;template slot=<span class=\"string\">\"title\"</span>&gt;</span><br><span class=\"line\">\t\t&lt;i <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"el-icon-setting\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span></span></span><br><span class=\"line\">\t\t&lt;span&gt;学生管理&lt;<span class=\"regexp\">/span&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t\t&lt;/</span>template&gt;</span><br><span class=\"line\">\t\t&lt;el-menu-item index=<span class=\"string\">\"add_student\"</span> v-<span class=\"keyword\">if</span>=<span class=\"string\">\"userType === 2\"</span>&gt;新增学生&lt;<span class=\"regexp\">/el-menu-item&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t\t&lt;el-menu-item index=\"search_student\" &gt;查询学生信息&lt;/</span>el-menu-item&gt;</span><br><span class=\"line\">\t\t&lt;el-menu-item index=<span class=\"string\">\"update_student\"</span> v-<span class=\"keyword\">if</span>=<span class=\"string\">\"userType === 2\"</span>&gt;修改学生信息&lt;<span class=\"regexp\">/el-menu-item&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;el-menu-item index=\"delete_student\" v-if=\"userType === 2\"&gt;删除学生&lt;/</span>el-menu-item&gt;</span><br><span class=\"line\">\t&lt;<span class=\"regexp\">/el-submenu&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;el-menu&gt;</span></span><br></pre></td></tr></table></figure>\n<p>所以就在<code>management</code>组件，也就是管理页面上检测路由变化来进行中间部分特定模块的显示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// management.vue</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    watch: &#123;</span><br><span class=\"line\">        $route(to, from)&#123;</span><br><span class=\"line\">            this.index = to.params.msg;</span><br><span class=\"line\">\t\t\tthis.table = this.index.split(&apos;_&apos;)[1];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>index 可以获取到跳转后的路由，似<code>add_student</code> ， 从而 <code>this.table</code>的值为 student，所以中间的数据部分显示student表。</p>\n<h1 id=\"心得\"><a href=\"#心得\" class=\"headerlink\" title=\"心得\"></a>心得</h1>","site":{"data":{}},"excerpt":"<p>数据库课设笔记</p>","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>这学期学习了 <strong>数据库系统</strong> 这门课程, 学习到了关于数据库的知识, 因为课堂学习的是SQL的知识, 做实验也是用到SQL Server, 所以这次课设就选择了MySQL来写,首先当然是知识准备咯.MySQL的语法跟SQL的语法一样.在课堂学习的时候就学习了SQL的语法，先用phpStudy的adminer把数据库及表建立起来，学习Node.js连接MySQL，前端利用ElementUI来快速完成页面的设计.</p>\n<h1 id=\"设计过程\"><a href=\"#设计过程\" class=\"headerlink\" title=\"设计过程\"></a>设计过程</h1><p>因为选题选的是学生信息管理系统,而做实验的时候就有类似的学生信息系统,所以参考实验并加以修改,总共有 Student,Department,Speciality,Class,Course,SC,User7个表.<br>其他就不着重讲了.课程设计报告有详细的。</p>\n<h1 id=\"服务端笔记\"><a href=\"#服务端笔记\" class=\"headerlink\" title=\"服务端笔记\"></a>服务端笔记</h1><p>Express采用<strong>body-parser</strong>,一个HTTP请求体解析中间件,使用这个模块可以解析JSON、Raw、文本、URL-encoded格式的请求体.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(bodyParser.json());</span><br><span class=\"line\">app.use(bodyParser.urlencoded(&#123;<span class=\"attr\">extended</span>: <span class=\"literal\">false</span>&#125;))</span><br></pre></td></tr></table></figure></p>\n<p>引入mysql<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mysql = <span class=\"built_in\">require</span>(<span class=\"string\">'mysql'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> conn mysql.createConnection(models.mysql);  <span class=\"comment\">//建立MySQL连接</span></span><br></pre></td></tr></table></figure></p>\n<p>设计API接口 (使用express的router)<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> router = express.Router(); <span class=\"comment\">//引入 router</span></span><br><span class=\"line\"></span><br><span class=\"line\">router.post(<span class=\"string\">'/selectAll'</span>, (req, res) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> params = req.body;  <span class=\"comment\">// 前端传过来的参数，进行提取</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> sql = <span class=\"string\">`SELECT * from <span class=\"subst\">$&#123;params.table&#125;</span>`</span>; <span class=\"comment\">//使用模版字符串写SQL语句</span></span><br><span class=\"line\">    <span class=\"comment\">//进行对数据库的查询</span></span><br><span class=\"line\">    conn.query(sql, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(err) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">            res.send(<span class=\"number\">500</span>,&#123;<span class=\"attr\">error</span>: <span class=\"string\">'出错: '</span>+err.sqlMessage&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(result) &#123;</span><br><span class=\"line\">            res.json(&#123;</span><br><span class=\"line\">                code: <span class=\"number\">200</span>,</span><br><span class=\"line\">                data: result,</span><br><span class=\"line\">                msg: <span class=\"string\">'查询成功'</span></span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>当查询出错时，一直不了解怎么返回提示信息给前端，后面观察服务端的node进程，<code>console.log(err)</code> 打印了一些出错信息，有个字段为sqlMessage，所以就把这个<code>err.sqlMessage</code>直接传给前端，有时候出错信息比较复杂，这个因为时间原因没有对这个信息再进行加工，就直接服务端数据库报什么错就直接传给前端了，有点不妥。 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(result) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(result.affectedRows&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        res.json(&#123;</span><br><span class=\"line\">            code: <span class=\"number\">200</span>,</span><br><span class=\"line\">            data: result,</span><br><span class=\"line\">            msg: <span class=\"string\">'删除成功'</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(result.affectedRows ===<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        res.json(&#123;</span><br><span class=\"line\">            code: <span class=\"number\">200</span>,</span><br><span class=\"line\">            data: result,</span><br><span class=\"line\">            msg: <span class=\"string\">'操作没有影响，删除的数据原本就不存在~'</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">设计*修改*，*删除*API时，对数据库的操作成功会返回个result对象，其有个affectedRows字段，代表操作后所影响到的表的数据的行数，当`</span>affectedRows &gt; <span class=\"number\">0</span><span class=\"string\">`说明数据有受到影响，而其为0时，则操作并没有对数据库产生修改，从侧面说明欲修改、删除的数据本就不存在，返回`</span>操作没有影响到数据库，数据不存在<span class=\"string\">`给前端。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"># 前端笔记</span></span><br><span class=\"line\"><span class=\"string\">前端采用Vue-cli 和 vue-router</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">整个的管理页面只有中间的具体操作的部分是根据管理模块的类型来按需显示的，又因为管理模块的类型已经在`</span>side-menu<span class=\"string\">`分得很清楚，点击菜单栏上的某个管理模块，中间的部分就显示特定的内容。一开始没有什么思路，后面查阅到`</span>ElementUI<span class=\"string\">`的`</span>el-menu<span class=\"string\">`支持路由模式，点击菜单栏的item，路由会跳转到特定的此item的index值，如下</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>html</span><br><span class=\"line\">&lt;el-menu</span><br><span class=\"line\">router &gt;</span><br><span class=\"line\">&lt;el-submenu index=<span class=\"string\">\"1\"</span>&gt;</span><br><span class=\"line\">\t\t&lt;template slot=<span class=\"string\">\"title\"</span>&gt;</span><br><span class=\"line\">\t\t&lt;i <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"el-icon-setting\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span></span></span><br><span class=\"line\">\t\t&lt;span&gt;学生管理&lt;<span class=\"regexp\">/span&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t\t&lt;/</span>template&gt;</span><br><span class=\"line\">\t\t&lt;el-menu-item index=<span class=\"string\">\"add_student\"</span> v-<span class=\"keyword\">if</span>=<span class=\"string\">\"userType === 2\"</span>&gt;新增学生&lt;<span class=\"regexp\">/el-menu-item&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t\t&lt;el-menu-item index=\"search_student\" &gt;查询学生信息&lt;/</span>el-menu-item&gt;</span><br><span class=\"line\">\t\t&lt;el-menu-item index=<span class=\"string\">\"update_student\"</span> v-<span class=\"keyword\">if</span>=<span class=\"string\">\"userType === 2\"</span>&gt;修改学生信息&lt;<span class=\"regexp\">/el-menu-item&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;el-menu-item index=\"delete_student\" v-if=\"userType === 2\"&gt;删除学生&lt;/</span>el-menu-item&gt;</span><br><span class=\"line\">\t&lt;<span class=\"regexp\">/el-submenu&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;el-menu&gt;</span></span><br></pre></td></tr></table></figure>\n<p>所以就在<code>management</code>组件，也就是管理页面上检测路由变化来进行中间部分特定模块的显示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// management.vue</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    watch: &#123;</span><br><span class=\"line\">        $route(to, from)&#123;</span><br><span class=\"line\">            this.index = to.params.msg;</span><br><span class=\"line\">\t\t\tthis.table = this.index.split(&apos;_&apos;)[1];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>index 可以获取到跳转后的路由，似<code>add_student</code> ， 从而 <code>this.table</code>的值为 student，所以中间的数据部分显示student表。</p>\n<h1 id=\"心得\"><a href=\"#心得\" class=\"headerlink\" title=\"心得\"></a>心得</h1>"},{"title":"Hexo部署成功后首页却没显示新文章，这是为什么呢？","date":"2018-03-14T16:00:00.000Z","_content":"记录一次hexo博客部署引发的姿势学习.\n本文涉及到了缓存。早点发现这个原因，就不会用那么多时间来调试hexo部署了，事实证明，是缓存引起的。\n<!-- more -->\n\n<br/>\n<br/>\n其实之前这个问题我也一直遇到过，那时候还不是很了解浏览器缓存的机制，出现问题没有往这方面想，在Ubuntu下，我就直接了当的使用sudo权限模式进行操作...一般来说都是可行的.最近Blog也转到Windows了，所以也就没使用这种方法了.\n``` bash\n$ sudo hexo clean\n$ sudo hexo g\n$ sudo hexo s\n$ sudo hexo d\n```\n\n## 部署不成功？\n生成静态资源文件，本地执行预览命令，进入预览页面发现一切正常，然后执行部署，也没有报错，只是出现一堆警告而已，最后修改是已经提交到git remote仓库的。\n\n`INFO Deploy done: git` 也说明了部署操作成功了。\n那么为什么会出现这个问题呢？\n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fpaiwn7k3kj20k60bxq4b.jpg)\n## 排查问题\n上github查看chenpt.github.io这个repo，里面已经有最新的文章了。\n我把本地预览时的端口号后面的路径复制，前面加上博客绑定的域名（`chenpt.cc/2018/03/13/title/#more`），发现可以访问这篇文章，，可是直接进入chenpt.cc 首页没有显示文章，我想会不会是缓存的问题，我将地址发到微信上，用电脑微信打开，发现一切正常，文章也出现了，转过头打开控制台把chenpt.cc的缓存全清了，再部署一遍\n``` bash\nhexo clean\n\nhexo g -d\n```\n\n\n## 原因\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fpdk62vrq9j20o30g6abx.jpg)\n\n你也可以修改`hexo`主题文件夹里的head文件的meta标签，来添加一个`Cache-Control`首部，强制不从缓存中加载资源，不过不建议这样做，这样会让浏览器每次都会发送请求去确认缓存是否在服务器有更新，这样会多了很多不必要的HTTP请求和一些资源的下载，这些都会造成页面加载时间过久，影响体验，所以，还是每次部署后直接强制刷新页面来得更加简单有效率.\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fpdmzjox7aj20qn06oq40.jpg)\n打开控制台一看NetWork，发现进入网站所请求的资源都是来自浏览器缓存，\n状态码都为200，`(from disk cache)` or `(from memory cache)`，这说明了，所有东西都是在客户端缓存请求的，实际上并没有发出http请求给服务器.（这里是github page）这就是`强缓存`\n\n简单来说，浏览器缓存分为两种，\n一种就是上面所说的`强缓存`，另外一种是`协商缓存`。\n\n1.强缓存：浏览器在加载资源时，首先会先根据首部信息（`Expires`和`Cache-Control`）来判断是否命中强缓存，如果命中，直接从浏览器缓存中将资源取出来，**不会发送请求到服务器**。\n\n2.协商缓存：在没有命中强缓存的前提下，浏览器会发送一个请求（带有一些跟协商缓存有关的首部）给服务器，服务器根据这些首部信息和所请求资源目前的一些header信息来比较验证这个资源是否命中协商缓存，如果命中了，服务器会将这个请求返回，但是并不会返回这个资源的数据，而是告诉浏览器，资源没有变化，可以直接从浏览器缓存中加载这个资源。\n\n命中协商缓存返回的状态信息为\n`304 Not Modified`\n\n3.共同点： `强缓存`和`协商缓存`的共同点是都是`从客户端缓存（浏览器缓存）中加载资源`，服务器并没有返回所请求的资源的数据.\n\n4.区别： 强缓存没有发送请求到服务器，协商缓存会发送请求到服务器。\n\n5.强缓存的控制首部为：`Expires`和`Cache-Control`\n\n6.协商缓存的控制首部为：配对的[`Last-Modified`,`If-Modified-Since`] 和[`Etag`,`If-None-Match`]\n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fpdkogtb06j20v30grq4t.jpg)\n\n所以，页面没有更新为最新的原因就是浏览器直接从强缓存中加载资源，\n\n`Cache-Control: max-age=600`说明资源从第一次请求后，下次可以再次直接从缓存中加载的有限时间为600s，也就是10分钟，当你在这个时间内再次请求资源，浏览器首先判断这个资源是否命中了强缓存，若是命中了则直接从缓存中加载，所以整个页面还是之前缓存的资源，所以并没有请求新的资源，页面也就没有更新为最新状态了。\n\n## 解决办法\n\n### Ctrl-F5强制刷新\n第一个解决办法就是Ctrl-F5强制刷新，这时请求头的Cache-Control：`no-cache`  \n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fpdnqs80o3j20u8066gm9.jpg)\n如果没有生效，那就把localStorage清空再刷新页面.（一般都是有效的，而不用打开控制台去清空当前页面缓存）   \n### Clear Storage\nChrome打开控制台`Application`,点击`clear site data`清除站点数据，然后刷新，应该就会出现最新页面了，如果没有出现，那可能就不是缓存的问题。自行google。\n\n### no-cache & no-store\n\nno-cache并不是表示`不缓存`,而是表示强制确认缓存，意味着使用缓存前必须检查这个资源在服务端是否有更新.\n\n那就顺便说下`Cache-Control:no-store`吧.\n它就比较简单理解了。就是字面意思`不储存`，表示禁止浏览器以及中间缓存储存任何版本的`返回响应信息`.每次用户请求资源时，都会完整的发一个请求，从服务器获得响应，之后浏览器和代理商都不得储存该响应信息.\n\n>Pragma是 HTTP/1.0 定义的首部字段，请求中包含Pragma的效果跟在头部信息定义`Cache-Control: no-cache`效果一样，主要是为了兼容使用HTTP/1.0的客户端.不可以取代`Cache-Cortrol`.还有就是Pragma只在请求首部中使用，不会在响应首部使用。\n\n[Google: Http缓存](https://www.google.com.hk/search?q=HTTP%E7%BC%93%E5%AD%98)\n\n发现自己还需要再去深入理解缓存这一块的东西。得空再去看看，\n下一篇笔记再做总结.","source":"_posts/hexo-Error.md","raw":"---\ntitle: Hexo部署成功后首页却没显示新文章，这是为什么呢？\ncategory: Bug记录\ntags: [hexo, 笔记, HTTP缓存]\ndate: 2018-3-15\n---\n记录一次hexo博客部署引发的姿势学习.\n本文涉及到了缓存。早点发现这个原因，就不会用那么多时间来调试hexo部署了，事实证明，是缓存引起的。\n<!-- more -->\n\n<br/>\n<br/>\n其实之前这个问题我也一直遇到过，那时候还不是很了解浏览器缓存的机制，出现问题没有往这方面想，在Ubuntu下，我就直接了当的使用sudo权限模式进行操作...一般来说都是可行的.最近Blog也转到Windows了，所以也就没使用这种方法了.\n``` bash\n$ sudo hexo clean\n$ sudo hexo g\n$ sudo hexo s\n$ sudo hexo d\n```\n\n## 部署不成功？\n生成静态资源文件，本地执行预览命令，进入预览页面发现一切正常，然后执行部署，也没有报错，只是出现一堆警告而已，最后修改是已经提交到git remote仓库的。\n\n`INFO Deploy done: git` 也说明了部署操作成功了。\n那么为什么会出现这个问题呢？\n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fpaiwn7k3kj20k60bxq4b.jpg)\n## 排查问题\n上github查看chenpt.github.io这个repo，里面已经有最新的文章了。\n我把本地预览时的端口号后面的路径复制，前面加上博客绑定的域名（`chenpt.cc/2018/03/13/title/#more`），发现可以访问这篇文章，，可是直接进入chenpt.cc 首页没有显示文章，我想会不会是缓存的问题，我将地址发到微信上，用电脑微信打开，发现一切正常，文章也出现了，转过头打开控制台把chenpt.cc的缓存全清了，再部署一遍\n``` bash\nhexo clean\n\nhexo g -d\n```\n\n\n## 原因\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fpdk62vrq9j20o30g6abx.jpg)\n\n你也可以修改`hexo`主题文件夹里的head文件的meta标签，来添加一个`Cache-Control`首部，强制不从缓存中加载资源，不过不建议这样做，这样会让浏览器每次都会发送请求去确认缓存是否在服务器有更新，这样会多了很多不必要的HTTP请求和一些资源的下载，这些都会造成页面加载时间过久，影响体验，所以，还是每次部署后直接强制刷新页面来得更加简单有效率.\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fpdmzjox7aj20qn06oq40.jpg)\n打开控制台一看NetWork，发现进入网站所请求的资源都是来自浏览器缓存，\n状态码都为200，`(from disk cache)` or `(from memory cache)`，这说明了，所有东西都是在客户端缓存请求的，实际上并没有发出http请求给服务器.（这里是github page）这就是`强缓存`\n\n简单来说，浏览器缓存分为两种，\n一种就是上面所说的`强缓存`，另外一种是`协商缓存`。\n\n1.强缓存：浏览器在加载资源时，首先会先根据首部信息（`Expires`和`Cache-Control`）来判断是否命中强缓存，如果命中，直接从浏览器缓存中将资源取出来，**不会发送请求到服务器**。\n\n2.协商缓存：在没有命中强缓存的前提下，浏览器会发送一个请求（带有一些跟协商缓存有关的首部）给服务器，服务器根据这些首部信息和所请求资源目前的一些header信息来比较验证这个资源是否命中协商缓存，如果命中了，服务器会将这个请求返回，但是并不会返回这个资源的数据，而是告诉浏览器，资源没有变化，可以直接从浏览器缓存中加载这个资源。\n\n命中协商缓存返回的状态信息为\n`304 Not Modified`\n\n3.共同点： `强缓存`和`协商缓存`的共同点是都是`从客户端缓存（浏览器缓存）中加载资源`，服务器并没有返回所请求的资源的数据.\n\n4.区别： 强缓存没有发送请求到服务器，协商缓存会发送请求到服务器。\n\n5.强缓存的控制首部为：`Expires`和`Cache-Control`\n\n6.协商缓存的控制首部为：配对的[`Last-Modified`,`If-Modified-Since`] 和[`Etag`,`If-None-Match`]\n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fpdkogtb06j20v30grq4t.jpg)\n\n所以，页面没有更新为最新的原因就是浏览器直接从强缓存中加载资源，\n\n`Cache-Control: max-age=600`说明资源从第一次请求后，下次可以再次直接从缓存中加载的有限时间为600s，也就是10分钟，当你在这个时间内再次请求资源，浏览器首先判断这个资源是否命中了强缓存，若是命中了则直接从缓存中加载，所以整个页面还是之前缓存的资源，所以并没有请求新的资源，页面也就没有更新为最新状态了。\n\n## 解决办法\n\n### Ctrl-F5强制刷新\n第一个解决办法就是Ctrl-F5强制刷新，这时请求头的Cache-Control：`no-cache`  \n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fpdnqs80o3j20u8066gm9.jpg)\n如果没有生效，那就把localStorage清空再刷新页面.（一般都是有效的，而不用打开控制台去清空当前页面缓存）   \n### Clear Storage\nChrome打开控制台`Application`,点击`clear site data`清除站点数据，然后刷新，应该就会出现最新页面了，如果没有出现，那可能就不是缓存的问题。自行google。\n\n### no-cache & no-store\n\nno-cache并不是表示`不缓存`,而是表示强制确认缓存，意味着使用缓存前必须检查这个资源在服务端是否有更新.\n\n那就顺便说下`Cache-Control:no-store`吧.\n它就比较简单理解了。就是字面意思`不储存`，表示禁止浏览器以及中间缓存储存任何版本的`返回响应信息`.每次用户请求资源时，都会完整的发一个请求，从服务器获得响应，之后浏览器和代理商都不得储存该响应信息.\n\n>Pragma是 HTTP/1.0 定义的首部字段，请求中包含Pragma的效果跟在头部信息定义`Cache-Control: no-cache`效果一样，主要是为了兼容使用HTTP/1.0的客户端.不可以取代`Cache-Cortrol`.还有就是Pragma只在请求首部中使用，不会在响应首部使用。\n\n[Google: Http缓存](https://www.google.com.hk/search?q=HTTP%E7%BC%93%E5%AD%98)\n\n发现自己还需要再去深入理解缓存这一块的东西。得空再去看看，\n下一篇笔记再做总结.","slug":"hexo-Error","published":1,"updated":"2018-03-15T19:24:53.933Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf81eh8a000qv4efialwuas4","content":"<p>记录一次hexo博客部署引发的姿势学习.<br>本文涉及到了缓存。早点发现这个原因，就不会用那么多时间来调试hexo部署了，事实证明，是缓存引起的。<br><a id=\"more\"></a></p>\n<p><br><br><br><br>其实之前这个问题我也一直遇到过，那时候还不是很了解浏览器缓存的机制，出现问题没有往这方面想，在Ubuntu下，我就直接了当的使用sudo权限模式进行操作…一般来说都是可行的.最近Blog也转到Windows了，所以也就没使用这种方法了.<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo hexo clean</span><br><span class=\"line\">$ sudo hexo g</span><br><span class=\"line\">$ sudo hexo s</span><br><span class=\"line\">$ sudo hexo d</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"部署不成功？\"><a href=\"#部署不成功？\" class=\"headerlink\" title=\"部署不成功？\"></a>部署不成功？</h2><p>生成静态资源文件，本地执行预览命令，进入预览页面发现一切正常，然后执行部署，也没有报错，只是出现一堆警告而已，最后修改是已经提交到git remote仓库的。</p>\n<p><code>INFO Deploy done: git</code> 也说明了部署操作成功了。<br>那么为什么会出现这个问题呢？</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fpaiwn7k3kj20k60bxq4b.jpg\" alt=\"\"></p>\n<h2 id=\"排查问题\"><a href=\"#排查问题\" class=\"headerlink\" title=\"排查问题\"></a>排查问题</h2><p>上github查看chenpt.github.io这个repo，里面已经有最新的文章了。<br>我把本地预览时的端口号后面的路径复制，前面加上博客绑定的域名（<code>chenpt.cc/2018/03/13/title/#more</code>），发现可以访问这篇文章，，可是直接进入chenpt.cc 首页没有显示文章，我想会不会是缓存的问题，我将地址发到微信上，用电脑微信打开，发现一切正常，文章也出现了，转过头打开控制台把chenpt.cc的缓存全清了，再部署一遍<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\"></span><br><span class=\"line\">hexo g -d</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fpdk62vrq9j20o30g6abx.jpg\" alt=\"\"></p>\n<p>你也可以修改<code>hexo</code>主题文件夹里的head文件的meta标签，来添加一个<code>Cache-Control</code>首部，强制不从缓存中加载资源，不过不建议这样做，这样会让浏览器每次都会发送请求去确认缓存是否在服务器有更新，这样会多了很多不必要的HTTP请求和一些资源的下载，这些都会造成页面加载时间过久，影响体验，所以，还是每次部署后直接强制刷新页面来得更加简单有效率.<br><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fpdmzjox7aj20qn06oq40.jpg\" alt=\"\"><br>打开控制台一看NetWork，发现进入网站所请求的资源都是来自浏览器缓存，<br>状态码都为200，<code>(from disk cache)</code> or <code>(from memory cache)</code>，这说明了，所有东西都是在客户端缓存请求的，实际上并没有发出http请求给服务器.（这里是github page）这就是<code>强缓存</code></p>\n<p>简单来说，浏览器缓存分为两种，<br>一种就是上面所说的<code>强缓存</code>，另外一种是<code>协商缓存</code>。</p>\n<p>1.强缓存：浏览器在加载资源时，首先会先根据首部信息（<code>Expires</code>和<code>Cache-Control</code>）来判断是否命中强缓存，如果命中，直接从浏览器缓存中将资源取出来，<strong>不会发送请求到服务器</strong>。</p>\n<p>2.协商缓存：在没有命中强缓存的前提下，浏览器会发送一个请求（带有一些跟协商缓存有关的首部）给服务器，服务器根据这些首部信息和所请求资源目前的一些header信息来比较验证这个资源是否命中协商缓存，如果命中了，服务器会将这个请求返回，但是并不会返回这个资源的数据，而是告诉浏览器，资源没有变化，可以直接从浏览器缓存中加载这个资源。</p>\n<p>命中协商缓存返回的状态信息为<br><code>304 Not Modified</code></p>\n<p>3.共同点： <code>强缓存</code>和<code>协商缓存</code>的共同点是都是<code>从客户端缓存（浏览器缓存）中加载资源</code>，服务器并没有返回所请求的资源的数据.</p>\n<p>4.区别： 强缓存没有发送请求到服务器，协商缓存会发送请求到服务器。</p>\n<p>5.强缓存的控制首部为：<code>Expires</code>和<code>Cache-Control</code></p>\n<p>6.协商缓存的控制首部为：配对的[<code>Last-Modified</code>,<code>If-Modified-Since</code>] 和[<code>Etag</code>,<code>If-None-Match</code>]</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fpdkogtb06j20v30grq4t.jpg\" alt=\"\"></p>\n<p>所以，页面没有更新为最新的原因就是浏览器直接从强缓存中加载资源，</p>\n<p><code>Cache-Control: max-age=600</code>说明资源从第一次请求后，下次可以再次直接从缓存中加载的有限时间为600s，也就是10分钟，当你在这个时间内再次请求资源，浏览器首先判断这个资源是否命中了强缓存，若是命中了则直接从缓存中加载，所以整个页面还是之前缓存的资源，所以并没有请求新的资源，页面也就没有更新为最新状态了。</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><h3 id=\"Ctrl-F5强制刷新\"><a href=\"#Ctrl-F5强制刷新\" class=\"headerlink\" title=\"Ctrl-F5强制刷新\"></a>Ctrl-F5强制刷新</h3><p>第一个解决办法就是Ctrl-F5强制刷新，这时请求头的Cache-Control：<code>no-cache</code><br><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fpdnqs80o3j20u8066gm9.jpg\" alt=\"\"><br>如果没有生效，那就把localStorage清空再刷新页面.（一般都是有效的，而不用打开控制台去清空当前页面缓存）   </p>\n<h3 id=\"Clear-Storage\"><a href=\"#Clear-Storage\" class=\"headerlink\" title=\"Clear Storage\"></a>Clear Storage</h3><p>Chrome打开控制台<code>Application</code>,点击<code>clear site data</code>清除站点数据，然后刷新，应该就会出现最新页面了，如果没有出现，那可能就不是缓存的问题。自行google。</p>\n<h3 id=\"no-cache-amp-no-store\"><a href=\"#no-cache-amp-no-store\" class=\"headerlink\" title=\"no-cache &amp; no-store\"></a>no-cache &amp; no-store</h3><p>no-cache并不是表示<code>不缓存</code>,而是表示强制确认缓存，意味着使用缓存前必须检查这个资源在服务端是否有更新.</p>\n<p>那就顺便说下<code>Cache-Control:no-store</code>吧.<br>它就比较简单理解了。就是字面意思<code>不储存</code>，表示禁止浏览器以及中间缓存储存任何版本的<code>返回响应信息</code>.每次用户请求资源时，都会完整的发一个请求，从服务器获得响应，之后浏览器和代理商都不得储存该响应信息.</p>\n<blockquote>\n<p>Pragma是 HTTP/1.0 定义的首部字段，请求中包含Pragma的效果跟在头部信息定义<code>Cache-Control: no-cache</code>效果一样，主要是为了兼容使用HTTP/1.0的客户端.不可以取代<code>Cache-Cortrol</code>.还有就是Pragma只在请求首部中使用，不会在响应首部使用。</p>\n</blockquote>\n<p><a href=\"https://www.google.com.hk/search?q=HTTP%E7%BC%93%E5%AD%98\" target=\"_blank\" rel=\"noopener\">Google: Http缓存</a></p>\n<p>发现自己还需要再去深入理解缓存这一块的东西。得空再去看看，<br>下一篇笔记再做总结.</p>\n","site":{"data":{}},"excerpt":"<p>记录一次hexo博客部署引发的姿势学习.<br>本文涉及到了缓存。早点发现这个原因，就不会用那么多时间来调试hexo部署了，事实证明，是缓存引起的。<br>","more":"</p>\n<p><br><br><br><br>其实之前这个问题我也一直遇到过，那时候还不是很了解浏览器缓存的机制，出现问题没有往这方面想，在Ubuntu下，我就直接了当的使用sudo权限模式进行操作…一般来说都是可行的.最近Blog也转到Windows了，所以也就没使用这种方法了.<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo hexo clean</span><br><span class=\"line\">$ sudo hexo g</span><br><span class=\"line\">$ sudo hexo s</span><br><span class=\"line\">$ sudo hexo d</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"部署不成功？\"><a href=\"#部署不成功？\" class=\"headerlink\" title=\"部署不成功？\"></a>部署不成功？</h2><p>生成静态资源文件，本地执行预览命令，进入预览页面发现一切正常，然后执行部署，也没有报错，只是出现一堆警告而已，最后修改是已经提交到git remote仓库的。</p>\n<p><code>INFO Deploy done: git</code> 也说明了部署操作成功了。<br>那么为什么会出现这个问题呢？</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fpaiwn7k3kj20k60bxq4b.jpg\" alt=\"\"></p>\n<h2 id=\"排查问题\"><a href=\"#排查问题\" class=\"headerlink\" title=\"排查问题\"></a>排查问题</h2><p>上github查看chenpt.github.io这个repo，里面已经有最新的文章了。<br>我把本地预览时的端口号后面的路径复制，前面加上博客绑定的域名（<code>chenpt.cc/2018/03/13/title/#more</code>），发现可以访问这篇文章，，可是直接进入chenpt.cc 首页没有显示文章，我想会不会是缓存的问题，我将地址发到微信上，用电脑微信打开，发现一切正常，文章也出现了，转过头打开控制台把chenpt.cc的缓存全清了，再部署一遍<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\"></span><br><span class=\"line\">hexo g -d</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fpdk62vrq9j20o30g6abx.jpg\" alt=\"\"></p>\n<p>你也可以修改<code>hexo</code>主题文件夹里的head文件的meta标签，来添加一个<code>Cache-Control</code>首部，强制不从缓存中加载资源，不过不建议这样做，这样会让浏览器每次都会发送请求去确认缓存是否在服务器有更新，这样会多了很多不必要的HTTP请求和一些资源的下载，这些都会造成页面加载时间过久，影响体验，所以，还是每次部署后直接强制刷新页面来得更加简单有效率.<br><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fpdmzjox7aj20qn06oq40.jpg\" alt=\"\"><br>打开控制台一看NetWork，发现进入网站所请求的资源都是来自浏览器缓存，<br>状态码都为200，<code>(from disk cache)</code> or <code>(from memory cache)</code>，这说明了，所有东西都是在客户端缓存请求的，实际上并没有发出http请求给服务器.（这里是github page）这就是<code>强缓存</code></p>\n<p>简单来说，浏览器缓存分为两种，<br>一种就是上面所说的<code>强缓存</code>，另外一种是<code>协商缓存</code>。</p>\n<p>1.强缓存：浏览器在加载资源时，首先会先根据首部信息（<code>Expires</code>和<code>Cache-Control</code>）来判断是否命中强缓存，如果命中，直接从浏览器缓存中将资源取出来，<strong>不会发送请求到服务器</strong>。</p>\n<p>2.协商缓存：在没有命中强缓存的前提下，浏览器会发送一个请求（带有一些跟协商缓存有关的首部）给服务器，服务器根据这些首部信息和所请求资源目前的一些header信息来比较验证这个资源是否命中协商缓存，如果命中了，服务器会将这个请求返回，但是并不会返回这个资源的数据，而是告诉浏览器，资源没有变化，可以直接从浏览器缓存中加载这个资源。</p>\n<p>命中协商缓存返回的状态信息为<br><code>304 Not Modified</code></p>\n<p>3.共同点： <code>强缓存</code>和<code>协商缓存</code>的共同点是都是<code>从客户端缓存（浏览器缓存）中加载资源</code>，服务器并没有返回所请求的资源的数据.</p>\n<p>4.区别： 强缓存没有发送请求到服务器，协商缓存会发送请求到服务器。</p>\n<p>5.强缓存的控制首部为：<code>Expires</code>和<code>Cache-Control</code></p>\n<p>6.协商缓存的控制首部为：配对的[<code>Last-Modified</code>,<code>If-Modified-Since</code>] 和[<code>Etag</code>,<code>If-None-Match</code>]</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fpdkogtb06j20v30grq4t.jpg\" alt=\"\"></p>\n<p>所以，页面没有更新为最新的原因就是浏览器直接从强缓存中加载资源，</p>\n<p><code>Cache-Control: max-age=600</code>说明资源从第一次请求后，下次可以再次直接从缓存中加载的有限时间为600s，也就是10分钟，当你在这个时间内再次请求资源，浏览器首先判断这个资源是否命中了强缓存，若是命中了则直接从缓存中加载，所以整个页面还是之前缓存的资源，所以并没有请求新的资源，页面也就没有更新为最新状态了。</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><h3 id=\"Ctrl-F5强制刷新\"><a href=\"#Ctrl-F5强制刷新\" class=\"headerlink\" title=\"Ctrl-F5强制刷新\"></a>Ctrl-F5强制刷新</h3><p>第一个解决办法就是Ctrl-F5强制刷新，这时请求头的Cache-Control：<code>no-cache</code><br><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fpdnqs80o3j20u8066gm9.jpg\" alt=\"\"><br>如果没有生效，那就把localStorage清空再刷新页面.（一般都是有效的，而不用打开控制台去清空当前页面缓存）   </p>\n<h3 id=\"Clear-Storage\"><a href=\"#Clear-Storage\" class=\"headerlink\" title=\"Clear Storage\"></a>Clear Storage</h3><p>Chrome打开控制台<code>Application</code>,点击<code>clear site data</code>清除站点数据，然后刷新，应该就会出现最新页面了，如果没有出现，那可能就不是缓存的问题。自行google。</p>\n<h3 id=\"no-cache-amp-no-store\"><a href=\"#no-cache-amp-no-store\" class=\"headerlink\" title=\"no-cache &amp; no-store\"></a>no-cache &amp; no-store</h3><p>no-cache并不是表示<code>不缓存</code>,而是表示强制确认缓存，意味着使用缓存前必须检查这个资源在服务端是否有更新.</p>\n<p>那就顺便说下<code>Cache-Control:no-store</code>吧.<br>它就比较简单理解了。就是字面意思<code>不储存</code>，表示禁止浏览器以及中间缓存储存任何版本的<code>返回响应信息</code>.每次用户请求资源时，都会完整的发一个请求，从服务器获得响应，之后浏览器和代理商都不得储存该响应信息.</p>\n<blockquote>\n<p>Pragma是 HTTP/1.0 定义的首部字段，请求中包含Pragma的效果跟在头部信息定义<code>Cache-Control: no-cache</code>效果一样，主要是为了兼容使用HTTP/1.0的客户端.不可以取代<code>Cache-Cortrol</code>.还有就是Pragma只在请求首部中使用，不会在响应首部使用。</p>\n</blockquote>\n<p><a href=\"https://www.google.com.hk/search?q=HTTP%E7%BC%93%E5%AD%98\" target=\"_blank\" rel=\"noopener\">Google: Http缓存</a></p>\n<p>发现自己还需要再去深入理解缓存这一块的东西。得空再去看看，<br>下一篇笔记再做总结.</p>"},{"title":"Object.prototype.hasOwnProperty() 与 in操作符的比较","date":"2017-07-18T02:00:00.000Z","_content":"\n\n\n学习整理笔记.\n\n<!-- more -->\n\n\n\n### Object.prototype.hasOwnProperty()\n\n>语法:  obj.hasOwnProperty('prop');  // prop: 要检测的属性\n>若存在 则返回true, 不存在返回false.  \n\n### in 运算符 \n>语法: prop in obj // 存在返回true, 不存在返回false    \n```javascript\n//如果一个属性是从原型链上继承过来的,in运算符也会返回true\nvar a = {\n  name: 'sd'\n}\n\"toString\" in a   //true \n```\n\n因为对象a 继承了Object.prototype对象的所有属性和方法,所以toString存在于a对象中  \n\n\n\n```javascript\nvar b = ['wow', 'my', 'mine'];\n0 in b  // true\n'wow' in b //false\n'length' in b //true； length是一个数组属性\n```\n\n### hasOwnProperty()\n\n```javascript\n//hasOwnProperty()\nvar c = {\n  name: 'cd',\n  sayName: function() {\n    return this.name;\n  }\n}\n\nc.hasOwnProperty(\"name\");  //true\nc.hasOwnProperty(\"toString\")  //false \n```\n\n\n\n采用字面量法创建对象,c继承了Object原型对象的方法,所以可用hasOwnProperty()方法.\n这个方法用来检测一个对象是否含有特定的自身属性.\n该方法会忽略掉从原型链上继承到的属性  \n\n\n\n```javascript\nvar d = Object.create(null);\nd.name = 'cd';\nd.hasOwnProperty('name')  // ERROR: d.hasOwnProperty is not a function(…) \n//解决办法,利用call\nObject.prototype.hasOwnProperty.call(d, 'name'); //true\n```\n\n因为对象d用Object.create()方法创建,并且指定原型对象为null,所以d没有继承其他方法.只有一个特定的自身属性\"name\". 所以对象d是没有hasOwnProperty()方法的,所以报错.\n\n解决办法是,利用call改变hasOwnProperty()this的指向, 使其指向对象d 的上下文, 并给hasOwnProperty()传参数 \"name\". \n\n\n\n### 相同点\n\n两者都可以用来判断对象是否存在某个属性. \n\n### 不同点\nObject.prototype.hasOwnProperty()方法会忽略掉从原型链上继承来的属性,而in运算符不会.","source":"_posts/in.md","raw":"---\ntitle: Object.prototype.hasOwnProperty() 与 in操作符的比较\n\ncategory: JavaScript\n\ntags: Object\n\ndate: 2017-07-18 10:00\n\n---\n\n\n\n学习整理笔记.\n\n<!-- more -->\n\n\n\n### Object.prototype.hasOwnProperty()\n\n>语法:  obj.hasOwnProperty('prop');  // prop: 要检测的属性\n>若存在 则返回true, 不存在返回false.  \n\n### in 运算符 \n>语法: prop in obj // 存在返回true, 不存在返回false    \n```javascript\n//如果一个属性是从原型链上继承过来的,in运算符也会返回true\nvar a = {\n  name: 'sd'\n}\n\"toString\" in a   //true \n```\n\n因为对象a 继承了Object.prototype对象的所有属性和方法,所以toString存在于a对象中  \n\n\n\n```javascript\nvar b = ['wow', 'my', 'mine'];\n0 in b  // true\n'wow' in b //false\n'length' in b //true； length是一个数组属性\n```\n\n### hasOwnProperty()\n\n```javascript\n//hasOwnProperty()\nvar c = {\n  name: 'cd',\n  sayName: function() {\n    return this.name;\n  }\n}\n\nc.hasOwnProperty(\"name\");  //true\nc.hasOwnProperty(\"toString\")  //false \n```\n\n\n\n采用字面量法创建对象,c继承了Object原型对象的方法,所以可用hasOwnProperty()方法.\n这个方法用来检测一个对象是否含有特定的自身属性.\n该方法会忽略掉从原型链上继承到的属性  \n\n\n\n```javascript\nvar d = Object.create(null);\nd.name = 'cd';\nd.hasOwnProperty('name')  // ERROR: d.hasOwnProperty is not a function(…) \n//解决办法,利用call\nObject.prototype.hasOwnProperty.call(d, 'name'); //true\n```\n\n因为对象d用Object.create()方法创建,并且指定原型对象为null,所以d没有继承其他方法.只有一个特定的自身属性\"name\". 所以对象d是没有hasOwnProperty()方法的,所以报错.\n\n解决办法是,利用call改变hasOwnProperty()this的指向, 使其指向对象d 的上下文, 并给hasOwnProperty()传参数 \"name\". \n\n\n\n### 相同点\n\n两者都可以用来判断对象是否存在某个属性. \n\n### 不同点\nObject.prototype.hasOwnProperty()方法会忽略掉从原型链上继承来的属性,而in运算符不会.","slug":"in","published":1,"updated":"2017-07-18T07:50:03.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf81eh8e000tv4efx4ayngej","content":"<p>学习整理笔记.</p>\n<a id=\"more\"></a>\n<h3 id=\"Object-prototype-hasOwnProperty\"><a href=\"#Object-prototype-hasOwnProperty\" class=\"headerlink\" title=\"Object.prototype.hasOwnProperty()\"></a>Object.prototype.hasOwnProperty()</h3><blockquote>\n<p>语法:  obj.hasOwnProperty(‘prop’);  // prop: 要检测的属性<br>若存在 则返回true, 不存在返回false.  </p>\n</blockquote>\n<h3 id=\"in-运算符\"><a href=\"#in-运算符\" class=\"headerlink\" title=\"in 运算符\"></a>in 运算符</h3><blockquote>\n<p>语法: prop in obj // 存在返回true, 不存在返回false<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如果一个属性是从原型链上继承过来的,in运算符也会返回true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'sd'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">\"toString\"</span> <span class=\"keyword\">in</span> a   <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>因为对象a 继承了Object.prototype对象的所有属性和方法,所以toString存在于a对象中  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"string\">'wow'</span>, <span class=\"string\">'my'</span>, <span class=\"string\">'mine'</span>];</span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"keyword\">in</span> b  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">'wow'</span> <span class=\"keyword\">in</span> b <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"string\">'length'</span> <span class=\"keyword\">in</span> b <span class=\"comment\">//true； length是一个数组属性</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"hasOwnProperty-NaN\"><a href=\"#hasOwnProperty-NaN\" class=\"headerlink\" title=\"hasOwnProperty()\"></a>hasOwnProperty()</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//hasOwnProperty()</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'cd'</span>,</span><br><span class=\"line\">  sayName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">c.hasOwnProperty(<span class=\"string\">\"name\"</span>);  <span class=\"comment\">//true</span></span><br><span class=\"line\">c.hasOwnProperty(<span class=\"string\">\"toString\"</span>)  <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>采用字面量法创建对象,c继承了Object原型对象的方法,所以可用hasOwnProperty()方法.<br>这个方法用来检测一个对象是否含有特定的自身属性.<br>该方法会忽略掉从原型链上继承到的属性  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\">d.name = <span class=\"string\">'cd'</span>;</span><br><span class=\"line\">d.hasOwnProperty(<span class=\"string\">'name'</span>)  <span class=\"comment\">// ERROR: d.hasOwnProperty is not a function(…) </span></span><br><span class=\"line\"><span class=\"comment\">//解决办法,利用call</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(d, <span class=\"string\">'name'</span>); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>因为对象d用Object.create()方法创建,并且指定原型对象为null,所以d没有继承其他方法.只有一个特定的自身属性”name”. 所以对象d是没有hasOwnProperty()方法的,所以报错.</p>\n<p>解决办法是,利用call改变hasOwnProperty()this的指向, 使其指向对象d 的上下文, 并给hasOwnProperty()传参数 “name”. </p>\n<h3 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h3><p>两者都可以用来判断对象是否存在某个属性. </p>\n<h3 id=\"不同点\"><a href=\"#不同点\" class=\"headerlink\" title=\"不同点\"></a>不同点</h3><p>Object.prototype.hasOwnProperty()方法会忽略掉从原型链上继承来的属性,而in运算符不会.</p>\n","site":{"data":{}},"excerpt":"<p>学习整理笔记.</p>","more":"<h3 id=\"Object-prototype-hasOwnProperty\"><a href=\"#Object-prototype-hasOwnProperty\" class=\"headerlink\" title=\"Object.prototype.hasOwnProperty()\"></a>Object.prototype.hasOwnProperty()</h3><blockquote>\n<p>语法:  obj.hasOwnProperty(‘prop’);  // prop: 要检测的属性<br>若存在 则返回true, 不存在返回false.  </p>\n</blockquote>\n<h3 id=\"in-运算符\"><a href=\"#in-运算符\" class=\"headerlink\" title=\"in 运算符\"></a>in 运算符</h3><blockquote>\n<p>语法: prop in obj // 存在返回true, 不存在返回false<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如果一个属性是从原型链上继承过来的,in运算符也会返回true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'sd'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">\"toString\"</span> <span class=\"keyword\">in</span> a   <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>因为对象a 继承了Object.prototype对象的所有属性和方法,所以toString存在于a对象中  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"string\">'wow'</span>, <span class=\"string\">'my'</span>, <span class=\"string\">'mine'</span>];</span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"keyword\">in</span> b  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">'wow'</span> <span class=\"keyword\">in</span> b <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"string\">'length'</span> <span class=\"keyword\">in</span> b <span class=\"comment\">//true； length是一个数组属性</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"hasOwnProperty-NaN\"><a href=\"#hasOwnProperty-NaN\" class=\"headerlink\" title=\"hasOwnProperty()\"></a>hasOwnProperty()</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//hasOwnProperty()</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'cd'</span>,</span><br><span class=\"line\">  sayName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">c.hasOwnProperty(<span class=\"string\">\"name\"</span>);  <span class=\"comment\">//true</span></span><br><span class=\"line\">c.hasOwnProperty(<span class=\"string\">\"toString\"</span>)  <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>采用字面量法创建对象,c继承了Object原型对象的方法,所以可用hasOwnProperty()方法.<br>这个方法用来检测一个对象是否含有特定的自身属性.<br>该方法会忽略掉从原型链上继承到的属性  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\">d.name = <span class=\"string\">'cd'</span>;</span><br><span class=\"line\">d.hasOwnProperty(<span class=\"string\">'name'</span>)  <span class=\"comment\">// ERROR: d.hasOwnProperty is not a function(…) </span></span><br><span class=\"line\"><span class=\"comment\">//解决办法,利用call</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(d, <span class=\"string\">'name'</span>); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>因为对象d用Object.create()方法创建,并且指定原型对象为null,所以d没有继承其他方法.只有一个特定的自身属性”name”. 所以对象d是没有hasOwnProperty()方法的,所以报错.</p>\n<p>解决办法是,利用call改变hasOwnProperty()this的指向, 使其指向对象d 的上下文, 并给hasOwnProperty()传参数 “name”. </p>\n<h3 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h3><p>两者都可以用来判断对象是否存在某个属性. </p>\n<h3 id=\"不同点\"><a href=\"#不同点\" class=\"headerlink\" title=\"不同点\"></a>不同点</h3><p>Object.prototype.hasOwnProperty()方法会忽略掉从原型链上继承来的属性,而in运算符不会.</p>"},{"title":"用Hexo+github pages搭建Blog 的笔记(主要是Hexo的笔记)","date":"2016-07-24T16:00:00.000Z","_content":"\n\n---\n因为 github 远程仓库之前已经建好了 所以跳过github pages 仓库的创建\nHexo 初始化\n### 1.安装Hexo\nHexo是基于NodeJS，所以需要先安装NodeJS\n\n    $ npm install -g hexo-cli\n### 2.初始化框架\n\n\n    $ hexo init <yourFLoder>   // 初始化到你创建的那个Blog文件夹\n    $ cd  <YourFloder>  // 切换到你创建的那个Blog文件夹\n\n### 3.安装依赖\n    $ npm install\n### 4.初始化完成大概的目录\n\n    .\n    ├── _config.yml //网站的`配置`信息，您可以在此配置大部分的参数。\n    ├── package.json\n    ├── db.json // json格式的静态常量数据库    \n    ├── node_modules // Hexo的功能JavaScript文件\n    ├── public // 生成静态网页文件\n    ├── scaffolds   //模版文件夹。当您新建文章时，Hexo会根据scaffold来建立文件。\n    ├── source     //资源文件夹是存放用户资源的地方。\n    |   ├── _drafts // 草稿文件夹\n    |   └── _posts // 文章文件夹\n    └── themes     //主题文件夹。Hexo会根据主题来生成静态页面。\n\n### 5.新建文章（默认会创建一个Hello World）\n    $ hexo new <title> for example : \"Hello World\"\n在Blogs/source/_post里添加hello-world.md文件，之后新建的文章都将存放在此目录下.\n如果要删除，直接在此文件夹下删除对应的文件即可\n### 6.生成网站\n    $ hexo generate   // 可以简写 $ hexo g\n此时会将Blogs/source的.md文件生成道/public中，形成网站的静态文件\n### 7.服务器\n    $ hexo server // 在本地客户端查看\n会出现以下内容\n\n    INFO  Start processing\n    INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.\n将**http://localhost:4000/** 复制到浏览器打开就可以预览到默认创建的那个hello world\n### 8.部署网站\n先在博客配置文件 _config.yml中配置你所要部署的站点,这边我是用github pages, 文档最下面有Deployment 只需在这边配置github pages 的信息(type 和 repo 和 branch)(repo的地址上你的github 去复制过来将好了 这边我是用https的 还有一种ssh 没试过,估计后者是不用输密码的~)\n\n    # Deployment\n    ## Docs: https://hexo.io/docs/deployment.html\n    deploy:\n      type: git\n      repo: https://github.com/ChenPt/ChenPt.github.io.git\n      branch: master\ntype那一项有的教程是写github 但是最新版的还是写git 所以写git就好了\n配置好后,把博客deploy(部署)到github上 \n    $ hexo deploy\n此时如果没有意外的话,部署将成功了,打开浏览器输入  **<用户名>.github.io**将可以查看你的blog了\n### 9.常用Hexo命令\n    $ hexo c == hexo clean\n执行此项操作会删除public文件夹中的内容 (也就是我们写的那些md文件)\n\n    $ hexo g == hexo generate   // 将Blogs/source的.md文件生成道/public中，形成网站的静态文件\n    $ hexo s == hexo server  //本地预览(此命令可以在你添加新文章后做预览用 看有没有生效~)\n    $ hexo d == hexo deploy // 部署到你的站点上\n","source":"_posts/hexo-notes.md","raw":"---\ntitle: 用Hexo+github pages搭建Blog 的笔记(主要是Hexo的笔记)\ncategory: blog笔记\ntags: hexo\ndate: 2016-07-25\n---\n\n\n---\n因为 github 远程仓库之前已经建好了 所以跳过github pages 仓库的创建\nHexo 初始化\n### 1.安装Hexo\nHexo是基于NodeJS，所以需要先安装NodeJS\n\n    $ npm install -g hexo-cli\n### 2.初始化框架\n\n\n    $ hexo init <yourFLoder>   // 初始化到你创建的那个Blog文件夹\n    $ cd  <YourFloder>  // 切换到你创建的那个Blog文件夹\n\n### 3.安装依赖\n    $ npm install\n### 4.初始化完成大概的目录\n\n    .\n    ├── _config.yml //网站的`配置`信息，您可以在此配置大部分的参数。\n    ├── package.json\n    ├── db.json // json格式的静态常量数据库    \n    ├── node_modules // Hexo的功能JavaScript文件\n    ├── public // 生成静态网页文件\n    ├── scaffolds   //模版文件夹。当您新建文章时，Hexo会根据scaffold来建立文件。\n    ├── source     //资源文件夹是存放用户资源的地方。\n    |   ├── _drafts // 草稿文件夹\n    |   └── _posts // 文章文件夹\n    └── themes     //主题文件夹。Hexo会根据主题来生成静态页面。\n\n### 5.新建文章（默认会创建一个Hello World）\n    $ hexo new <title> for example : \"Hello World\"\n在Blogs/source/_post里添加hello-world.md文件，之后新建的文章都将存放在此目录下.\n如果要删除，直接在此文件夹下删除对应的文件即可\n### 6.生成网站\n    $ hexo generate   // 可以简写 $ hexo g\n此时会将Blogs/source的.md文件生成道/public中，形成网站的静态文件\n### 7.服务器\n    $ hexo server // 在本地客户端查看\n会出现以下内容\n\n    INFO  Start processing\n    INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.\n将**http://localhost:4000/** 复制到浏览器打开就可以预览到默认创建的那个hello world\n### 8.部署网站\n先在博客配置文件 _config.yml中配置你所要部署的站点,这边我是用github pages, 文档最下面有Deployment 只需在这边配置github pages 的信息(type 和 repo 和 branch)(repo的地址上你的github 去复制过来将好了 这边我是用https的 还有一种ssh 没试过,估计后者是不用输密码的~)\n\n    # Deployment\n    ## Docs: https://hexo.io/docs/deployment.html\n    deploy:\n      type: git\n      repo: https://github.com/ChenPt/ChenPt.github.io.git\n      branch: master\ntype那一项有的教程是写github 但是最新版的还是写git 所以写git就好了\n配置好后,把博客deploy(部署)到github上 \n    $ hexo deploy\n此时如果没有意外的话,部署将成功了,打开浏览器输入  **<用户名>.github.io**将可以查看你的blog了\n### 9.常用Hexo命令\n    $ hexo c == hexo clean\n执行此项操作会删除public文件夹中的内容 (也就是我们写的那些md文件)\n\n    $ hexo g == hexo generate   // 将Blogs/source的.md文件生成道/public中，形成网站的静态文件\n    $ hexo s == hexo server  //本地预览(此命令可以在你添加新文章后做预览用 看有没有生效~)\n    $ hexo d == hexo deploy // 部署到你的站点上\n","slug":"hexo-notes","published":1,"updated":"2017-07-17T04:56:31.612Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf81eh8j000wv4ef530tb9te","content":"<hr>\n<p>因为 github 远程仓库之前已经建好了 所以跳过github pages 仓库的创建<br>Hexo 初始化</p>\n<h3 id=\"1-安装Hexo\"><a href=\"#1-安装Hexo\" class=\"headerlink\" title=\"1.安装Hexo\"></a>1.安装Hexo</h3><p>Hexo是基于NodeJS，所以需要先安装NodeJS</p>\n<pre><code>$ npm install -g hexo-cli\n</code></pre><h3 id=\"2-初始化框架\"><a href=\"#2-初始化框架\" class=\"headerlink\" title=\"2.初始化框架\"></a>2.初始化框架</h3><pre><code>$ hexo init &lt;yourFLoder&gt;   // 初始化到你创建的那个Blog文件夹\n$ cd  &lt;YourFloder&gt;  // 切换到你创建的那个Blog文件夹\n</code></pre><h3 id=\"3-安装依赖\"><a href=\"#3-安装依赖\" class=\"headerlink\" title=\"3.安装依赖\"></a>3.安装依赖</h3><pre><code>$ npm install\n</code></pre><h3 id=\"4-初始化完成大概的目录\"><a href=\"#4-初始化完成大概的目录\" class=\"headerlink\" title=\"4.初始化完成大概的目录\"></a>4.初始化完成大概的目录</h3><pre><code>.\n├── _config.yml //网站的`配置`信息，您可以在此配置大部分的参数。\n├── package.json\n├── db.json // json格式的静态常量数据库    \n├── node_modules // Hexo的功能JavaScript文件\n├── public // 生成静态网页文件\n├── scaffolds   //模版文件夹。当您新建文章时，Hexo会根据scaffold来建立文件。\n├── source     //资源文件夹是存放用户资源的地方。\n|   ├── _drafts // 草稿文件夹\n|   └── _posts // 文章文件夹\n└── themes     //主题文件夹。Hexo会根据主题来生成静态页面。\n</code></pre><h3 id=\"5-新建文章（默认会创建一个Hello-World）\"><a href=\"#5-新建文章（默认会创建一个Hello-World）\" class=\"headerlink\" title=\"5.新建文章（默认会创建一个Hello World）\"></a>5.新建文章（默认会创建一个Hello World）</h3><pre><code>$ hexo new &lt;title&gt; for example : &quot;Hello World&quot;\n</code></pre><p>在Blogs/source/_post里添加hello-world.md文件，之后新建的文章都将存放在此目录下.<br>如果要删除，直接在此文件夹下删除对应的文件即可</p>\n<h3 id=\"6-生成网站\"><a href=\"#6-生成网站\" class=\"headerlink\" title=\"6.生成网站\"></a>6.生成网站</h3><pre><code>$ hexo generate   // 可以简写 $ hexo g\n</code></pre><p>此时会将Blogs/source的.md文件生成道/public中，形成网站的静态文件</p>\n<h3 id=\"7-服务器\"><a href=\"#7-服务器\" class=\"headerlink\" title=\"7.服务器\"></a>7.服务器</h3><pre><code>$ hexo server // 在本地客户端查看\n</code></pre><p>会出现以下内容</p>\n<pre><code>INFO  Start processing\nINFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.\n</code></pre><p>将<strong><a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a></strong> 复制到浏览器打开就可以预览到默认创建的那个hello world</p>\n<h3 id=\"8-部署网站\"><a href=\"#8-部署网站\" class=\"headerlink\" title=\"8.部署网站\"></a>8.部署网站</h3><p>先在博客配置文件 _config.yml中配置你所要部署的站点,这边我是用github pages, 文档最下面有Deployment 只需在这边配置github pages 的信息(type 和 repo 和 branch)(repo的地址上你的github 去复制过来将好了 这边我是用https的 还有一种ssh 没试过,估计后者是不用输密码的~)</p>\n<pre><code># Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: https://github.com/ChenPt/ChenPt.github.io.git\n  branch: master\n</code></pre><p>type那一项有的教程是写github 但是最新版的还是写git 所以写git就好了<br>配置好后,把博客deploy(部署)到github上<br>    $ hexo deploy<br>此时如果没有意外的话,部署将成功了,打开浏览器输入  <strong>&lt;用户名&gt;.github.io</strong>将可以查看你的blog了</p>\n<h3 id=\"9-常用Hexo命令\"><a href=\"#9-常用Hexo命令\" class=\"headerlink\" title=\"9.常用Hexo命令\"></a>9.常用Hexo命令</h3><pre><code>$ hexo c == hexo clean\n</code></pre><p>执行此项操作会删除public文件夹中的内容 (也就是我们写的那些md文件)</p>\n<pre><code>$ hexo g == hexo generate   // 将Blogs/source的.md文件生成道/public中，形成网站的静态文件\n$ hexo s == hexo server  //本地预览(此命令可以在你添加新文章后做预览用 看有没有生效~)\n$ hexo d == hexo deploy // 部署到你的站点上\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<hr>\n<p>因为 github 远程仓库之前已经建好了 所以跳过github pages 仓库的创建<br>Hexo 初始化</p>\n<h3 id=\"1-安装Hexo\"><a href=\"#1-安装Hexo\" class=\"headerlink\" title=\"1.安装Hexo\"></a>1.安装Hexo</h3><p>Hexo是基于NodeJS，所以需要先安装NodeJS</p>\n<pre><code>$ npm install -g hexo-cli\n</code></pre><h3 id=\"2-初始化框架\"><a href=\"#2-初始化框架\" class=\"headerlink\" title=\"2.初始化框架\"></a>2.初始化框架</h3><pre><code>$ hexo init &lt;yourFLoder&gt;   // 初始化到你创建的那个Blog文件夹\n$ cd  &lt;YourFloder&gt;  // 切换到你创建的那个Blog文件夹\n</code></pre><h3 id=\"3-安装依赖\"><a href=\"#3-安装依赖\" class=\"headerlink\" title=\"3.安装依赖\"></a>3.安装依赖</h3><pre><code>$ npm install\n</code></pre><h3 id=\"4-初始化完成大概的目录\"><a href=\"#4-初始化完成大概的目录\" class=\"headerlink\" title=\"4.初始化完成大概的目录\"></a>4.初始化完成大概的目录</h3><pre><code>.\n├── _config.yml //网站的`配置`信息，您可以在此配置大部分的参数。\n├── package.json\n├── db.json // json格式的静态常量数据库    \n├── node_modules // Hexo的功能JavaScript文件\n├── public // 生成静态网页文件\n├── scaffolds   //模版文件夹。当您新建文章时，Hexo会根据scaffold来建立文件。\n├── source     //资源文件夹是存放用户资源的地方。\n|   ├── _drafts // 草稿文件夹\n|   └── _posts // 文章文件夹\n└── themes     //主题文件夹。Hexo会根据主题来生成静态页面。\n</code></pre><h3 id=\"5-新建文章（默认会创建一个Hello-World）\"><a href=\"#5-新建文章（默认会创建一个Hello-World）\" class=\"headerlink\" title=\"5.新建文章（默认会创建一个Hello World）\"></a>5.新建文章（默认会创建一个Hello World）</h3><pre><code>$ hexo new &lt;title&gt; for example : &quot;Hello World&quot;\n</code></pre><p>在Blogs/source/_post里添加hello-world.md文件，之后新建的文章都将存放在此目录下.<br>如果要删除，直接在此文件夹下删除对应的文件即可</p>\n<h3 id=\"6-生成网站\"><a href=\"#6-生成网站\" class=\"headerlink\" title=\"6.生成网站\"></a>6.生成网站</h3><pre><code>$ hexo generate   // 可以简写 $ hexo g\n</code></pre><p>此时会将Blogs/source的.md文件生成道/public中，形成网站的静态文件</p>\n<h3 id=\"7-服务器\"><a href=\"#7-服务器\" class=\"headerlink\" title=\"7.服务器\"></a>7.服务器</h3><pre><code>$ hexo server // 在本地客户端查看\n</code></pre><p>会出现以下内容</p>\n<pre><code>INFO  Start processing\nINFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.\n</code></pre><p>将<strong><a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a></strong> 复制到浏览器打开就可以预览到默认创建的那个hello world</p>\n<h3 id=\"8-部署网站\"><a href=\"#8-部署网站\" class=\"headerlink\" title=\"8.部署网站\"></a>8.部署网站</h3><p>先在博客配置文件 _config.yml中配置你所要部署的站点,这边我是用github pages, 文档最下面有Deployment 只需在这边配置github pages 的信息(type 和 repo 和 branch)(repo的地址上你的github 去复制过来将好了 这边我是用https的 还有一种ssh 没试过,估计后者是不用输密码的~)</p>\n<pre><code># Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: https://github.com/ChenPt/ChenPt.github.io.git\n  branch: master\n</code></pre><p>type那一项有的教程是写github 但是最新版的还是写git 所以写git就好了<br>配置好后,把博客deploy(部署)到github上<br>    $ hexo deploy<br>此时如果没有意外的话,部署将成功了,打开浏览器输入  <strong>&lt;用户名&gt;.github.io</strong>将可以查看你的blog了</p>\n<h3 id=\"9-常用Hexo命令\"><a href=\"#9-常用Hexo命令\" class=\"headerlink\" title=\"9.常用Hexo命令\"></a>9.常用Hexo命令</h3><pre><code>$ hexo c == hexo clean\n</code></pre><p>执行此项操作会删除public文件夹中的内容 (也就是我们写的那些md文件)</p>\n<pre><code>$ hexo g == hexo generate   // 将Blogs/source的.md文件生成道/public中，形成网站的静态文件\n$ hexo s == hexo server  //本地预览(此命令可以在你添加新文章后做预览用 看有没有生效~)\n$ hexo d == hexo deploy // 部署到你的站点上\n</code></pre>"},{"title":"JavaScript 继承 的学习笔记","date":"2016-07-25T17:20:46.000Z","_content":">我是结合慕课和JS高级程序设计这本书去学习继承这部分的内容的。在慕课《JavaScript 深入浅出》那一教程的OOP（Object Oriented Programming 面向对象程序设计）章节。\n## 原型链\n首先我们了解原型链。在ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。\n```javascript\nfunction foo() {\n}\nfoo.prototype.z = 3;\nvar obj = new foo();\nobj.x = 1;\nobj.y = 2;\n```\n![image](http://note.youdao.com/yws/res/342/WEBRESOURCE0ae9a61d44df15812fcf1ae06d7dc33b)\n---\n这边我们创建一个 foo构造函数，并创建了一个对象实例obj，对象obj的内部有一内部属性[[prototype]] （跟图中的[[proto]]是同一个东西） ，该属性是一个指针，因为是用new命令实例化对象，我们来回顾下new命令在使用时进行的操作.\n1. 创建一个新的对象\n2. 为这个新建对象进行[[prototype]]连接\n3. 将this值绑定到这个新建对象上\n4. 如果函数没有返回其他对象就返回这个对象\n\n\n执行new命令操作的第2步中，将对象obj的[[prototype]]属性，（它是一个指针） 指向到其对应的原型对象 foo.prototype\n\nfoo.prototype 这个原型对象其内部也有一个[[prototype]]属性，指向Object.prototype   \n我们可以用isPrototypeOf()方法来确定对象之间是否存在这种关系\n\n```javascript\nconsole.log(foo.prototype.isPrototypeOf(obj));               // true\nconsole.log(Object.prototype.isPrototypeOf(foo.prototype));  // true\n```\n我们用原型对象的isPrototypeOf（ ）方法测试了obj和foo.prototype，\n对象实例obj内部有一个指针指向foo.prototype 所以返回了true\n因为foo.prototype内部有一个指针指向Object.prototype 所以返回了true\n\nObject.prototype 指向null，这条原型链的尽头就是Object.prototype\n所以上图就是一个简单的完整的原型链~  明确了原型链是什么之后，我们就来了解如何利用原型链实现继承。\n\n---\n## 实现继承\n>继承的本质在于重写原型对象，往往通过重写构造函数的原型对象去实现继承\n### 实现继承的方法\n#### 利用原型链\n---\n```javascript\n//继承了Human  以下两种方式都可以实现继承\nPerson.prototype = new Human();  //新建一个Human的实例  ，并且Human的实例也指向了Human.prototype  。  所以Person.prototype也指向了Human.prototype\nPerson.prototype = Object.creat(Human.prototype);  //较为理想的方法，创建一个空对象，并且规定此新建对象指向的对象原型为Human.prototype\n```\n```javascript\nObject.create(proto, [ propertiesObject ]）  //语法\n```\n\nObject.create() 方法创建一个拥有指定原型和若干个指定属性的对象。\n**参数**\nproto ： 一个对象，作为新建对象的原型\npropertiesObject ： 可选。该参数对象是一组属性与值，\n举个例子\n```javascript\nfunction Human() {\n}\nHuman.prototype = {\n    constructor: Human,\n    a: 99,\n    b: 100\n}\nfunction Person() {\n    this.type = false;\n}\nPerson.prototype = new Human();   //Person 继承了Human\nPerson.prototype.getValue = function () {\n    return this.a;\n}\nvar person1 = new Person();\nvar person2 = new Person();\nconsole.log(person1.a);\nconsole.log(person2.getValue());\n//首先从person2本身需找此方法，找不到再从person2的原型Person.prototype查找getValue方法，\n//转而寻找Person.prototype所继承的Human原型对象，找到并引用。\n```\n\n利用原型链的确可以，但是我的上一篇笔记有说过，原型模式的问题是当构造函数含有引用类型值（如数组）的属性时，修改这种属性的值，所有实例共享属性，所有实例也会发生变化。这显然不是我们想要的\n\n\n\n\n\n","source":"_posts/inherit.md","raw":"---\ntitle: JavaScript 继承 的学习笔记\ndate: 2016-07-26 01:20:46\ntags: 继承\ncategory: JavaScript\n---\n>我是结合慕课和JS高级程序设计这本书去学习继承这部分的内容的。在慕课《JavaScript 深入浅出》那一教程的OOP（Object Oriented Programming 面向对象程序设计）章节。\n## 原型链\n首先我们了解原型链。在ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。\n```javascript\nfunction foo() {\n}\nfoo.prototype.z = 3;\nvar obj = new foo();\nobj.x = 1;\nobj.y = 2;\n```\n![image](http://note.youdao.com/yws/res/342/WEBRESOURCE0ae9a61d44df15812fcf1ae06d7dc33b)\n---\n这边我们创建一个 foo构造函数，并创建了一个对象实例obj，对象obj的内部有一内部属性[[prototype]] （跟图中的[[proto]]是同一个东西） ，该属性是一个指针，因为是用new命令实例化对象，我们来回顾下new命令在使用时进行的操作.\n1. 创建一个新的对象\n2. 为这个新建对象进行[[prototype]]连接\n3. 将this值绑定到这个新建对象上\n4. 如果函数没有返回其他对象就返回这个对象\n\n\n执行new命令操作的第2步中，将对象obj的[[prototype]]属性，（它是一个指针） 指向到其对应的原型对象 foo.prototype\n\nfoo.prototype 这个原型对象其内部也有一个[[prototype]]属性，指向Object.prototype   \n我们可以用isPrototypeOf()方法来确定对象之间是否存在这种关系\n\n```javascript\nconsole.log(foo.prototype.isPrototypeOf(obj));               // true\nconsole.log(Object.prototype.isPrototypeOf(foo.prototype));  // true\n```\n我们用原型对象的isPrototypeOf（ ）方法测试了obj和foo.prototype，\n对象实例obj内部有一个指针指向foo.prototype 所以返回了true\n因为foo.prototype内部有一个指针指向Object.prototype 所以返回了true\n\nObject.prototype 指向null，这条原型链的尽头就是Object.prototype\n所以上图就是一个简单的完整的原型链~  明确了原型链是什么之后，我们就来了解如何利用原型链实现继承。\n\n---\n## 实现继承\n>继承的本质在于重写原型对象，往往通过重写构造函数的原型对象去实现继承\n### 实现继承的方法\n#### 利用原型链\n---\n```javascript\n//继承了Human  以下两种方式都可以实现继承\nPerson.prototype = new Human();  //新建一个Human的实例  ，并且Human的实例也指向了Human.prototype  。  所以Person.prototype也指向了Human.prototype\nPerson.prototype = Object.creat(Human.prototype);  //较为理想的方法，创建一个空对象，并且规定此新建对象指向的对象原型为Human.prototype\n```\n```javascript\nObject.create(proto, [ propertiesObject ]）  //语法\n```\n\nObject.create() 方法创建一个拥有指定原型和若干个指定属性的对象。\n**参数**\nproto ： 一个对象，作为新建对象的原型\npropertiesObject ： 可选。该参数对象是一组属性与值，\n举个例子\n```javascript\nfunction Human() {\n}\nHuman.prototype = {\n    constructor: Human,\n    a: 99,\n    b: 100\n}\nfunction Person() {\n    this.type = false;\n}\nPerson.prototype = new Human();   //Person 继承了Human\nPerson.prototype.getValue = function () {\n    return this.a;\n}\nvar person1 = new Person();\nvar person2 = new Person();\nconsole.log(person1.a);\nconsole.log(person2.getValue());\n//首先从person2本身需找此方法，找不到再从person2的原型Person.prototype查找getValue方法，\n//转而寻找Person.prototype所继承的Human原型对象，找到并引用。\n```\n\n利用原型链的确可以，但是我的上一篇笔记有说过，原型模式的问题是当构造函数含有引用类型值（如数组）的属性时，修改这种属性的值，所有实例共享属性，所有实例也会发生变化。这显然不是我们想要的\n\n\n\n\n\n","slug":"inherit","published":1,"updated":"2016-07-25T17:22:50.688Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf81eh8o000zv4efccaxyhfe","content":"<blockquote>\n<p>我是结合慕课和JS高级程序设计这本书去学习继承这部分的内容的。在慕课《JavaScript 深入浅出》那一教程的OOP（Object Oriented Programming 面向对象程序设计）章节。</p>\n</blockquote>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>首先我们了解原型链。在ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo.prototype.z = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> foo();</span><br><span class=\"line\">obj.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">obj.y = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"http://note.youdao.com/yws/res/342/WEBRESOURCE0ae9a61d44df15812fcf1ae06d7dc33b\" alt=\"image\"></h2><p>这边我们创建一个 foo构造函数，并创建了一个对象实例obj，对象obj的内部有一内部属性[[prototype]] （跟图中的[[proto]]是同一个东西） ，该属性是一个指针，因为是用new命令实例化对象，我们来回顾下new命令在使用时进行的操作.</p>\n<ol>\n<li>创建一个新的对象</li>\n<li>为这个新建对象进行[[prototype]]连接</li>\n<li>将this值绑定到这个新建对象上</li>\n<li>如果函数没有返回其他对象就返回这个对象</li>\n</ol>\n<p>执行new命令操作的第2步中，将对象obj的[[prototype]]属性，（它是一个指针） 指向到其对应的原型对象 foo.prototype</p>\n<p>foo.prototype 这个原型对象其内部也有一个[[prototype]]属性，指向Object.prototype<br>我们可以用isPrototypeOf()方法来确定对象之间是否存在这种关系</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.prototype.isPrototypeOf(obj));               <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.prototype.isPrototypeOf(foo.prototype));  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>我们用原型对象的isPrototypeOf（ ）方法测试了obj和foo.prototype，<br>对象实例obj内部有一个指针指向foo.prototype 所以返回了true<br>因为foo.prototype内部有一个指针指向Object.prototype 所以返回了true</p>\n<p>Object.prototype 指向null，这条原型链的尽头就是Object.prototype<br>所以上图就是一个简单的完整的原型链~  明确了原型链是什么之后，我们就来了解如何利用原型链实现继承。</p>\n<hr>\n<h2 id=\"实现继承\"><a href=\"#实现继承\" class=\"headerlink\" title=\"实现继承\"></a>实现继承</h2><blockquote>\n<p>继承的本质在于重写原型对象，往往通过重写构造函数的原型对象去实现继承</p>\n</blockquote>\n<h3 id=\"实现继承的方法\"><a href=\"#实现继承的方法\" class=\"headerlink\" title=\"实现继承的方法\"></a>实现继承的方法</h3><h4 id=\"利用原型链\"><a href=\"#利用原型链\" class=\"headerlink\" title=\"利用原型链\"></a>利用原型链</h4><hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//继承了Human  以下两种方式都可以实现继承</span></span><br><span class=\"line\">Person.prototype = <span class=\"keyword\">new</span> Human();  <span class=\"comment\">//新建一个Human的实例  ，并且Human的实例也指向了Human.prototype  。  所以Person.prototype也指向了Human.prototype</span></span><br><span class=\"line\">Person.prototype = <span class=\"built_in\">Object</span>.creat(Human.prototype);  <span class=\"comment\">//较为理想的方法，创建一个空对象，并且规定此新建对象指向的对象原型为Human.prototype</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.create(proto, [ propertiesObject ]）  <span class=\"comment\">//语法</span></span><br></pre></td></tr></table></figure>\n<p>Object.create() 方法创建一个拥有指定原型和若干个指定属性的对象。<br><strong>参数</strong><br>proto ： 一个对象，作为新建对象的原型<br>propertiesObject ： 可选。该参数对象是一组属性与值，<br>举个例子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Human</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Human.prototype = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>: Human,</span><br><span class=\"line\">    a: 99,</span><br><span class=\"line\">    b: 100</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Person() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.type = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype = <span class=\"keyword\">new</span> Human();   <span class=\"comment\">//Person 继承了Human</span></span><br><span class=\"line\">Person.prototype.getValue = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.a);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person2.getValue());</span><br><span class=\"line\"><span class=\"comment\">//首先从person2本身需找此方法，找不到再从person2的原型Person.prototype查找getValue方法，</span></span><br><span class=\"line\"><span class=\"comment\">//转而寻找Person.prototype所继承的Human原型对象，找到并引用。</span></span><br></pre></td></tr></table></figure></p>\n<p>利用原型链的确可以，但是我的上一篇笔记有说过，原型模式的问题是当构造函数含有引用类型值（如数组）的属性时，修改这种属性的值，所有实例共享属性，所有实例也会发生变化。这显然不是我们想要的</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>我是结合慕课和JS高级程序设计这本书去学习继承这部分的内容的。在慕课《JavaScript 深入浅出》那一教程的OOP（Object Oriented Programming 面向对象程序设计）章节。</p>\n</blockquote>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>首先我们了解原型链。在ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo.prototype.z = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> foo();</span><br><span class=\"line\">obj.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">obj.y = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"http://note.youdao.com/yws/res/342/WEBRESOURCE0ae9a61d44df15812fcf1ae06d7dc33b\" alt=\"image\"></h2><p>这边我们创建一个 foo构造函数，并创建了一个对象实例obj，对象obj的内部有一内部属性[[prototype]] （跟图中的[[proto]]是同一个东西） ，该属性是一个指针，因为是用new命令实例化对象，我们来回顾下new命令在使用时进行的操作.</p>\n<ol>\n<li>创建一个新的对象</li>\n<li>为这个新建对象进行[[prototype]]连接</li>\n<li>将this值绑定到这个新建对象上</li>\n<li>如果函数没有返回其他对象就返回这个对象</li>\n</ol>\n<p>执行new命令操作的第2步中，将对象obj的[[prototype]]属性，（它是一个指针） 指向到其对应的原型对象 foo.prototype</p>\n<p>foo.prototype 这个原型对象其内部也有一个[[prototype]]属性，指向Object.prototype<br>我们可以用isPrototypeOf()方法来确定对象之间是否存在这种关系</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.prototype.isPrototypeOf(obj));               <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.prototype.isPrototypeOf(foo.prototype));  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>我们用原型对象的isPrototypeOf（ ）方法测试了obj和foo.prototype，<br>对象实例obj内部有一个指针指向foo.prototype 所以返回了true<br>因为foo.prototype内部有一个指针指向Object.prototype 所以返回了true</p>\n<p>Object.prototype 指向null，这条原型链的尽头就是Object.prototype<br>所以上图就是一个简单的完整的原型链~  明确了原型链是什么之后，我们就来了解如何利用原型链实现继承。</p>\n<hr>\n<h2 id=\"实现继承\"><a href=\"#实现继承\" class=\"headerlink\" title=\"实现继承\"></a>实现继承</h2><blockquote>\n<p>继承的本质在于重写原型对象，往往通过重写构造函数的原型对象去实现继承</p>\n</blockquote>\n<h3 id=\"实现继承的方法\"><a href=\"#实现继承的方法\" class=\"headerlink\" title=\"实现继承的方法\"></a>实现继承的方法</h3><h4 id=\"利用原型链\"><a href=\"#利用原型链\" class=\"headerlink\" title=\"利用原型链\"></a>利用原型链</h4><hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//继承了Human  以下两种方式都可以实现继承</span></span><br><span class=\"line\">Person.prototype = <span class=\"keyword\">new</span> Human();  <span class=\"comment\">//新建一个Human的实例  ，并且Human的实例也指向了Human.prototype  。  所以Person.prototype也指向了Human.prototype</span></span><br><span class=\"line\">Person.prototype = <span class=\"built_in\">Object</span>.creat(Human.prototype);  <span class=\"comment\">//较为理想的方法，创建一个空对象，并且规定此新建对象指向的对象原型为Human.prototype</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.create(proto, [ propertiesObject ]）  <span class=\"comment\">//语法</span></span><br></pre></td></tr></table></figure>\n<p>Object.create() 方法创建一个拥有指定原型和若干个指定属性的对象。<br><strong>参数</strong><br>proto ： 一个对象，作为新建对象的原型<br>propertiesObject ： 可选。该参数对象是一组属性与值，<br>举个例子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Human</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Human.prototype = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>: Human,</span><br><span class=\"line\">    a: 99,</span><br><span class=\"line\">    b: 100</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Person() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.type = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype = <span class=\"keyword\">new</span> Human();   <span class=\"comment\">//Person 继承了Human</span></span><br><span class=\"line\">Person.prototype.getValue = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.a);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person2.getValue());</span><br><span class=\"line\"><span class=\"comment\">//首先从person2本身需找此方法，找不到再从person2的原型Person.prototype查找getValue方法，</span></span><br><span class=\"line\"><span class=\"comment\">//转而寻找Person.prototype所继承的Human原型对象，找到并引用。</span></span><br></pre></td></tr></table></figure></p>\n<p>利用原型链的确可以，但是我的上一篇笔记有说过，原型模式的问题是当构造函数含有引用类型值（如数组）的属性时，修改这种属性的值，所有实例共享属性，所有实例也会发生变化。这显然不是我们想要的</p>\n"},{"title":"Process","tabs":["Node.js","process"],"date":"2017-07-30T13:00:00.000Z","_content":"\n\n\n最近在学gulp,接触到了Node.js的process对象,stream  \n\n所以就看了Node.js官方文档学习..做下笔记\n\n<!-- more -->\n\n把目前接触到的process的相关属性和方法整理下..\n\nProcess对象是一个global对象,提供有关信息,控制当前nodejs进程.它作为一个全局对象,对于nodejs应用程序始终是可用的,所以无需使用require().\n\n\n\n**Process对象是EventEmitter的实例,**\n在 NodeJS 中，使用 process 代表 NodeJS 应用程序\n\n## process Event\n\n### Event: 'exit'\n\n`exit`事件监听器\n\n```\nprocess.on('exit', (code) => {\n\tconsole.log(`code is ${code}`);\n})\n```\n\n`'exit'`事件监听器的回调函数只有一个入参, 这个参数可以使process.exitCode的属性值,或者是调用process.exit()方法传入的`code`值.    \n\n`'exit'`事件监听器的回调函数只允许包含同步操作.当`'exit'`事件被调用后,所有在event loop队列中排队的事件都会被强制丢弃,然后Node.js进程会马上结束.  \n\n```javascript\nprocess.on('exit', (code) => {\n\tsetTimeout(() => {\n    \tconsole.log('hello ,this will not run');\n\t}, 0)\n});\nconsole.log('wow');\nprocess.exit(1);\n\n// only printf \"wow\"\n```\n\n\n\n## process.argv\n`a.js`\n\n``` javascript\nprocess.argv.forEach((item, idx) => {\n    console.log(`${idx}: ${item}`);\n})\n```\n\n``` shell \nnode a.js a b c d\n\n0: /usr/local/bin/node\n1: /home/chenpengteng/gulpstudy/src/js/a.js\n2: a\n3: b\n4: c\n5: d\n\n```\n第一个元素是`process.execPath`属性,返回启动Node.js进程的可执行文件所在的绝对路径  \n第二个元素是 当前Node.js进程的当前工作目录 使用 `process.cwd()`方法也可以得到\n\n## process.stdin 标准输入流对象\n\nprocess.stdin 是一个stream.writable类对象\n\n## process.stdout 标准输出流对象\n``` javascript \nprocess.stdout.write('hello stdout\\n'); \n//在终端输出\nhello stdout\n\n```\n## process.env 环境变量\nprocess.env 属性返回一个包含用户环境信息的对象\n\n## process.exit([code]) & process.exitCode\n\n\n\ncode为结束状态码,默认为0.(success状态码.)\n\n显式使用process.exit()会强制进程尽快结束,即时还有在等待中的异步操作没有全部执行完成,如 process.stdout\n\n尽量不要显式调用process.exit. 当Node.js的事件轮询队列没有在等待中的工作,Node.js进程会自行结束.  \n\nprocess.exitCode是进程结束的状态码.   \n\n当进程正常结束或者通过process.exit()方法结束进程而没有传参时,process.exitCode代表进程结束的状态码.  \n\n当使用process.exit()结束进程,并指定了一个状态码,则会覆盖process.exitCode的原有值.","source":"_posts/process.md","raw":"---\n\ntitle: Process\n\ncategory: Node.js\n\ntabs: [Node.js, process]\n\ndate: 2017-07-30 21:00\n\n---\n\n\n\n最近在学gulp,接触到了Node.js的process对象,stream  \n\n所以就看了Node.js官方文档学习..做下笔记\n\n<!-- more -->\n\n把目前接触到的process的相关属性和方法整理下..\n\nProcess对象是一个global对象,提供有关信息,控制当前nodejs进程.它作为一个全局对象,对于nodejs应用程序始终是可用的,所以无需使用require().\n\n\n\n**Process对象是EventEmitter的实例,**\n在 NodeJS 中，使用 process 代表 NodeJS 应用程序\n\n## process Event\n\n### Event: 'exit'\n\n`exit`事件监听器\n\n```\nprocess.on('exit', (code) => {\n\tconsole.log(`code is ${code}`);\n})\n```\n\n`'exit'`事件监听器的回调函数只有一个入参, 这个参数可以使process.exitCode的属性值,或者是调用process.exit()方法传入的`code`值.    \n\n`'exit'`事件监听器的回调函数只允许包含同步操作.当`'exit'`事件被调用后,所有在event loop队列中排队的事件都会被强制丢弃,然后Node.js进程会马上结束.  \n\n```javascript\nprocess.on('exit', (code) => {\n\tsetTimeout(() => {\n    \tconsole.log('hello ,this will not run');\n\t}, 0)\n});\nconsole.log('wow');\nprocess.exit(1);\n\n// only printf \"wow\"\n```\n\n\n\n## process.argv\n`a.js`\n\n``` javascript\nprocess.argv.forEach((item, idx) => {\n    console.log(`${idx}: ${item}`);\n})\n```\n\n``` shell \nnode a.js a b c d\n\n0: /usr/local/bin/node\n1: /home/chenpengteng/gulpstudy/src/js/a.js\n2: a\n3: b\n4: c\n5: d\n\n```\n第一个元素是`process.execPath`属性,返回启动Node.js进程的可执行文件所在的绝对路径  \n第二个元素是 当前Node.js进程的当前工作目录 使用 `process.cwd()`方法也可以得到\n\n## process.stdin 标准输入流对象\n\nprocess.stdin 是一个stream.writable类对象\n\n## process.stdout 标准输出流对象\n``` javascript \nprocess.stdout.write('hello stdout\\n'); \n//在终端输出\nhello stdout\n\n```\n## process.env 环境变量\nprocess.env 属性返回一个包含用户环境信息的对象\n\n## process.exit([code]) & process.exitCode\n\n\n\ncode为结束状态码,默认为0.(success状态码.)\n\n显式使用process.exit()会强制进程尽快结束,即时还有在等待中的异步操作没有全部执行完成,如 process.stdout\n\n尽量不要显式调用process.exit. 当Node.js的事件轮询队列没有在等待中的工作,Node.js进程会自行结束.  \n\nprocess.exitCode是进程结束的状态码.   \n\n当进程正常结束或者通过process.exit()方法结束进程而没有传参时,process.exitCode代表进程结束的状态码.  \n\n当使用process.exit()结束进程,并指定了一个状态码,则会覆盖process.exitCode的原有值.","slug":"process","published":1,"updated":"2017-07-30T13:21:21.659Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf81eh8r0012v4efkj7wy9u7","content":"<p>最近在学gulp,接触到了Node.js的process对象,stream  </p>\n<p>所以就看了Node.js官方文档学习..做下笔记</p>\n<a id=\"more\"></a>\n<p>把目前接触到的process的相关属性和方法整理下..</p>\n<p>Process对象是一个global对象,提供有关信息,控制当前nodejs进程.它作为一个全局对象,对于nodejs应用程序始终是可用的,所以无需使用require().</p>\n<p><strong>Process对象是EventEmitter的实例,</strong><br>在 NodeJS 中，使用 process 代表 NodeJS 应用程序</p>\n<h2 id=\"process-Event\"><a href=\"#process-Event\" class=\"headerlink\" title=\"process Event\"></a>process Event</h2><h3 id=\"Event-‘exit’\"><a href=\"#Event-‘exit’\" class=\"headerlink\" title=\"Event: ‘exit’\"></a>Event: ‘exit’</h3><p><code>exit</code>事件监听器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.on(&apos;exit&apos;, (code) =&gt; &#123;</span><br><span class=\"line\">\tconsole.log(`code is $&#123;code&#125;`);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><code>&#39;exit&#39;</code>事件监听器的回调函数只有一个入参, 这个参数可以使process.exitCode的属性值,或者是调用process.exit()方法传入的<code>code</code>值.    </p>\n<p><code>&#39;exit&#39;</code>事件监听器的回调函数只允许包含同步操作.当<code>&#39;exit&#39;</code>事件被调用后,所有在event loop队列中排队的事件都会被强制丢弃,然后Node.js进程会马上结束.  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.on(<span class=\"string\">'exit'</span>, (code) =&gt; &#123;</span><br><span class=\"line\">\tsetTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'hello ,this will not run'</span>);</span><br><span class=\"line\">\t&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'wow'</span>);</span><br><span class=\"line\">process.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// only printf \"wow\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"process-argv\"><a href=\"#process-argv\" class=\"headerlink\" title=\"process.argv\"></a>process.argv</h2><p><code>a.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.argv.forEach(<span class=\"function\">(<span class=\"params\">item, idx</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;idx&#125;</span>: <span class=\"subst\">$&#123;item&#125;</span>`</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node a.js a b c d</span><br><span class=\"line\"></span><br><span class=\"line\">0: /usr/local/bin/node</span><br><span class=\"line\">1: /home/chenpengteng/gulpstudy/src/js/a.js</span><br><span class=\"line\">2: a</span><br><span class=\"line\">3: b</span><br><span class=\"line\">4: c</span><br><span class=\"line\">5: d</span><br></pre></td></tr></table></figure>\n<p>第一个元素是<code>process.execPath</code>属性,返回启动Node.js进程的可执行文件所在的绝对路径<br>第二个元素是 当前Node.js进程的当前工作目录 使用 <code>process.cwd()</code>方法也可以得到</p>\n<h2 id=\"process-stdin-标准输入流对象\"><a href=\"#process-stdin-标准输入流对象\" class=\"headerlink\" title=\"process.stdin 标准输入流对象\"></a>process.stdin 标准输入流对象</h2><p>process.stdin 是一个stream.writable类对象</p>\n<h2 id=\"process-stdout-标准输出流对象\"><a href=\"#process-stdout-标准输出流对象\" class=\"headerlink\" title=\"process.stdout 标准输出流对象\"></a>process.stdout 标准输出流对象</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.stdout.write(<span class=\"string\">'hello stdout\\n'</span>); </span><br><span class=\"line\"><span class=\"comment\">//在终端输出</span></span><br><span class=\"line\">hello stdout</span><br></pre></td></tr></table></figure>\n<h2 id=\"process-env-环境变量\"><a href=\"#process-env-环境变量\" class=\"headerlink\" title=\"process.env 环境变量\"></a>process.env 环境变量</h2><p>process.env 属性返回一个包含用户环境信息的对象</p>\n<h2 id=\"process-exit-code-amp-process-exitCode\"><a href=\"#process-exit-code-amp-process-exitCode\" class=\"headerlink\" title=\"process.exit([code]) &amp; process.exitCode\"></a>process.exit([code]) &amp; process.exitCode</h2><p>code为结束状态码,默认为0.(success状态码.)</p>\n<p>显式使用process.exit()会强制进程尽快结束,即时还有在等待中的异步操作没有全部执行完成,如 process.stdout</p>\n<p>尽量不要显式调用process.exit. 当Node.js的事件轮询队列没有在等待中的工作,Node.js进程会自行结束.  </p>\n<p>process.exitCode是进程结束的状态码.   </p>\n<p>当进程正常结束或者通过process.exit()方法结束进程而没有传参时,process.exitCode代表进程结束的状态码.  </p>\n<p>当使用process.exit()结束进程,并指定了一个状态码,则会覆盖process.exitCode的原有值.</p>\n","site":{"data":{}},"excerpt":"<p>最近在学gulp,接触到了Node.js的process对象,stream  </p>\n<p>所以就看了Node.js官方文档学习..做下笔记</p>","more":"<p>把目前接触到的process的相关属性和方法整理下..</p>\n<p>Process对象是一个global对象,提供有关信息,控制当前nodejs进程.它作为一个全局对象,对于nodejs应用程序始终是可用的,所以无需使用require().</p>\n<p><strong>Process对象是EventEmitter的实例,</strong><br>在 NodeJS 中，使用 process 代表 NodeJS 应用程序</p>\n<h2 id=\"process-Event\"><a href=\"#process-Event\" class=\"headerlink\" title=\"process Event\"></a>process Event</h2><h3 id=\"Event-‘exit’\"><a href=\"#Event-‘exit’\" class=\"headerlink\" title=\"Event: ‘exit’\"></a>Event: ‘exit’</h3><p><code>exit</code>事件监听器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.on(&apos;exit&apos;, (code) =&gt; &#123;</span><br><span class=\"line\">\tconsole.log(`code is $&#123;code&#125;`);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><code>&#39;exit&#39;</code>事件监听器的回调函数只有一个入参, 这个参数可以使process.exitCode的属性值,或者是调用process.exit()方法传入的<code>code</code>值.    </p>\n<p><code>&#39;exit&#39;</code>事件监听器的回调函数只允许包含同步操作.当<code>&#39;exit&#39;</code>事件被调用后,所有在event loop队列中排队的事件都会被强制丢弃,然后Node.js进程会马上结束.  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.on(<span class=\"string\">'exit'</span>, (code) =&gt; &#123;</span><br><span class=\"line\">\tsetTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'hello ,this will not run'</span>);</span><br><span class=\"line\">\t&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'wow'</span>);</span><br><span class=\"line\">process.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// only printf \"wow\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"process-argv\"><a href=\"#process-argv\" class=\"headerlink\" title=\"process.argv\"></a>process.argv</h2><p><code>a.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.argv.forEach(<span class=\"function\">(<span class=\"params\">item, idx</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;idx&#125;</span>: <span class=\"subst\">$&#123;item&#125;</span>`</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node a.js a b c d</span><br><span class=\"line\"></span><br><span class=\"line\">0: /usr/local/bin/node</span><br><span class=\"line\">1: /home/chenpengteng/gulpstudy/src/js/a.js</span><br><span class=\"line\">2: a</span><br><span class=\"line\">3: b</span><br><span class=\"line\">4: c</span><br><span class=\"line\">5: d</span><br></pre></td></tr></table></figure>\n<p>第一个元素是<code>process.execPath</code>属性,返回启动Node.js进程的可执行文件所在的绝对路径<br>第二个元素是 当前Node.js进程的当前工作目录 使用 <code>process.cwd()</code>方法也可以得到</p>\n<h2 id=\"process-stdin-标准输入流对象\"><a href=\"#process-stdin-标准输入流对象\" class=\"headerlink\" title=\"process.stdin 标准输入流对象\"></a>process.stdin 标准输入流对象</h2><p>process.stdin 是一个stream.writable类对象</p>\n<h2 id=\"process-stdout-标准输出流对象\"><a href=\"#process-stdout-标准输出流对象\" class=\"headerlink\" title=\"process.stdout 标准输出流对象\"></a>process.stdout 标准输出流对象</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.stdout.write(<span class=\"string\">'hello stdout\\n'</span>); </span><br><span class=\"line\"><span class=\"comment\">//在终端输出</span></span><br><span class=\"line\">hello stdout</span><br></pre></td></tr></table></figure>\n<h2 id=\"process-env-环境变量\"><a href=\"#process-env-环境变量\" class=\"headerlink\" title=\"process.env 环境变量\"></a>process.env 环境变量</h2><p>process.env 属性返回一个包含用户环境信息的对象</p>\n<h2 id=\"process-exit-code-amp-process-exitCode\"><a href=\"#process-exit-code-amp-process-exitCode\" class=\"headerlink\" title=\"process.exit([code]) &amp; process.exitCode\"></a>process.exit([code]) &amp; process.exitCode</h2><p>code为结束状态码,默认为0.(success状态码.)</p>\n<p>显式使用process.exit()会强制进程尽快结束,即时还有在等待中的异步操作没有全部执行完成,如 process.stdout</p>\n<p>尽量不要显式调用process.exit. 当Node.js的事件轮询队列没有在等待中的工作,Node.js进程会自行结束.  </p>\n<p>process.exitCode是进程结束的状态码.   </p>\n<p>当进程正常结束或者通过process.exit()方法结束进程而没有传参时,process.exitCode代表进程结束的状态码.  </p>\n<p>当使用process.exit()结束进程,并指定了一个状态码,则会覆盖process.exitCode的原有值.</p>"},{"title":"JavaScript内置对象","date":"2017-07-17T16:00:00.000Z","_content":"## JavaScript内置对象\n\n第二周周一...JavaScript内置对象\n\n<!-- more -->\n\n\n### Glboal对象 (全局对象)\n它是一个特殊的对象,实际上,所有在全局作用域中定义的属性和函数,都是全局对象的属性和方法.  \n在JavaScript中,全局对象就是window对象.\n全局对象的方法:  \n\n+ encodeURI() //对字符串进行编码形成可用的URI(通用资源标识符)\n+ encodeURIComponent()  //将字符串编码为URI组件,与encodeURI的区别就是它的参数是URI的一部分(比如协议\\主机名\\路径\\查询字符串) 它也会把不属于URI的特殊字符进行编码(如冒号,正斜杆,问号,#号),而encodeURI()不会.\n+ decodeURI()\n+ decodeURIComponent()\n+ escape()  //将字符串进行编码\n+ eval() //计算Js字符串,并把它作为脚本代码来执行\n+ isFinite()  //判断某个值是否为有穷数\n+ isNaN()      //is not a number  判断检查参数是否为非数字值.\n+ Number()      //将对象的值转化为函数,如果无法转换则返回NaN\n+ parseInt()    //将字符串转换为整数\n+ parseFloat()  //将字符串转换为浮点数\n+ String()      //将对象的值转化为字符串\n+ unescape()    //将escape()编的码转化为字符串\n\n\n\n+ NaN       // Not-A-Number\n+ Infinity   //全局属性,表示无穷\n\n## 引用类型\n在ECMAScript中,引用类型是一种数据结构,用于将数据和功能组织在一起.引用类型有时候也被称为**对象定义**,因为它们描述的是一类对象所具有的属性和方法.  \n\n**对象是某个特定引用类型的实例**,新对象是使用new操作符加一个构造函数生成的.\n\n``` javascript \nvar person = new Object(); \n```\n\n这行代码创建一个 Object()类型的新实例, 保存到person变量中.  \n构造函数Object为新对象定义了默认的属性和方法.\n### Object 类型\n#### 创建Object类型\n\n创建Object类型有两种方法  \n1.使用new操作符\n``` javascript\nvar person = new Object();\n```\n2.对象字面量法\n``` javascript \nvar apple = {\n    price: 100,\n    color: 'red',\n    from: 'GuangZhou',\n    isFruit: true,\n    to where: 'BeiJing'\n}; \n```\n\n#### 访问对象属性\n``` javascript\napple.price;  //100\napple[\"price\"]; //100  \n\nvar fruitColor = \"color\";  // 使用方括号语法可以通过变量来访问对象属性\n\napple[fruitColor]; // 'red'\n\n//to where 含有空格,不能使用\".\"来访问,只能用方括号语法.  \n\napple[\"to where\"]; // \"BeiJing\"\n```\n\n### Array 类型\n#### 创建数组类型\n**ECMAScript数组的每一项可以保存任何类型的数据**  \n1.采用Array构造函数\n``` javascript\nvar array = new Array();\n// var array = Array();\narray[0] = 1;\narray[1] = 2;\n// array = [1, 2];\n```\n2.数组字面量法\n``` javascript\nvar a = [1, 2, 3, 5, 'Fuck'];\n```\n数组的length属性不是只读的,通过改变length属性的值可以从数组的末尾删除元素或者添加新元素.\n``` javascript\nvar a = [1, 2, 3];\na.length = 2;\nconsole.log(a); // [1, 2]\na.length = 3;\nconsole.log(a[2]);  //undefined\na[a.length] = 4;\nconsole.log(a) // [1, 2, undefined, 4];\n```\n#### 讲几个Array的方法\n##### slice & splice\n``` javascript\n//Array.prototype.slice(beginIndex, endIndex); 不包括结束\n\nvar a = [1, 2, 3, 4];\na.slice(0,2);  // [1, 2]  把序号为0, 1 的值取出来,原数组不变\nconsole.log(a)  // [1, 2, 3, 4];\n\n//Array.prototype.splice(start, deleteCount)\n//Array.prototype.splice(start, deleteCount,item1,....);\na.splice(2, 1);  // [3]\nconsole.log(a); // [1, 2, 4]\n\na.splice(3, 0, 5); // [1, 2, 4, 5]  deleteCount为0表示不删除元素,即添加元素\n```\n##### pop & push & shift & unshift\n``` javascript\nvar a = [1, 2, 3, 4];\na.push(5, 6)  // 返回a.length  == 6\nconsole.log(a); // [1, 2, 3, 4, 5, 6];\n\na.pop(); // 数组的最后一项 6\nconsole.log(a) // [1, 2, 3, 4, 5];\n\na.shift(); // 数组的第一项 1\nconsole.log(a); [2, 3, 4, 5]\n\na.unshift(0, 1);  //返回a.length == 10\nconsole.log(a); //[0, 1, 2, 3, 4, 5];\n```\npop() & push() 可实现堆栈(LIFO).  \nshift() & push() 可实现队列(FIFO).  \n这四个方法都会改变数组的长度.\n\n##### reduce() & map() & filter\nreduce() 方法对累加器和数组中的每个元素 (从左到右)应用一个函数，将其减少为**单个值**。**不会改变原数组**  \n\n>array.reduce(function(accumulator, currentValue, currentIndex, array), initialValue)\n\n\n``` javascript\nvar a = [1, 2, 3, 4, 5];\n\na.reduce((x, y,idx, its) => {\n    return x + y;\n}, 0)   // 15\n```\n``` javascript\n# map \nvar a = [1, 2, 3, 4, 5];\n\na.map((item, idx, array) => {\n    return item * 2;\n})   // [2, 4, 6, 8, 10];\n\n```\n\n```javascript\nvar a = [3, 4, 5, 6, 7, 8, 10]\n\nfunction islessThan(value) {\n    return  value < 4;\n}\n\na.filter(islessThan) \n\n\n\n```\n\n\n\n### Date 类型 \n```\nvar date = new Date();\nconsole.log(date); //Mon Jul 17 2017 16:20:03 GMT+0800 (CST)\ndate.getFullYear(); //2017\n```\n\n### Function 类型 \nhttp://chenpt.cc/2017/07/13/Js-Function/\n### 基本包装类型(String,Number,Boolean)\n\n#### String\n\n1.  type1:\"wow\"\n2.  type2:\\`hello world\\`  \n\n\n\n``` javascript\nvar str1 = \"wow\"  + \" fuck\";    // \"wow fuck\"\n```\n\n\n### RegExp 构造函数创建了一个正则表达式对象RegExp\nRegExp 构造函数创建了一个正则表达式对象  \n三种方法: 字面量, 构造函数, 工厂符号\n```javascript\n/pattern/flags\nnew RegExp(pattern [, flags])\nRegExp(pattern, [,flags]);\n\n//pattern 正则表达式的文本\n// flags \n// g: 找到所有匹配,而不是在第一个匹配后停止\n```\n\n``` javascript\nvar pattern = /*.com/g\nvar testStr = 'sdsdsdsada.com';\npattern.exec(testStr)\n```\n\n\n\n\n\n\n\n","source":"_posts/second-Monday.md","raw":"---\ntitle: JavaScript内置对象\ntag: [JavaScript, Object]\ndate: 2017-07-18\ncategory: JavaScript\n---\n## JavaScript内置对象\n\n第二周周一...JavaScript内置对象\n\n<!-- more -->\n\n\n### Glboal对象 (全局对象)\n它是一个特殊的对象,实际上,所有在全局作用域中定义的属性和函数,都是全局对象的属性和方法.  \n在JavaScript中,全局对象就是window对象.\n全局对象的方法:  \n\n+ encodeURI() //对字符串进行编码形成可用的URI(通用资源标识符)\n+ encodeURIComponent()  //将字符串编码为URI组件,与encodeURI的区别就是它的参数是URI的一部分(比如协议\\主机名\\路径\\查询字符串) 它也会把不属于URI的特殊字符进行编码(如冒号,正斜杆,问号,#号),而encodeURI()不会.\n+ decodeURI()\n+ decodeURIComponent()\n+ escape()  //将字符串进行编码\n+ eval() //计算Js字符串,并把它作为脚本代码来执行\n+ isFinite()  //判断某个值是否为有穷数\n+ isNaN()      //is not a number  判断检查参数是否为非数字值.\n+ Number()      //将对象的值转化为函数,如果无法转换则返回NaN\n+ parseInt()    //将字符串转换为整数\n+ parseFloat()  //将字符串转换为浮点数\n+ String()      //将对象的值转化为字符串\n+ unescape()    //将escape()编的码转化为字符串\n\n\n\n+ NaN       // Not-A-Number\n+ Infinity   //全局属性,表示无穷\n\n## 引用类型\n在ECMAScript中,引用类型是一种数据结构,用于将数据和功能组织在一起.引用类型有时候也被称为**对象定义**,因为它们描述的是一类对象所具有的属性和方法.  \n\n**对象是某个特定引用类型的实例**,新对象是使用new操作符加一个构造函数生成的.\n\n``` javascript \nvar person = new Object(); \n```\n\n这行代码创建一个 Object()类型的新实例, 保存到person变量中.  \n构造函数Object为新对象定义了默认的属性和方法.\n### Object 类型\n#### 创建Object类型\n\n创建Object类型有两种方法  \n1.使用new操作符\n``` javascript\nvar person = new Object();\n```\n2.对象字面量法\n``` javascript \nvar apple = {\n    price: 100,\n    color: 'red',\n    from: 'GuangZhou',\n    isFruit: true,\n    to where: 'BeiJing'\n}; \n```\n\n#### 访问对象属性\n``` javascript\napple.price;  //100\napple[\"price\"]; //100  \n\nvar fruitColor = \"color\";  // 使用方括号语法可以通过变量来访问对象属性\n\napple[fruitColor]; // 'red'\n\n//to where 含有空格,不能使用\".\"来访问,只能用方括号语法.  \n\napple[\"to where\"]; // \"BeiJing\"\n```\n\n### Array 类型\n#### 创建数组类型\n**ECMAScript数组的每一项可以保存任何类型的数据**  \n1.采用Array构造函数\n``` javascript\nvar array = new Array();\n// var array = Array();\narray[0] = 1;\narray[1] = 2;\n// array = [1, 2];\n```\n2.数组字面量法\n``` javascript\nvar a = [1, 2, 3, 5, 'Fuck'];\n```\n数组的length属性不是只读的,通过改变length属性的值可以从数组的末尾删除元素或者添加新元素.\n``` javascript\nvar a = [1, 2, 3];\na.length = 2;\nconsole.log(a); // [1, 2]\na.length = 3;\nconsole.log(a[2]);  //undefined\na[a.length] = 4;\nconsole.log(a) // [1, 2, undefined, 4];\n```\n#### 讲几个Array的方法\n##### slice & splice\n``` javascript\n//Array.prototype.slice(beginIndex, endIndex); 不包括结束\n\nvar a = [1, 2, 3, 4];\na.slice(0,2);  // [1, 2]  把序号为0, 1 的值取出来,原数组不变\nconsole.log(a)  // [1, 2, 3, 4];\n\n//Array.prototype.splice(start, deleteCount)\n//Array.prototype.splice(start, deleteCount,item1,....);\na.splice(2, 1);  // [3]\nconsole.log(a); // [1, 2, 4]\n\na.splice(3, 0, 5); // [1, 2, 4, 5]  deleteCount为0表示不删除元素,即添加元素\n```\n##### pop & push & shift & unshift\n``` javascript\nvar a = [1, 2, 3, 4];\na.push(5, 6)  // 返回a.length  == 6\nconsole.log(a); // [1, 2, 3, 4, 5, 6];\n\na.pop(); // 数组的最后一项 6\nconsole.log(a) // [1, 2, 3, 4, 5];\n\na.shift(); // 数组的第一项 1\nconsole.log(a); [2, 3, 4, 5]\n\na.unshift(0, 1);  //返回a.length == 10\nconsole.log(a); //[0, 1, 2, 3, 4, 5];\n```\npop() & push() 可实现堆栈(LIFO).  \nshift() & push() 可实现队列(FIFO).  \n这四个方法都会改变数组的长度.\n\n##### reduce() & map() & filter\nreduce() 方法对累加器和数组中的每个元素 (从左到右)应用一个函数，将其减少为**单个值**。**不会改变原数组**  \n\n>array.reduce(function(accumulator, currentValue, currentIndex, array), initialValue)\n\n\n``` javascript\nvar a = [1, 2, 3, 4, 5];\n\na.reduce((x, y,idx, its) => {\n    return x + y;\n}, 0)   // 15\n```\n``` javascript\n# map \nvar a = [1, 2, 3, 4, 5];\n\na.map((item, idx, array) => {\n    return item * 2;\n})   // [2, 4, 6, 8, 10];\n\n```\n\n```javascript\nvar a = [3, 4, 5, 6, 7, 8, 10]\n\nfunction islessThan(value) {\n    return  value < 4;\n}\n\na.filter(islessThan) \n\n\n\n```\n\n\n\n### Date 类型 \n```\nvar date = new Date();\nconsole.log(date); //Mon Jul 17 2017 16:20:03 GMT+0800 (CST)\ndate.getFullYear(); //2017\n```\n\n### Function 类型 \nhttp://chenpt.cc/2017/07/13/Js-Function/\n### 基本包装类型(String,Number,Boolean)\n\n#### String\n\n1.  type1:\"wow\"\n2.  type2:\\`hello world\\`  \n\n\n\n``` javascript\nvar str1 = \"wow\"  + \" fuck\";    // \"wow fuck\"\n```\n\n\n### RegExp 构造函数创建了一个正则表达式对象RegExp\nRegExp 构造函数创建了一个正则表达式对象  \n三种方法: 字面量, 构造函数, 工厂符号\n```javascript\n/pattern/flags\nnew RegExp(pattern [, flags])\nRegExp(pattern, [,flags]);\n\n//pattern 正则表达式的文本\n// flags \n// g: 找到所有匹配,而不是在第一个匹配后停止\n```\n\n``` javascript\nvar pattern = /*.com/g\nvar testStr = 'sdsdsdsada.com';\npattern.exec(testStr)\n```\n\n\n\n\n\n\n\n","slug":"second-Monday","published":1,"updated":"2017-07-18T04:22:18.761Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf81eh8w0016v4efqzb7tvmj","content":"<h2 id=\"JavaScript内置对象\"><a href=\"#JavaScript内置对象\" class=\"headerlink\" title=\"JavaScript内置对象\"></a>JavaScript内置对象</h2><p>第二周周一…JavaScript内置对象</p>\n<a id=\"more\"></a>\n<h3 id=\"Glboal对象-全局对象\"><a href=\"#Glboal对象-全局对象\" class=\"headerlink\" title=\"Glboal对象 (全局对象)\"></a>Glboal对象 (全局对象)</h3><p>它是一个特殊的对象,实际上,所有在全局作用域中定义的属性和函数,都是全局对象的属性和方法.<br>在JavaScript中,全局对象就是window对象.<br>全局对象的方法:  </p>\n<ul>\n<li>encodeURI() //对字符串进行编码形成可用的URI(通用资源标识符)</li>\n<li>encodeURIComponent()  //将字符串编码为URI组件,与encodeURI的区别就是它的参数是URI的一部分(比如协议\\主机名\\路径\\查询字符串) 它也会把不属于URI的特殊字符进行编码(如冒号,正斜杆,问号,#号),而encodeURI()不会.</li>\n<li>decodeURI()</li>\n<li>decodeURIComponent()</li>\n<li>escape()  //将字符串进行编码</li>\n<li>eval() //计算Js字符串,并把它作为脚本代码来执行</li>\n<li>isFinite()  //判断某个值是否为有穷数</li>\n<li>isNaN()      //is not a number  判断检查参数是否为非数字值.</li>\n<li>Number()      //将对象的值转化为函数,如果无法转换则返回NaN</li>\n<li>parseInt()    //将字符串转换为整数</li>\n<li>parseFloat()  //将字符串转换为浮点数</li>\n<li>String()      //将对象的值转化为字符串</li>\n<li>unescape()    //将escape()编的码转化为字符串</li>\n</ul>\n<ul>\n<li>NaN       // Not-A-Number</li>\n<li>Infinity   //全局属性,表示无穷</li>\n</ul>\n<h2 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h2><p>在ECMAScript中,引用类型是一种数据结构,用于将数据和功能组织在一起.引用类型有时候也被称为<strong>对象定义</strong>,因为它们描述的是一类对象所具有的属性和方法.  </p>\n<p><strong>对象是某个特定引用类型的实例</strong>,新对象是使用new操作符加一个构造函数生成的.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br></pre></td></tr></table></figure>\n<p>这行代码创建一个 Object()类型的新实例, 保存到person变量中.<br>构造函数Object为新对象定义了默认的属性和方法.</p>\n<h3 id=\"Object-类型\"><a href=\"#Object-类型\" class=\"headerlink\" title=\"Object 类型\"></a>Object 类型</h3><h4 id=\"创建Object类型\"><a href=\"#创建Object类型\" class=\"headerlink\" title=\"创建Object类型\"></a>创建Object类型</h4><p>创建Object类型有两种方法<br>1.使用new操作符<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br></pre></td></tr></table></figure></p>\n<p>2.对象字面量法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> apple = &#123;</span><br><span class=\"line\">    price: <span class=\"number\">100</span>,</span><br><span class=\"line\">    color: <span class=\"string\">'red'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">from</span>: <span class=\"string\">'GuangZhou'</span>,</span><br><span class=\"line\">    isFruit: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    to where: <span class=\"string\">'BeiJing'</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"访问对象属性\"><a href=\"#访问对象属性\" class=\"headerlink\" title=\"访问对象属性\"></a>访问对象属性</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apple.price;  <span class=\"comment\">//100</span></span><br><span class=\"line\">apple[<span class=\"string\">\"price\"</span>]; <span class=\"comment\">//100  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fruitColor = <span class=\"string\">\"color\"</span>;  <span class=\"comment\">// 使用方括号语法可以通过变量来访问对象属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">apple[fruitColor]; <span class=\"comment\">// 'red'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//to where 含有空格,不能使用\".\"来访问,只能用方括号语法.  </span></span><br><span class=\"line\"></span><br><span class=\"line\">apple[<span class=\"string\">\"to where\"</span>]; <span class=\"comment\">// \"BeiJing\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Array-类型\"><a href=\"#Array-类型\" class=\"headerlink\" title=\"Array 类型\"></a>Array 类型</h3><h4 id=\"创建数组类型\"><a href=\"#创建数组类型\" class=\"headerlink\" title=\"创建数组类型\"></a>创建数组类型</h4><p><strong>ECMAScript数组的每一项可以保存任何类型的数据</strong><br>1.采用Array构造函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\"><span class=\"comment\">// var array = Array();</span></span><br><span class=\"line\">array[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">array[<span class=\"number\">1</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">// array = [1, 2];</span></span><br></pre></td></tr></table></figure></p>\n<p>2.数组字面量法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"string\">'Fuck'</span>];</span><br></pre></td></tr></table></figure></p>\n<p>数组的length属性不是只读的,通过改变length属性的值可以从数组的末尾删除元素或者添加新元素.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">a.length = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// [1, 2]</span></span><br><span class=\"line\">a.length = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a[<span class=\"number\">2</span>]);  <span class=\"comment\">//undefined</span></span><br><span class=\"line\">a[a.length] = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// [1, 2, undefined, 4];</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"讲几个Array的方法\"><a href=\"#讲几个Array的方法\" class=\"headerlink\" title=\"讲几个Array的方法\"></a>讲几个Array的方法</h4><h5 id=\"slice-amp-splice\"><a href=\"#slice-amp-splice\" class=\"headerlink\" title=\"slice &amp; splice\"></a>slice &amp; splice</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Array.prototype.slice(beginIndex, endIndex); 不包括结束</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\">a.slice(<span class=\"number\">0</span>,<span class=\"number\">2</span>);  <span class=\"comment\">// [1, 2]  把序号为0, 1 的值取出来,原数组不变</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a)  <span class=\"comment\">// [1, 2, 3, 4];</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Array.prototype.splice(start, deleteCount)</span></span><br><span class=\"line\"><span class=\"comment\">//Array.prototype.splice(start, deleteCount,item1,....);</span></span><br><span class=\"line\">a.splice(<span class=\"number\">2</span>, <span class=\"number\">1</span>);  <span class=\"comment\">// [3]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// [1, 2, 4]</span></span><br><span class=\"line\"></span><br><span class=\"line\">a.splice(<span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span>); <span class=\"comment\">// [1, 2, 4, 5]  deleteCount为0表示不删除元素,即添加元素</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"pop-amp-push-amp-shift-amp-unshift\"><a href=\"#pop-amp-push-amp-shift-amp-unshift\" class=\"headerlink\" title=\"pop &amp; push &amp; shift &amp; unshift\"></a>pop &amp; push &amp; shift &amp; unshift</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\">a.push(<span class=\"number\">5</span>, <span class=\"number\">6</span>)  <span class=\"comment\">// 返回a.length  == 6</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// [1, 2, 3, 4, 5, 6];</span></span><br><span class=\"line\"></span><br><span class=\"line\">a.pop(); <span class=\"comment\">// 数组的最后一项 6</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// [1, 2, 3, 4, 5];</span></span><br><span class=\"line\"></span><br><span class=\"line\">a.shift(); <span class=\"comment\">// 数组的第一项 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">a.unshift(<span class=\"number\">0</span>, <span class=\"number\">1</span>);  <span class=\"comment\">//返回a.length == 10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//[0, 1, 2, 3, 4, 5];</span></span><br></pre></td></tr></table></figure>\n<p>pop() &amp; push() 可实现堆栈(LIFO).<br>shift() &amp; push() 可实现队列(FIFO).<br>这四个方法都会改变数组的长度.</p>\n<h5 id=\"reduce-amp-map-amp-filter\"><a href=\"#reduce-amp-map-amp-filter\" class=\"headerlink\" title=\"reduce() &amp; map() &amp; filter\"></a>reduce() &amp; map() &amp; filter</h5><p>reduce() 方法对累加器和数组中的每个元素 (从左到右)应用一个函数，将其减少为<strong>单个值</strong>。<strong>不会改变原数组</strong>  </p>\n<blockquote>\n<p>array.reduce(function(accumulator, currentValue, currentIndex, array), initialValue)</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">a.reduce(<span class=\"function\">(<span class=\"params\">x, y,idx, its</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>)   <span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># map </span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">a.map(<span class=\"function\">(<span class=\"params\">item, idx, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> item * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;)   <span class=\"comment\">// [2, 4, 6, 8, 10];</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">islessThan</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  value &lt; <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">a.filter(islessThan)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Date-类型\"><a href=\"#Date-类型\" class=\"headerlink\" title=\"Date 类型\"></a>Date 类型</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var date = new Date();</span><br><span class=\"line\">console.log(date); //Mon Jul 17 2017 16:20:03 GMT+0800 (CST)</span><br><span class=\"line\">date.getFullYear(); //2017</span><br></pre></td></tr></table></figure>\n<h3 id=\"Function-类型\"><a href=\"#Function-类型\" class=\"headerlink\" title=\"Function 类型\"></a>Function 类型</h3><p><a href=\"http://chenpt.cc/2017/07/13/Js-Function/\" target=\"_blank\" rel=\"noopener\">http://chenpt.cc/2017/07/13/Js-Function/</a></p>\n<h3 id=\"基本包装类型-String-Number-Boolean\"><a href=\"#基本包装类型-String-Number-Boolean\" class=\"headerlink\" title=\"基本包装类型(String,Number,Boolean)\"></a>基本包装类型(String,Number,Boolean)</h3><h4 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h4><ol>\n<li>type1:”wow”</li>\n<li>type2:`hello world`  </li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str1 = <span class=\"string\">\"wow\"</span>  + <span class=\"string\">\" fuck\"</span>;    <span class=\"comment\">// \"wow fuck\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"RegExp-构造函数创建了一个正则表达式对象RegExp\"><a href=\"#RegExp-构造函数创建了一个正则表达式对象RegExp\" class=\"headerlink\" title=\"RegExp 构造函数创建了一个正则表达式对象RegExp\"></a>RegExp 构造函数创建了一个正则表达式对象RegExp</h3><p>RegExp 构造函数创建了一个正则表达式对象<br>三种方法: 字面量, 构造函数, 工厂符号<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/pattern/flags</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(pattern [, flags])</span><br><span class=\"line\"><span class=\"built_in\">RegExp</span>(pattern, [,flags]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//pattern 正则表达式的文本</span></span><br><span class=\"line\"><span class=\"comment\">// flags </span></span><br><span class=\"line\"><span class=\"comment\">// g: 找到所有匹配,而不是在第一个匹配后停止</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"comment\">/*.com/g</span></span><br><span class=\"line\"><span class=\"comment\">var testStr = 'sdsdsdsada.com';</span></span><br><span class=\"line\"><span class=\"comment\">pattern.exec(testStr)</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"JavaScript内置对象\"><a href=\"#JavaScript内置对象\" class=\"headerlink\" title=\"JavaScript内置对象\"></a>JavaScript内置对象</h2><p>第二周周一…JavaScript内置对象</p>","more":"<h3 id=\"Glboal对象-全局对象\"><a href=\"#Glboal对象-全局对象\" class=\"headerlink\" title=\"Glboal对象 (全局对象)\"></a>Glboal对象 (全局对象)</h3><p>它是一个特殊的对象,实际上,所有在全局作用域中定义的属性和函数,都是全局对象的属性和方法.<br>在JavaScript中,全局对象就是window对象.<br>全局对象的方法:  </p>\n<ul>\n<li>encodeURI() //对字符串进行编码形成可用的URI(通用资源标识符)</li>\n<li>encodeURIComponent()  //将字符串编码为URI组件,与encodeURI的区别就是它的参数是URI的一部分(比如协议\\主机名\\路径\\查询字符串) 它也会把不属于URI的特殊字符进行编码(如冒号,正斜杆,问号,#号),而encodeURI()不会.</li>\n<li>decodeURI()</li>\n<li>decodeURIComponent()</li>\n<li>escape()  //将字符串进行编码</li>\n<li>eval() //计算Js字符串,并把它作为脚本代码来执行</li>\n<li>isFinite()  //判断某个值是否为有穷数</li>\n<li>isNaN()      //is not a number  判断检查参数是否为非数字值.</li>\n<li>Number()      //将对象的值转化为函数,如果无法转换则返回NaN</li>\n<li>parseInt()    //将字符串转换为整数</li>\n<li>parseFloat()  //将字符串转换为浮点数</li>\n<li>String()      //将对象的值转化为字符串</li>\n<li>unescape()    //将escape()编的码转化为字符串</li>\n</ul>\n<ul>\n<li>NaN       // Not-A-Number</li>\n<li>Infinity   //全局属性,表示无穷</li>\n</ul>\n<h2 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h2><p>在ECMAScript中,引用类型是一种数据结构,用于将数据和功能组织在一起.引用类型有时候也被称为<strong>对象定义</strong>,因为它们描述的是一类对象所具有的属性和方法.  </p>\n<p><strong>对象是某个特定引用类型的实例</strong>,新对象是使用new操作符加一个构造函数生成的.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br></pre></td></tr></table></figure>\n<p>这行代码创建一个 Object()类型的新实例, 保存到person变量中.<br>构造函数Object为新对象定义了默认的属性和方法.</p>\n<h3 id=\"Object-类型\"><a href=\"#Object-类型\" class=\"headerlink\" title=\"Object 类型\"></a>Object 类型</h3><h4 id=\"创建Object类型\"><a href=\"#创建Object类型\" class=\"headerlink\" title=\"创建Object类型\"></a>创建Object类型</h4><p>创建Object类型有两种方法<br>1.使用new操作符<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br></pre></td></tr></table></figure></p>\n<p>2.对象字面量法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> apple = &#123;</span><br><span class=\"line\">    price: <span class=\"number\">100</span>,</span><br><span class=\"line\">    color: <span class=\"string\">'red'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">from</span>: <span class=\"string\">'GuangZhou'</span>,</span><br><span class=\"line\">    isFruit: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    to where: <span class=\"string\">'BeiJing'</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"访问对象属性\"><a href=\"#访问对象属性\" class=\"headerlink\" title=\"访问对象属性\"></a>访问对象属性</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apple.price;  <span class=\"comment\">//100</span></span><br><span class=\"line\">apple[<span class=\"string\">\"price\"</span>]; <span class=\"comment\">//100  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fruitColor = <span class=\"string\">\"color\"</span>;  <span class=\"comment\">// 使用方括号语法可以通过变量来访问对象属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">apple[fruitColor]; <span class=\"comment\">// 'red'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//to where 含有空格,不能使用\".\"来访问,只能用方括号语法.  </span></span><br><span class=\"line\"></span><br><span class=\"line\">apple[<span class=\"string\">\"to where\"</span>]; <span class=\"comment\">// \"BeiJing\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Array-类型\"><a href=\"#Array-类型\" class=\"headerlink\" title=\"Array 类型\"></a>Array 类型</h3><h4 id=\"创建数组类型\"><a href=\"#创建数组类型\" class=\"headerlink\" title=\"创建数组类型\"></a>创建数组类型</h4><p><strong>ECMAScript数组的每一项可以保存任何类型的数据</strong><br>1.采用Array构造函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\"><span class=\"comment\">// var array = Array();</span></span><br><span class=\"line\">array[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">array[<span class=\"number\">1</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">// array = [1, 2];</span></span><br></pre></td></tr></table></figure></p>\n<p>2.数组字面量法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"string\">'Fuck'</span>];</span><br></pre></td></tr></table></figure></p>\n<p>数组的length属性不是只读的,通过改变length属性的值可以从数组的末尾删除元素或者添加新元素.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">a.length = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// [1, 2]</span></span><br><span class=\"line\">a.length = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a[<span class=\"number\">2</span>]);  <span class=\"comment\">//undefined</span></span><br><span class=\"line\">a[a.length] = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// [1, 2, undefined, 4];</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"讲几个Array的方法\"><a href=\"#讲几个Array的方法\" class=\"headerlink\" title=\"讲几个Array的方法\"></a>讲几个Array的方法</h4><h5 id=\"slice-amp-splice\"><a href=\"#slice-amp-splice\" class=\"headerlink\" title=\"slice &amp; splice\"></a>slice &amp; splice</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Array.prototype.slice(beginIndex, endIndex); 不包括结束</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\">a.slice(<span class=\"number\">0</span>,<span class=\"number\">2</span>);  <span class=\"comment\">// [1, 2]  把序号为0, 1 的值取出来,原数组不变</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a)  <span class=\"comment\">// [1, 2, 3, 4];</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Array.prototype.splice(start, deleteCount)</span></span><br><span class=\"line\"><span class=\"comment\">//Array.prototype.splice(start, deleteCount,item1,....);</span></span><br><span class=\"line\">a.splice(<span class=\"number\">2</span>, <span class=\"number\">1</span>);  <span class=\"comment\">// [3]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// [1, 2, 4]</span></span><br><span class=\"line\"></span><br><span class=\"line\">a.splice(<span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span>); <span class=\"comment\">// [1, 2, 4, 5]  deleteCount为0表示不删除元素,即添加元素</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"pop-amp-push-amp-shift-amp-unshift\"><a href=\"#pop-amp-push-amp-shift-amp-unshift\" class=\"headerlink\" title=\"pop &amp; push &amp; shift &amp; unshift\"></a>pop &amp; push &amp; shift &amp; unshift</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\">a.push(<span class=\"number\">5</span>, <span class=\"number\">6</span>)  <span class=\"comment\">// 返回a.length  == 6</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// [1, 2, 3, 4, 5, 6];</span></span><br><span class=\"line\"></span><br><span class=\"line\">a.pop(); <span class=\"comment\">// 数组的最后一项 6</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// [1, 2, 3, 4, 5];</span></span><br><span class=\"line\"></span><br><span class=\"line\">a.shift(); <span class=\"comment\">// 数组的第一项 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">a.unshift(<span class=\"number\">0</span>, <span class=\"number\">1</span>);  <span class=\"comment\">//返回a.length == 10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//[0, 1, 2, 3, 4, 5];</span></span><br></pre></td></tr></table></figure>\n<p>pop() &amp; push() 可实现堆栈(LIFO).<br>shift() &amp; push() 可实现队列(FIFO).<br>这四个方法都会改变数组的长度.</p>\n<h5 id=\"reduce-amp-map-amp-filter\"><a href=\"#reduce-amp-map-amp-filter\" class=\"headerlink\" title=\"reduce() &amp; map() &amp; filter\"></a>reduce() &amp; map() &amp; filter</h5><p>reduce() 方法对累加器和数组中的每个元素 (从左到右)应用一个函数，将其减少为<strong>单个值</strong>。<strong>不会改变原数组</strong>  </p>\n<blockquote>\n<p>array.reduce(function(accumulator, currentValue, currentIndex, array), initialValue)</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">a.reduce(<span class=\"function\">(<span class=\"params\">x, y,idx, its</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>)   <span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># map </span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">a.map(<span class=\"function\">(<span class=\"params\">item, idx, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> item * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;)   <span class=\"comment\">// [2, 4, 6, 8, 10];</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">islessThan</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  value &lt; <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">a.filter(islessThan)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Date-类型\"><a href=\"#Date-类型\" class=\"headerlink\" title=\"Date 类型\"></a>Date 类型</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var date = new Date();</span><br><span class=\"line\">console.log(date); //Mon Jul 17 2017 16:20:03 GMT+0800 (CST)</span><br><span class=\"line\">date.getFullYear(); //2017</span><br></pre></td></tr></table></figure>\n<h3 id=\"Function-类型\"><a href=\"#Function-类型\" class=\"headerlink\" title=\"Function 类型\"></a>Function 类型</h3><p><a href=\"http://chenpt.cc/2017/07/13/Js-Function/\" target=\"_blank\" rel=\"noopener\">http://chenpt.cc/2017/07/13/Js-Function/</a></p>\n<h3 id=\"基本包装类型-String-Number-Boolean\"><a href=\"#基本包装类型-String-Number-Boolean\" class=\"headerlink\" title=\"基本包装类型(String,Number,Boolean)\"></a>基本包装类型(String,Number,Boolean)</h3><h4 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h4><ol>\n<li>type1:”wow”</li>\n<li>type2:`hello world`  </li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str1 = <span class=\"string\">\"wow\"</span>  + <span class=\"string\">\" fuck\"</span>;    <span class=\"comment\">// \"wow fuck\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"RegExp-构造函数创建了一个正则表达式对象RegExp\"><a href=\"#RegExp-构造函数创建了一个正则表达式对象RegExp\" class=\"headerlink\" title=\"RegExp 构造函数创建了一个正则表达式对象RegExp\"></a>RegExp 构造函数创建了一个正则表达式对象RegExp</h3><p>RegExp 构造函数创建了一个正则表达式对象<br>三种方法: 字面量, 构造函数, 工厂符号<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/pattern/flags</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(pattern [, flags])</span><br><span class=\"line\"><span class=\"built_in\">RegExp</span>(pattern, [,flags]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//pattern 正则表达式的文本</span></span><br><span class=\"line\"><span class=\"comment\">// flags </span></span><br><span class=\"line\"><span class=\"comment\">// g: 找到所有匹配,而不是在第一个匹配后停止</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"comment\">/*.com/g</span></span><br><span class=\"line\"><span class=\"comment\">var testStr = 'sdsdsdsada.com';</span></span><br><span class=\"line\"><span class=\"comment\">pattern.exec(testStr)</span></span><br></pre></td></tr></table></figure>"},{"title":"JS高级程序设计 6.2 创建对象 的笔记","date":"2016-07-25T16:00:00.000Z","_content":"## 原型模式\n之前对原型这部分的内容感觉很懵,所以做笔记整理一下思路.\n\n\n----------\n\n\n我们创建的每个函数都有一个prototype(原型)属性,这个属性是一个指针,指向一个对象.这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法  所指的这个对象就是原型对象.\nprototype 就是通过构造函数创建出来的实例的原型对象,使用原型对象的好处就是可以让所有对象实例共享它所包含的属性和方法,也就是不必在构造函数中定义对象实例的信息,而是将这些信息直接添加道原型对象中.\n### 1.理解原型对象 \n\n - 创建一个新的函数,会默认创建一个prototype属性, 这个属性指向函数的原型对象.\n - 同时,所有原型对象会自动获得一个 constructor (构造函数)属性,这个属性是一个指针,指向prototype属性所在的函数.\n - 创建自定义的构造函数之后,其原型对象默认只会取得constructor属性\n - 使用构造函数构造一个新的对象实例后,该对象实例的内部将包含一个指针(内部属性)[[Prototype]] 指向构造函数的原型对象.\n\n***\n### 2.属性屏蔽\n先说一下代码读取某个对象的某个属性的流程.\n\n 1. 代码读取某个对象的某个属性,都会执行一次搜索,目标是具有给定名字的属性.\n 2. 首先是在对象实例本身开始寻找是否具有那个属性.假如没有\n 3. 转而继续搜索对象实例内部指针[[Prototype]]所指向的原型对象\n 4. 找到该属性后,返回该属性的值\n```javascript\nfunction Person(){\n}\nPerson.prototype.name = \"ChenPt\";\nPerson.prototype.age = 29;\nPerson.prototype.sayName = function(){\n    alert(this.name);\n};\n\nvar person1 = new Person();\nvar person2 = new Person();\nPerson1.name = \"Wow\";\nalert(person1.name); // \"WOw\"来自对象实例\nalert(person2.name);// \"ChenPt\"来自原型\n```\n由代码读取某个对象的某个属性的搜索过程我们可以知道,我们可以通过对象实例  访问 保存在原型中的值,但是我们不能通过对象实例重写原型中的值.如果我们往对象实例添加一个属性,这个属性已经存在于对象实例的原型中,结果会是,我们成功在对象实例中创建了该属性,该属性会屏蔽原型中的那个属性.\n即当为对象实例添加一个属性时,这个属性就会屏蔽原型对象中保存的同名属性.添加这个属性只会阻止我们访问原型中的那个属性,但是不会修改那个属性,所以,叫做属性屏蔽\n```javascript\ndelete.person1.name;\nalert(person1.name);  // \"ChenPt\" 来自原型\n```\n可以删除对象实例中的属性,删除之后就恢复了对原型中name属性的连接\n***\n既然实例中和原型对象中都可以有同名属性,那我们可以 用hasOwnProperty()方法检测一个属性是存在于实例中还是存在于原型对象中. 属性存在于实例中时,hasOwnProperty()返回 true.\n***\n#### in操作符\n 只要通过对象能够访问道属性就返回 true\n ***\n\n     hasPrototypeProperty(person, \"name\")    // 如果实例拥有name 属性 则返回 false.\n                                             // 如果实例没有name 属性 则返回 true.\n***\n### 3.简单的原型语法 \n (包含所有属性和方法的对象字面量来重写整个原型对象)\n```javascript\nfunction Person(){\n}\nPerson.prototype = {\n    name : \"ChenPt\",\n    age : 19,\n    sayName : function(){\n        alert(this.name);\n    }\n}\n```\n\n注意 此时原型对象的constructor 属性不再指向Person了.这里我们本质上是完全重写了默认的prototype对象,因此 constructor属性也变成了新对象的constructor属性(指向Object构造函数) 不再指向Person函数.\n你可以设置constructor的值为适当的值\n```javascript\n//重设构造函数\nObject.defineProperty(Person.prototype, \"constructor\",{\n    enumerable: false,\n    value: Person\n});\n```\n#### 原型的动态性\n```javascript\nfunction Person(){\n}\n\nvar friend = new Person();\n\nPerson.prototype = {\n    constructor: Person,\n    name: \"ChenPt\",\n    age: 19,\n    sayName : function(){\n        alert(this.name);\n    }\n};\nfriend.sayName();  //报错\n```\n我们先建了一个Person的一个实例,然后重新写了其原型对象. \n `friend.sayName();`报错,因为friend指向的原型不包含sayName这属性.\nfriend指向的原型只有默认的constructor属性(指向Person这个构造函数).\n这就说明了,重写原型对象切断了现有原型与之前已经存在的对象实例之间的联系,这些对象实例引用的仍然是最初的原型.\n#### 原型模式的问题\n**原型中所有属性都是被很多实例共享的**\n对于包含**引用类型值**的属性来说,问题就会变得很突出了.什么叫引用类型值呢,我查阅的资料如下\n**引用类型：对象、数组、函数**\n我们来举个栗子(参照书的P158)\n```javascript\nfunction Person () {\n}\n\nPerson.prototype = {\n    constructor : Person,\n    name : \"ChenPt\",\n    age : 19,\n    friends : [\"Aaa\",\"Bbb\"],  //friends是包含引用类型值(数组)的属性\n    sayName : function () {\n        alert(this.name);\n    }\n};\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.friends.push(\"Ccc\");    //往数组再添加一个字符串\n\nalert(person1.friends);     //\"Aaa\",\"Bbb\",\"Ccc\"  实例1改变了\nalert(person2.friends);     //\"Aaa\",\"Bbb\",\"Ccc\"  实例2的变化是跟实例1一样的,他们共享一个数组\nalert(person1.friends === person2.friends); //  true\n```\n所以说,在含有引用类型值的属性来说,修改此属性的值后,所有实例的此属性值也会跟着变化.\n实例一般是要有属于自己的全部属性的.所以这时候就有了 组合使用构造函数模式和原型模式\n***\n## 组合使用构造模式和原型模式\n通俗点讲,构造函数用于定义实例属性,而原型模式用于定义方法和共享的属性.\n```javascript\nfunction Person (name,age) {\n    this.name = name;\n    this.age = age;\n    this.friends = [\"Zzz\",\"Yyy\"];\n}\n\nPerson.prototype = {\n    constructor : Person,\n    sayName : function () {\n        alert(this.name)\n    }\n};\n\nvar person1 = new Person(\"Aaa\",19);\nvar person2 = new Person(\"BBb\",20);\n\nperson1.friends.push(\"Www\");\n\nalert(person1.friends);     // [\"Zzz\", \"Yyy\", \"Www\"]\nalert(person2.friends);     // [\"Zzz\", \"Yyy\"]  \nperson1.sayName();          // Aaa\n```\n第17行代码修改了实例一的friends属性,往其中添加了一个新的字符串,但是并不会影响到对象实例 person2.friends,因为它们引用了不同的数组.\n构造函数与原型混成的模式,可以说,`这是用来**定义引用类型**的一种默认模式.\n***\n**未完待续..........**\n","source":"_posts/prototype-mode.md","raw":"---\ntitle: JS高级程序设计 6.2 创建对象 的笔记\ncategory: JavaScript\ntags: 原型模式\ndate: 2016-07-26\n---\n## 原型模式\n之前对原型这部分的内容感觉很懵,所以做笔记整理一下思路.\n\n\n----------\n\n\n我们创建的每个函数都有一个prototype(原型)属性,这个属性是一个指针,指向一个对象.这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法  所指的这个对象就是原型对象.\nprototype 就是通过构造函数创建出来的实例的原型对象,使用原型对象的好处就是可以让所有对象实例共享它所包含的属性和方法,也就是不必在构造函数中定义对象实例的信息,而是将这些信息直接添加道原型对象中.\n### 1.理解原型对象 \n\n - 创建一个新的函数,会默认创建一个prototype属性, 这个属性指向函数的原型对象.\n - 同时,所有原型对象会自动获得一个 constructor (构造函数)属性,这个属性是一个指针,指向prototype属性所在的函数.\n - 创建自定义的构造函数之后,其原型对象默认只会取得constructor属性\n - 使用构造函数构造一个新的对象实例后,该对象实例的内部将包含一个指针(内部属性)[[Prototype]] 指向构造函数的原型对象.\n\n***\n### 2.属性屏蔽\n先说一下代码读取某个对象的某个属性的流程.\n\n 1. 代码读取某个对象的某个属性,都会执行一次搜索,目标是具有给定名字的属性.\n 2. 首先是在对象实例本身开始寻找是否具有那个属性.假如没有\n 3. 转而继续搜索对象实例内部指针[[Prototype]]所指向的原型对象\n 4. 找到该属性后,返回该属性的值\n```javascript\nfunction Person(){\n}\nPerson.prototype.name = \"ChenPt\";\nPerson.prototype.age = 29;\nPerson.prototype.sayName = function(){\n    alert(this.name);\n};\n\nvar person1 = new Person();\nvar person2 = new Person();\nPerson1.name = \"Wow\";\nalert(person1.name); // \"WOw\"来自对象实例\nalert(person2.name);// \"ChenPt\"来自原型\n```\n由代码读取某个对象的某个属性的搜索过程我们可以知道,我们可以通过对象实例  访问 保存在原型中的值,但是我们不能通过对象实例重写原型中的值.如果我们往对象实例添加一个属性,这个属性已经存在于对象实例的原型中,结果会是,我们成功在对象实例中创建了该属性,该属性会屏蔽原型中的那个属性.\n即当为对象实例添加一个属性时,这个属性就会屏蔽原型对象中保存的同名属性.添加这个属性只会阻止我们访问原型中的那个属性,但是不会修改那个属性,所以,叫做属性屏蔽\n```javascript\ndelete.person1.name;\nalert(person1.name);  // \"ChenPt\" 来自原型\n```\n可以删除对象实例中的属性,删除之后就恢复了对原型中name属性的连接\n***\n既然实例中和原型对象中都可以有同名属性,那我们可以 用hasOwnProperty()方法检测一个属性是存在于实例中还是存在于原型对象中. 属性存在于实例中时,hasOwnProperty()返回 true.\n***\n#### in操作符\n 只要通过对象能够访问道属性就返回 true\n ***\n\n     hasPrototypeProperty(person, \"name\")    // 如果实例拥有name 属性 则返回 false.\n                                             // 如果实例没有name 属性 则返回 true.\n***\n### 3.简单的原型语法 \n (包含所有属性和方法的对象字面量来重写整个原型对象)\n```javascript\nfunction Person(){\n}\nPerson.prototype = {\n    name : \"ChenPt\",\n    age : 19,\n    sayName : function(){\n        alert(this.name);\n    }\n}\n```\n\n注意 此时原型对象的constructor 属性不再指向Person了.这里我们本质上是完全重写了默认的prototype对象,因此 constructor属性也变成了新对象的constructor属性(指向Object构造函数) 不再指向Person函数.\n你可以设置constructor的值为适当的值\n```javascript\n//重设构造函数\nObject.defineProperty(Person.prototype, \"constructor\",{\n    enumerable: false,\n    value: Person\n});\n```\n#### 原型的动态性\n```javascript\nfunction Person(){\n}\n\nvar friend = new Person();\n\nPerson.prototype = {\n    constructor: Person,\n    name: \"ChenPt\",\n    age: 19,\n    sayName : function(){\n        alert(this.name);\n    }\n};\nfriend.sayName();  //报错\n```\n我们先建了一个Person的一个实例,然后重新写了其原型对象. \n `friend.sayName();`报错,因为friend指向的原型不包含sayName这属性.\nfriend指向的原型只有默认的constructor属性(指向Person这个构造函数).\n这就说明了,重写原型对象切断了现有原型与之前已经存在的对象实例之间的联系,这些对象实例引用的仍然是最初的原型.\n#### 原型模式的问题\n**原型中所有属性都是被很多实例共享的**\n对于包含**引用类型值**的属性来说,问题就会变得很突出了.什么叫引用类型值呢,我查阅的资料如下\n**引用类型：对象、数组、函数**\n我们来举个栗子(参照书的P158)\n```javascript\nfunction Person () {\n}\n\nPerson.prototype = {\n    constructor : Person,\n    name : \"ChenPt\",\n    age : 19,\n    friends : [\"Aaa\",\"Bbb\"],  //friends是包含引用类型值(数组)的属性\n    sayName : function () {\n        alert(this.name);\n    }\n};\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.friends.push(\"Ccc\");    //往数组再添加一个字符串\n\nalert(person1.friends);     //\"Aaa\",\"Bbb\",\"Ccc\"  实例1改变了\nalert(person2.friends);     //\"Aaa\",\"Bbb\",\"Ccc\"  实例2的变化是跟实例1一样的,他们共享一个数组\nalert(person1.friends === person2.friends); //  true\n```\n所以说,在含有引用类型值的属性来说,修改此属性的值后,所有实例的此属性值也会跟着变化.\n实例一般是要有属于自己的全部属性的.所以这时候就有了 组合使用构造函数模式和原型模式\n***\n## 组合使用构造模式和原型模式\n通俗点讲,构造函数用于定义实例属性,而原型模式用于定义方法和共享的属性.\n```javascript\nfunction Person (name,age) {\n    this.name = name;\n    this.age = age;\n    this.friends = [\"Zzz\",\"Yyy\"];\n}\n\nPerson.prototype = {\n    constructor : Person,\n    sayName : function () {\n        alert(this.name)\n    }\n};\n\nvar person1 = new Person(\"Aaa\",19);\nvar person2 = new Person(\"BBb\",20);\n\nperson1.friends.push(\"Www\");\n\nalert(person1.friends);     // [\"Zzz\", \"Yyy\", \"Www\"]\nalert(person2.friends);     // [\"Zzz\", \"Yyy\"]  \nperson1.sayName();          // Aaa\n```\n第17行代码修改了实例一的friends属性,往其中添加了一个新的字符串,但是并不会影响到对象实例 person2.friends,因为它们引用了不同的数组.\n构造函数与原型混成的模式,可以说,`这是用来**定义引用类型**的一种默认模式.\n***\n**未完待续..........**\n","slug":"prototype-mode","published":1,"updated":"2017-07-17T04:57:01.001Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf81eh8y0017v4ef76vs7sy4","content":"<h2 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h2><p>之前对原型这部分的内容感觉很懵,所以做笔记整理一下思路.</p>\n<hr>\n<p>我们创建的每个函数都有一个prototype(原型)属性,这个属性是一个指针,指向一个对象.这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法  所指的这个对象就是原型对象.<br>prototype 就是通过构造函数创建出来的实例的原型对象,使用原型对象的好处就是可以让所有对象实例共享它所包含的属性和方法,也就是不必在构造函数中定义对象实例的信息,而是将这些信息直接添加道原型对象中.</p>\n<h3 id=\"1-理解原型对象\"><a href=\"#1-理解原型对象\" class=\"headerlink\" title=\"1.理解原型对象\"></a>1.理解原型对象</h3><ul>\n<li>创建一个新的函数,会默认创建一个prototype属性, 这个属性指向函数的原型对象.</li>\n<li>同时,所有原型对象会自动获得一个 constructor (构造函数)属性,这个属性是一个指针,指向prototype属性所在的函数.</li>\n<li>创建自定义的构造函数之后,其原型对象默认只会取得constructor属性</li>\n<li>使用构造函数构造一个新的对象实例后,该对象实例的内部将包含一个指针(内部属性)[[Prototype]] 指向构造函数的原型对象.</li>\n</ul>\n<hr>\n<h3 id=\"2-属性屏蔽\"><a href=\"#2-属性屏蔽\" class=\"headerlink\" title=\"2.属性屏蔽\"></a>2.属性屏蔽</h3><p>先说一下代码读取某个对象的某个属性的流程.</p>\n<ol>\n<li>代码读取某个对象的某个属性,都会执行一次搜索,目标是具有给定名字的属性.</li>\n<li>首先是在对象实例本身开始寻找是否具有那个属性.假如没有</li>\n<li>转而继续搜索对象实例内部指针[[Prototype]]所指向的原型对象</li>\n<li>找到该属性后,返回该属性的值<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.name = <span class=\"string\">\"ChenPt\"</span>;</span><br><span class=\"line\">Person.prototype.age = <span class=\"number\">29</span>;</span><br><span class=\"line\">Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">Person1.name = <span class=\"string\">\"Wow\"</span>;</span><br><span class=\"line\">alert(person1.name); <span class=\"comment\">// \"WOw\"来自对象实例</span></span><br><span class=\"line\">alert(person2.name);<span class=\"comment\">// \"ChenPt\"来自原型</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>由代码读取某个对象的某个属性的搜索过程我们可以知道,我们可以通过对象实例  访问 保存在原型中的值,但是我们不能通过对象实例重写原型中的值.如果我们往对象实例添加一个属性,这个属性已经存在于对象实例的原型中,结果会是,我们成功在对象实例中创建了该属性,该属性会屏蔽原型中的那个属性.<br>即当为对象实例添加一个属性时,这个属性就会屏蔽原型对象中保存的同名属性.添加这个属性只会阻止我们访问原型中的那个属性,但是不会修改那个属性,所以,叫做属性屏蔽<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span>.person1.name;</span><br><span class=\"line\">alert(person1.name);  <span class=\"comment\">// \"ChenPt\" 来自原型</span></span><br></pre></td></tr></table></figure></p>\n<p>可以删除对象实例中的属性,删除之后就恢复了对原型中name属性的连接</p>\n<hr>\n<p>既然实例中和原型对象中都可以有同名属性,那我们可以 用hasOwnProperty()方法检测一个属性是存在于实例中还是存在于原型对象中. 属性存在于实例中时,hasOwnProperty()返回 true.</p>\n<hr>\n<h4 id=\"in操作符\"><a href=\"#in操作符\" class=\"headerlink\" title=\"in操作符\"></a>in操作符</h4><p> 只要通过对象能够访问道属性就返回 true</p>\n<hr>\n<pre><code>hasPrototypeProperty(person, &quot;name&quot;)    // 如果实例拥有name 属性 则返回 false.\n                                        // 如果实例没有name 属性 则返回 true.\n</code></pre><hr>\n<h3 id=\"3-简单的原型语法\"><a href=\"#3-简单的原型语法\" class=\"headerlink\" title=\"3.简单的原型语法\"></a>3.简单的原型语法</h3><p> (包含所有属性和方法的对象字面量来重写整个原型对象)<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    name : <span class=\"string\">\"ChenPt\"</span>,</span><br><span class=\"line\">    age : <span class=\"number\">19</span>,</span><br><span class=\"line\">    sayName : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意 此时原型对象的constructor 属性不再指向Person了.这里我们本质上是完全重写了默认的prototype对象,因此 constructor属性也变成了新对象的constructor属性(指向Object构造函数) 不再指向Person函数.<br>你可以设置constructor的值为适当的值<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//重设构造函数</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(Person.prototype, <span class=\"string\">\"constructor\"</span>,&#123;</span><br><span class=\"line\">    enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    value: Person</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"原型的动态性\"><a href=\"#原型的动态性\" class=\"headerlink\" title=\"原型的动态性\"></a>原型的动态性</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> friend = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>: Person,</span><br><span class=\"line\">    name: \"ChenPt\",</span><br><span class=\"line\">    age: 19,</span><br><span class=\"line\">    sayName : function()&#123;</span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">friend.sayName();  <span class=\"comment\">//报错</span></span><br></pre></td></tr></table></figure>\n<p>我们先建了一个Person的一个实例,然后重新写了其原型对象.<br> <code>friend.sayName();</code>报错,因为friend指向的原型不包含sayName这属性.<br>friend指向的原型只有默认的constructor属性(指向Person这个构造函数).<br>这就说明了,重写原型对象切断了现有原型与之前已经存在的对象实例之间的联系,这些对象实例引用的仍然是最初的原型.</p>\n<h4 id=\"原型模式的问题\"><a href=\"#原型模式的问题\" class=\"headerlink\" title=\"原型模式的问题\"></a>原型模式的问题</h4><p><strong>原型中所有属性都是被很多实例共享的</strong><br>对于包含<strong>引用类型值</strong>的属性来说,问题就会变得很突出了.什么叫引用类型值呢,我查阅的资料如下<br><strong>引用类型：对象、数组、函数</strong><br>我们来举个栗子(参照书的P158)<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> : Person,</span><br><span class=\"line\">    name : \"ChenPt\",</span><br><span class=\"line\">    age : 19,</span><br><span class=\"line\">    friends : [\"Aaa\",\"Bbb\"],  //friends是包含引用类型值(数组)的属性</span><br><span class=\"line\">    sayName : function () &#123;</span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"></span><br><span class=\"line\">person1.friends.push(<span class=\"string\">\"Ccc\"</span>);    <span class=\"comment\">//往数组再添加一个字符串</span></span><br><span class=\"line\"></span><br><span class=\"line\">alert(person1.friends);     <span class=\"comment\">//\"Aaa\",\"Bbb\",\"Ccc\"  实例1改变了</span></span><br><span class=\"line\">alert(person2.friends);     <span class=\"comment\">//\"Aaa\",\"Bbb\",\"Ccc\"  实例2的变化是跟实例1一样的,他们共享一个数组</span></span><br><span class=\"line\">alert(person1.friends === person2.friends); <span class=\"comment\">//  true</span></span><br></pre></td></tr></table></figure></p>\n<p>所以说,在含有引用类型值的属性来说,修改此属性的值后,所有实例的此属性值也会跟着变化.<br>实例一般是要有属于自己的全部属性的.所以这时候就有了 组合使用构造函数模式和原型模式</p>\n<hr>\n<h2 id=\"组合使用构造模式和原型模式\"><a href=\"#组合使用构造模式和原型模式\" class=\"headerlink\" title=\"组合使用构造模式和原型模式\"></a>组合使用构造模式和原型模式</h2><p>通俗点讲,构造函数用于定义实例属性,而原型模式用于定义方法和共享的属性.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span> (<span class=\"params\">name,age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.friends = [<span class=\"string\">\"Zzz\"</span>,<span class=\"string\">\"Yyy\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> : Person,</span><br><span class=\"line\">    sayName : function () &#123;</span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Aaa\"</span>,<span class=\"number\">19</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"BBb\"</span>,<span class=\"number\">20</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">person1.friends.push(<span class=\"string\">\"Www\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">alert(person1.friends);     <span class=\"comment\">// [\"Zzz\", \"Yyy\", \"Www\"]</span></span><br><span class=\"line\">alert(person2.friends);     <span class=\"comment\">// [\"Zzz\", \"Yyy\"]  </span></span><br><span class=\"line\">person1.sayName();          <span class=\"comment\">// Aaa</span></span><br></pre></td></tr></table></figure></p>\n<p>第17行代码修改了实例一的friends属性,往其中添加了一个新的字符串,但是并不会影响到对象实例 person2.friends,因为它们引用了不同的数组.<br>构造函数与原型混成的模式,可以说,`这是用来<strong>定义引用类型</strong>的一种默认模式.</p>\n<hr>\n<p><strong>未完待续……….</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h2><p>之前对原型这部分的内容感觉很懵,所以做笔记整理一下思路.</p>\n<hr>\n<p>我们创建的每个函数都有一个prototype(原型)属性,这个属性是一个指针,指向一个对象.这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法  所指的这个对象就是原型对象.<br>prototype 就是通过构造函数创建出来的实例的原型对象,使用原型对象的好处就是可以让所有对象实例共享它所包含的属性和方法,也就是不必在构造函数中定义对象实例的信息,而是将这些信息直接添加道原型对象中.</p>\n<h3 id=\"1-理解原型对象\"><a href=\"#1-理解原型对象\" class=\"headerlink\" title=\"1.理解原型对象\"></a>1.理解原型对象</h3><ul>\n<li>创建一个新的函数,会默认创建一个prototype属性, 这个属性指向函数的原型对象.</li>\n<li>同时,所有原型对象会自动获得一个 constructor (构造函数)属性,这个属性是一个指针,指向prototype属性所在的函数.</li>\n<li>创建自定义的构造函数之后,其原型对象默认只会取得constructor属性</li>\n<li>使用构造函数构造一个新的对象实例后,该对象实例的内部将包含一个指针(内部属性)[[Prototype]] 指向构造函数的原型对象.</li>\n</ul>\n<hr>\n<h3 id=\"2-属性屏蔽\"><a href=\"#2-属性屏蔽\" class=\"headerlink\" title=\"2.属性屏蔽\"></a>2.属性屏蔽</h3><p>先说一下代码读取某个对象的某个属性的流程.</p>\n<ol>\n<li>代码读取某个对象的某个属性,都会执行一次搜索,目标是具有给定名字的属性.</li>\n<li>首先是在对象实例本身开始寻找是否具有那个属性.假如没有</li>\n<li>转而继续搜索对象实例内部指针[[Prototype]]所指向的原型对象</li>\n<li>找到该属性后,返回该属性的值<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.name = <span class=\"string\">\"ChenPt\"</span>;</span><br><span class=\"line\">Person.prototype.age = <span class=\"number\">29</span>;</span><br><span class=\"line\">Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">Person1.name = <span class=\"string\">\"Wow\"</span>;</span><br><span class=\"line\">alert(person1.name); <span class=\"comment\">// \"WOw\"来自对象实例</span></span><br><span class=\"line\">alert(person2.name);<span class=\"comment\">// \"ChenPt\"来自原型</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>由代码读取某个对象的某个属性的搜索过程我们可以知道,我们可以通过对象实例  访问 保存在原型中的值,但是我们不能通过对象实例重写原型中的值.如果我们往对象实例添加一个属性,这个属性已经存在于对象实例的原型中,结果会是,我们成功在对象实例中创建了该属性,该属性会屏蔽原型中的那个属性.<br>即当为对象实例添加一个属性时,这个属性就会屏蔽原型对象中保存的同名属性.添加这个属性只会阻止我们访问原型中的那个属性,但是不会修改那个属性,所以,叫做属性屏蔽<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span>.person1.name;</span><br><span class=\"line\">alert(person1.name);  <span class=\"comment\">// \"ChenPt\" 来自原型</span></span><br></pre></td></tr></table></figure></p>\n<p>可以删除对象实例中的属性,删除之后就恢复了对原型中name属性的连接</p>\n<hr>\n<p>既然实例中和原型对象中都可以有同名属性,那我们可以 用hasOwnProperty()方法检测一个属性是存在于实例中还是存在于原型对象中. 属性存在于实例中时,hasOwnProperty()返回 true.</p>\n<hr>\n<h4 id=\"in操作符\"><a href=\"#in操作符\" class=\"headerlink\" title=\"in操作符\"></a>in操作符</h4><p> 只要通过对象能够访问道属性就返回 true</p>\n<hr>\n<pre><code>hasPrototypeProperty(person, &quot;name&quot;)    // 如果实例拥有name 属性 则返回 false.\n                                        // 如果实例没有name 属性 则返回 true.\n</code></pre><hr>\n<h3 id=\"3-简单的原型语法\"><a href=\"#3-简单的原型语法\" class=\"headerlink\" title=\"3.简单的原型语法\"></a>3.简单的原型语法</h3><p> (包含所有属性和方法的对象字面量来重写整个原型对象)<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    name : <span class=\"string\">\"ChenPt\"</span>,</span><br><span class=\"line\">    age : <span class=\"number\">19</span>,</span><br><span class=\"line\">    sayName : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意 此时原型对象的constructor 属性不再指向Person了.这里我们本质上是完全重写了默认的prototype对象,因此 constructor属性也变成了新对象的constructor属性(指向Object构造函数) 不再指向Person函数.<br>你可以设置constructor的值为适当的值<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//重设构造函数</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(Person.prototype, <span class=\"string\">\"constructor\"</span>,&#123;</span><br><span class=\"line\">    enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    value: Person</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"原型的动态性\"><a href=\"#原型的动态性\" class=\"headerlink\" title=\"原型的动态性\"></a>原型的动态性</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> friend = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>: Person,</span><br><span class=\"line\">    name: \"ChenPt\",</span><br><span class=\"line\">    age: 19,</span><br><span class=\"line\">    sayName : function()&#123;</span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">friend.sayName();  <span class=\"comment\">//报错</span></span><br></pre></td></tr></table></figure>\n<p>我们先建了一个Person的一个实例,然后重新写了其原型对象.<br> <code>friend.sayName();</code>报错,因为friend指向的原型不包含sayName这属性.<br>friend指向的原型只有默认的constructor属性(指向Person这个构造函数).<br>这就说明了,重写原型对象切断了现有原型与之前已经存在的对象实例之间的联系,这些对象实例引用的仍然是最初的原型.</p>\n<h4 id=\"原型模式的问题\"><a href=\"#原型模式的问题\" class=\"headerlink\" title=\"原型模式的问题\"></a>原型模式的问题</h4><p><strong>原型中所有属性都是被很多实例共享的</strong><br>对于包含<strong>引用类型值</strong>的属性来说,问题就会变得很突出了.什么叫引用类型值呢,我查阅的资料如下<br><strong>引用类型：对象、数组、函数</strong><br>我们来举个栗子(参照书的P158)<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> : Person,</span><br><span class=\"line\">    name : \"ChenPt\",</span><br><span class=\"line\">    age : 19,</span><br><span class=\"line\">    friends : [\"Aaa\",\"Bbb\"],  //friends是包含引用类型值(数组)的属性</span><br><span class=\"line\">    sayName : function () &#123;</span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"></span><br><span class=\"line\">person1.friends.push(<span class=\"string\">\"Ccc\"</span>);    <span class=\"comment\">//往数组再添加一个字符串</span></span><br><span class=\"line\"></span><br><span class=\"line\">alert(person1.friends);     <span class=\"comment\">//\"Aaa\",\"Bbb\",\"Ccc\"  实例1改变了</span></span><br><span class=\"line\">alert(person2.friends);     <span class=\"comment\">//\"Aaa\",\"Bbb\",\"Ccc\"  实例2的变化是跟实例1一样的,他们共享一个数组</span></span><br><span class=\"line\">alert(person1.friends === person2.friends); <span class=\"comment\">//  true</span></span><br></pre></td></tr></table></figure></p>\n<p>所以说,在含有引用类型值的属性来说,修改此属性的值后,所有实例的此属性值也会跟着变化.<br>实例一般是要有属于自己的全部属性的.所以这时候就有了 组合使用构造函数模式和原型模式</p>\n<hr>\n<h2 id=\"组合使用构造模式和原型模式\"><a href=\"#组合使用构造模式和原型模式\" class=\"headerlink\" title=\"组合使用构造模式和原型模式\"></a>组合使用构造模式和原型模式</h2><p>通俗点讲,构造函数用于定义实例属性,而原型模式用于定义方法和共享的属性.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span> (<span class=\"params\">name,age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.friends = [<span class=\"string\">\"Zzz\"</span>,<span class=\"string\">\"Yyy\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> : Person,</span><br><span class=\"line\">    sayName : function () &#123;</span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Aaa\"</span>,<span class=\"number\">19</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"BBb\"</span>,<span class=\"number\">20</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">person1.friends.push(<span class=\"string\">\"Www\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">alert(person1.friends);     <span class=\"comment\">// [\"Zzz\", \"Yyy\", \"Www\"]</span></span><br><span class=\"line\">alert(person2.friends);     <span class=\"comment\">// [\"Zzz\", \"Yyy\"]  </span></span><br><span class=\"line\">person1.sayName();          <span class=\"comment\">// Aaa</span></span><br></pre></td></tr></table></figure></p>\n<p>第17行代码修改了实例一的friends属性,往其中添加了一个新的字符串,但是并不会影响到对象实例 person2.friends,因为它们引用了不同的数组.<br>构造函数与原型混成的模式,可以说,`这是用来<strong>定义引用类型</strong>的一种默认模式.</p>\n<hr>\n<p><strong>未完待续……….</strong></p>\n"},{"title":"CSS3 & H5 Canvas","date":"2017-07-10T16:00:00.000Z","_content":"\n因为需要给大一捞仔们介绍下..CSS和 H5的东西,所以就顺便复习了下这些知识,写成学习记录blog,结合CSS揭秘和MDN,对CSS3的新特性也了解加深了..\n<!-- more -->\n\n## CSS3\n### 选择器\n 参考W3 \n http://www.w3school.com.cn/cssref/css_selectors.asp\n 或者  MDN \n https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference#选择器\n\n### 背景和边框\n+  border-radius\n+  box-shadow\n+  border-image\n#### border-radius\nborder-radius 有四个参数  border-radius(top-left, top-right, bottom-right, bottom-left)\n#### box-shadow\nbox-shadow（inset, offset-x, offset-y, blur-radius, spread-radius, color）\n默认是outset 当第一个参数写了inset之后就变成阴影在边框内，背景之上内容之下。\noffset-x, offset-y 是 水平和垂直的阴影偏移量\nblur-radius  默认为0，边缘锋利，不能为负，值越大，模糊面积越大，阴影就越大越淡\nspread-radius 取正值，阴影扩大，取负值，阴影收缩。默认为0，此时阴影与元素同样大\n#### border-image \n### 文本效果\n+  text-shadow  文本阴影\n+  word-wrap: normal | break-word;  强制文本进行换行\n+   text-overflow: clip | ellipsis | string;   (修剪| 省略号代替溢出的文本 | 使用给定的字符串而不是省略号来代替)\n### @规则\n#### @font-face规则 （使用自定义字体）\n```\n@font-face {\n\tfont-family: myFont;\n\tsrc: url('xxxx.ttf');  //自定义的字体文件路径\n}\n\ndiv {\n\tfont-family: myFont;\n}\n```\n\n#### @media规则 （媒体查询，作用：在不同设备上使用不同的CSS）\n```css\n/*在打印机设备上显示*/\n@media print {\n}\n/*在屏幕上显示*/\n@media screen {\n}\n\n\n/*在700px~1024px的设备上显示以下样式*/\n@media screen and (max-width: 1024px) and (min-width: 700px) {\n}\n```\n\n#### @keyframes规则 （描述CSS动画的中间步骤）放在CSS3动画一起讲\n### CSS3 变形 （2D&3D转换）\n **transform**属性： &nbsp 可以在不影响正常文档流的情况下改变作用内容的位置\n#### 2D转换\n+  translate(x,y)  元素从当前位置分别在水平和垂直移动 x、y 距离\n+  rotate(x deg) 元素顺时针旋转给定的角度。负值时，元素将逆时针旋转\n+  scale(x, y)  把尺寸转为原来的 x、y倍\n+  skew(x deg, y deg) 围绕 X、Y轴翻转 \n+  matrix()   前面的5个的综合\n\n```css \ndiv {\n\ttransform:translate(50px, 100px) || rotate(30deg) || scale(1,2) || skew(20deg, 30deg)\n}\n```\n\n#### 3D转换\n\t1.  rotateX( )  围绕X轴 以给定的度数进行旋转\n\t2.  rotateY( )  围绕Y轴 以给定的度数进行旋转\n\n\n### CSS3过渡\n**transition**属性： &nbsp 简写属性，一般需要设置的是变化的属性值和变化时间\n```css\ndiv {\n\twidth: 50px;\n\theigth: 50px;\t\n\ttransition: width 2s;\n}\n\ndiv:hover {\n\twidth: 100px;\n}\n```\n\n### 动画\t\n#### @keyframes 规则（描述CSS动画的中间步骤）\n```css\n@keyframes myAnimate{\n\tfrom {\n\t\tcolor: red;\n\t}\n\tto {\n\t\tcolor: black;\n\t}\n}\n\n@keyframes Second {\n\t0% {\n\t\tbackground-color: red;\n\t}\n\t25% {\n\t\tbackground-color: green;\n\t}\n\t50% {\n\t\tbackground-color: blue;\n\t}\n\t75% {\n\t\tbackground-color: white;\n\t}\n\t100% {\n\t\tbackground-color: black;\n\t}\n}\n```\n\n#### 动画属性\n```css\ndiv {\n\tanimation-name: myAnimate;  /*规定@keyframes 动画的名称*/\n\tanimation-duration: 5s;  /&规定动画完成一个周期所花费的时间*/\n\tanimation-timing-function: ease; /*规定动画的速度曲线 默认为\"ease\"*/\n\tanimation-delay： 100ms； /*表示延迟多久才开始动画*/\n\tanimation-iteration-count: infinite; /*规定播放的次数，默认为1, infinite表示无限循环*/\n\tanimation-direction： alternate； /*规定动画在下一周期是否逆向播放，默认为'normal'*/\n\tanimation-play-state: running; /*规定动画是否在进行中，默认为running*/\n}\n\n/*简写属性*/\n.second {\n\tanimation: Second 5s linear 1s infinite alternate;\n}\n```\n\n## Flex布局\n>阮一峰Flex教程 http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool  \n\n传统的布局解决方案是 display + position + float ,但这种方案要实现垂直居中就很麻烦.\n\nFlex是Flexbile Box的缩写 意思是\"弹性布局\"  \nFlex现在的兼容性就已经很好了,所以可以很安全的使用flex布局而不用怎么考虑浏览器兼容性了.\n### What is Flex?\n任何容器都可以使用flex布局\n```css\n.box {\n    display: flex;\n}\n```\n```css\n/*行内元素也可使用flex布局*/\n.box {\n    display: inline-flex;\n}\n\n```\n**注意:任何使用flex布局的 float,clear,vertical-align的属性将失效**\n\n### Flex基本概念\n\n**Flex Container & Flex item**\n\n采用Flex布局的元素, 称为**Flex Container -> 容器**, 此容器的所有子元素自动成为容器成员,称为**Flex item -> 项目**\n\n<img src=\"http://osuuzm0m8.bkt.clouddn.com/2017-07-10%2011-52-19%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png\">\n\n容器默认存在两根轴,主轴(main axis) & 交叉轴(cross axis) 主轴的开始位置叫做main start 结束位置叫做main end\n同理有 cross start & cross end.项目默认沿主轴排列.  单个项目占据的主轴空间叫做main size,占据的交叉轴空间叫做 cross size .\n\n### 容器的属性\n\n1.   flex-direction 决定主轴的方向 即item的排列方向  \nrow row-reverse column column-reverse  \n2.   flex-wrap \nwrap、nowrap、 wrap-reverse\n3.   flex-flow \nflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap\n4.   justify-content\n5.   align-items\n6.   align-content\n\n### 项目的属性\n+  order 定义项目的排列顺序。数值越小，排列越靠前\n+  flex-grow  定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大.\n+  flex-shrink 定义项目的缩小比例，默认为1，当空间不足时，该项目将缩小。\n+  flex-basis\n+  flex：  flex-grow & flex-shrink & flex-basis的简写，后两个属性可选。\n+  align-self   可覆盖align-item属性\n### 例子\n\n## Canvas\n### What is Canvas？ \n> canvas  标签只有两个属性—— width和height。这些都是可选的，并且同样利用 DOM properties 来设置。当没有设置宽度和高度的时候，canvas会初始化宽度为300像素和高度为150像素。该元素可以使用CSS来定义大小，但在绘制时图像会伸缩以适应它的框架尺寸：如果CSS的尺寸与初始画布的比例不一致，它会出现扭曲。\n\n### 用法\n@(HTML)\n```html\n<body onload = \"draw();\">\n\t<canvas id = \"canvas\" width=\"500\" height=\"500\"></canvas>\n</body>\n```\n@(Js)\n\n```javascript\nfunction draw(){\n\tvar canvas = document.getElementById(\"canvas\"); //获取canvas元素\n\tvar t = canvas.getContext('2d'); //canvas元素的getContext('2d')方法 获得渲染上下文和它的绘画功能\n}\n```\ncanvas的栅格和 坐标空间\n![Markdown](http://i1.buimg.com/1949/e6019cbf5a8745b0.png)\n\n绘制矩形\n```javascript\nt.fillStyle = 'rgba(130,120,244,.5)'; //设置填充样式\nt.strokeStyle = 'rgba(100,200,130,.5)'; //设置描边样式\n\nt.fillRect(50, 50, 30, 30); //绘制一个填充的矩形\nt.strokeRect(75, 75, 30, 30); //绘制一个矩形的边框\n```\n结果如下图\n![Markdown](http://i1.buimg.com/1949/71022b72e3961e1e.png)\n\n### 使用路径\n绘制圆形\n```javascript  \nt.beginPath();\nt.arc(50, 50, 50, 0, Math.PI*2, true);  \n// arc(x, y, radius, startAngle, endAngle, anticlockwise)  anticlockwise默认为true，顺时针 \nt.closePath();\t//关闭路径\nt.fillStyle = 'rgba(231, 142, 56, .5)';  \nt.fill(); //填充\n```\n如图\n![Markdown](http://i1.buimg.com/1949/3a76773b6033b51c.png)\n\n绘制线条\n```javascript  \nt.beginPath();\nt.moveTo(50, 50);\nt.lineTo(50,75);\nt.closePath();\nt.stroke();\n```\n![Markdown](http://i4.piimg.com/1949/50fb206a53c8caf2.png)\n\n其他高级操作自行探索\n\n\n### 清除画布\n\n```\nt.clearRect(0, 0, 500, 500) // （x, y, width, height）\n```\n\n### 利用canvas制作动画\n1.  清空画布\n2.  保存canvas状态\n3.  绘制动画图形\n4.  恢复canvas状态\n\n**使用canvas制作时钟**\n\n\n## LocalStorage\n### What is LocalStorage？\nlocalstorage 是用来存储客户端临时信息H5新特性.\n```\ntypeof(window.localStorage)  //object\n```\nlocalstorage 存储的数据没有时间限制。\n与之对应的sessionStorage 存储的数据当用户关闭浏览器窗口后，数据会被删除。\n他们均只能存储字符串类型.\n```javascript\nvar storage = localStorage;\nstorage.setItem(\"name\",4);  // 写入\nstorage[\"temp\"] = 1;\t\t// 写入\nconsole.log(storage.getItem(\"temp\"));  // 1\nconsole.log(storage[\"name\"]);\t\t// 4\nconsole.log(typeof storage[\"name\"]);  //string\n\n// 删除localStorage的某个键值对\nstorage.removeItem(\"name\")；\nconsole.log(storage);  // { temp: '1', length:1}\n// 将localStorage的所有内容删除\nstorage.clear();      // {}\n```\n\n","source":"_posts/summer-css3-canvas.md","raw":"---\ntitle: CSS3 & H5 Canvas\ncategory: 2017暑假\ntags: [暑假, 夏令营, 2017]\ndate: 2017-07-11\n---\n\n因为需要给大一捞仔们介绍下..CSS和 H5的东西,所以就顺便复习了下这些知识,写成学习记录blog,结合CSS揭秘和MDN,对CSS3的新特性也了解加深了..\n<!-- more -->\n\n## CSS3\n### 选择器\n 参考W3 \n http://www.w3school.com.cn/cssref/css_selectors.asp\n 或者  MDN \n https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference#选择器\n\n### 背景和边框\n+  border-radius\n+  box-shadow\n+  border-image\n#### border-radius\nborder-radius 有四个参数  border-radius(top-left, top-right, bottom-right, bottom-left)\n#### box-shadow\nbox-shadow（inset, offset-x, offset-y, blur-radius, spread-radius, color）\n默认是outset 当第一个参数写了inset之后就变成阴影在边框内，背景之上内容之下。\noffset-x, offset-y 是 水平和垂直的阴影偏移量\nblur-radius  默认为0，边缘锋利，不能为负，值越大，模糊面积越大，阴影就越大越淡\nspread-radius 取正值，阴影扩大，取负值，阴影收缩。默认为0，此时阴影与元素同样大\n#### border-image \n### 文本效果\n+  text-shadow  文本阴影\n+  word-wrap: normal | break-word;  强制文本进行换行\n+   text-overflow: clip | ellipsis | string;   (修剪| 省略号代替溢出的文本 | 使用给定的字符串而不是省略号来代替)\n### @规则\n#### @font-face规则 （使用自定义字体）\n```\n@font-face {\n\tfont-family: myFont;\n\tsrc: url('xxxx.ttf');  //自定义的字体文件路径\n}\n\ndiv {\n\tfont-family: myFont;\n}\n```\n\n#### @media规则 （媒体查询，作用：在不同设备上使用不同的CSS）\n```css\n/*在打印机设备上显示*/\n@media print {\n}\n/*在屏幕上显示*/\n@media screen {\n}\n\n\n/*在700px~1024px的设备上显示以下样式*/\n@media screen and (max-width: 1024px) and (min-width: 700px) {\n}\n```\n\n#### @keyframes规则 （描述CSS动画的中间步骤）放在CSS3动画一起讲\n### CSS3 变形 （2D&3D转换）\n **transform**属性： &nbsp 可以在不影响正常文档流的情况下改变作用内容的位置\n#### 2D转换\n+  translate(x,y)  元素从当前位置分别在水平和垂直移动 x、y 距离\n+  rotate(x deg) 元素顺时针旋转给定的角度。负值时，元素将逆时针旋转\n+  scale(x, y)  把尺寸转为原来的 x、y倍\n+  skew(x deg, y deg) 围绕 X、Y轴翻转 \n+  matrix()   前面的5个的综合\n\n```css \ndiv {\n\ttransform:translate(50px, 100px) || rotate(30deg) || scale(1,2) || skew(20deg, 30deg)\n}\n```\n\n#### 3D转换\n\t1.  rotateX( )  围绕X轴 以给定的度数进行旋转\n\t2.  rotateY( )  围绕Y轴 以给定的度数进行旋转\n\n\n### CSS3过渡\n**transition**属性： &nbsp 简写属性，一般需要设置的是变化的属性值和变化时间\n```css\ndiv {\n\twidth: 50px;\n\theigth: 50px;\t\n\ttransition: width 2s;\n}\n\ndiv:hover {\n\twidth: 100px;\n}\n```\n\n### 动画\t\n#### @keyframes 规则（描述CSS动画的中间步骤）\n```css\n@keyframes myAnimate{\n\tfrom {\n\t\tcolor: red;\n\t}\n\tto {\n\t\tcolor: black;\n\t}\n}\n\n@keyframes Second {\n\t0% {\n\t\tbackground-color: red;\n\t}\n\t25% {\n\t\tbackground-color: green;\n\t}\n\t50% {\n\t\tbackground-color: blue;\n\t}\n\t75% {\n\t\tbackground-color: white;\n\t}\n\t100% {\n\t\tbackground-color: black;\n\t}\n}\n```\n\n#### 动画属性\n```css\ndiv {\n\tanimation-name: myAnimate;  /*规定@keyframes 动画的名称*/\n\tanimation-duration: 5s;  /&规定动画完成一个周期所花费的时间*/\n\tanimation-timing-function: ease; /*规定动画的速度曲线 默认为\"ease\"*/\n\tanimation-delay： 100ms； /*表示延迟多久才开始动画*/\n\tanimation-iteration-count: infinite; /*规定播放的次数，默认为1, infinite表示无限循环*/\n\tanimation-direction： alternate； /*规定动画在下一周期是否逆向播放，默认为'normal'*/\n\tanimation-play-state: running; /*规定动画是否在进行中，默认为running*/\n}\n\n/*简写属性*/\n.second {\n\tanimation: Second 5s linear 1s infinite alternate;\n}\n```\n\n## Flex布局\n>阮一峰Flex教程 http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool  \n\n传统的布局解决方案是 display + position + float ,但这种方案要实现垂直居中就很麻烦.\n\nFlex是Flexbile Box的缩写 意思是\"弹性布局\"  \nFlex现在的兼容性就已经很好了,所以可以很安全的使用flex布局而不用怎么考虑浏览器兼容性了.\n### What is Flex?\n任何容器都可以使用flex布局\n```css\n.box {\n    display: flex;\n}\n```\n```css\n/*行内元素也可使用flex布局*/\n.box {\n    display: inline-flex;\n}\n\n```\n**注意:任何使用flex布局的 float,clear,vertical-align的属性将失效**\n\n### Flex基本概念\n\n**Flex Container & Flex item**\n\n采用Flex布局的元素, 称为**Flex Container -> 容器**, 此容器的所有子元素自动成为容器成员,称为**Flex item -> 项目**\n\n<img src=\"http://osuuzm0m8.bkt.clouddn.com/2017-07-10%2011-52-19%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png\">\n\n容器默认存在两根轴,主轴(main axis) & 交叉轴(cross axis) 主轴的开始位置叫做main start 结束位置叫做main end\n同理有 cross start & cross end.项目默认沿主轴排列.  单个项目占据的主轴空间叫做main size,占据的交叉轴空间叫做 cross size .\n\n### 容器的属性\n\n1.   flex-direction 决定主轴的方向 即item的排列方向  \nrow row-reverse column column-reverse  \n2.   flex-wrap \nwrap、nowrap、 wrap-reverse\n3.   flex-flow \nflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap\n4.   justify-content\n5.   align-items\n6.   align-content\n\n### 项目的属性\n+  order 定义项目的排列顺序。数值越小，排列越靠前\n+  flex-grow  定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大.\n+  flex-shrink 定义项目的缩小比例，默认为1，当空间不足时，该项目将缩小。\n+  flex-basis\n+  flex：  flex-grow & flex-shrink & flex-basis的简写，后两个属性可选。\n+  align-self   可覆盖align-item属性\n### 例子\n\n## Canvas\n### What is Canvas？ \n> canvas  标签只有两个属性—— width和height。这些都是可选的，并且同样利用 DOM properties 来设置。当没有设置宽度和高度的时候，canvas会初始化宽度为300像素和高度为150像素。该元素可以使用CSS来定义大小，但在绘制时图像会伸缩以适应它的框架尺寸：如果CSS的尺寸与初始画布的比例不一致，它会出现扭曲。\n\n### 用法\n@(HTML)\n```html\n<body onload = \"draw();\">\n\t<canvas id = \"canvas\" width=\"500\" height=\"500\"></canvas>\n</body>\n```\n@(Js)\n\n```javascript\nfunction draw(){\n\tvar canvas = document.getElementById(\"canvas\"); //获取canvas元素\n\tvar t = canvas.getContext('2d'); //canvas元素的getContext('2d')方法 获得渲染上下文和它的绘画功能\n}\n```\ncanvas的栅格和 坐标空间\n![Markdown](http://i1.buimg.com/1949/e6019cbf5a8745b0.png)\n\n绘制矩形\n```javascript\nt.fillStyle = 'rgba(130,120,244,.5)'; //设置填充样式\nt.strokeStyle = 'rgba(100,200,130,.5)'; //设置描边样式\n\nt.fillRect(50, 50, 30, 30); //绘制一个填充的矩形\nt.strokeRect(75, 75, 30, 30); //绘制一个矩形的边框\n```\n结果如下图\n![Markdown](http://i1.buimg.com/1949/71022b72e3961e1e.png)\n\n### 使用路径\n绘制圆形\n```javascript  \nt.beginPath();\nt.arc(50, 50, 50, 0, Math.PI*2, true);  \n// arc(x, y, radius, startAngle, endAngle, anticlockwise)  anticlockwise默认为true，顺时针 \nt.closePath();\t//关闭路径\nt.fillStyle = 'rgba(231, 142, 56, .5)';  \nt.fill(); //填充\n```\n如图\n![Markdown](http://i1.buimg.com/1949/3a76773b6033b51c.png)\n\n绘制线条\n```javascript  \nt.beginPath();\nt.moveTo(50, 50);\nt.lineTo(50,75);\nt.closePath();\nt.stroke();\n```\n![Markdown](http://i4.piimg.com/1949/50fb206a53c8caf2.png)\n\n其他高级操作自行探索\n\n\n### 清除画布\n\n```\nt.clearRect(0, 0, 500, 500) // （x, y, width, height）\n```\n\n### 利用canvas制作动画\n1.  清空画布\n2.  保存canvas状态\n3.  绘制动画图形\n4.  恢复canvas状态\n\n**使用canvas制作时钟**\n\n\n## LocalStorage\n### What is LocalStorage？\nlocalstorage 是用来存储客户端临时信息H5新特性.\n```\ntypeof(window.localStorage)  //object\n```\nlocalstorage 存储的数据没有时间限制。\n与之对应的sessionStorage 存储的数据当用户关闭浏览器窗口后，数据会被删除。\n他们均只能存储字符串类型.\n```javascript\nvar storage = localStorage;\nstorage.setItem(\"name\",4);  // 写入\nstorage[\"temp\"] = 1;\t\t// 写入\nconsole.log(storage.getItem(\"temp\"));  // 1\nconsole.log(storage[\"name\"]);\t\t// 4\nconsole.log(typeof storage[\"name\"]);  //string\n\n// 删除localStorage的某个键值对\nstorage.removeItem(\"name\")；\nconsole.log(storage);  // { temp: '1', length:1}\n// 将localStorage的所有内容删除\nstorage.clear();      // {}\n```\n\n","slug":"summer-css3-canvas","published":1,"updated":"2017-07-17T05:14:42.285Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf81eh93001bv4efahyy8okn","content":"<p>因为需要给大一捞仔们介绍下..CSS和 H5的东西,所以就顺便复习了下这些知识,写成学习记录blog,结合CSS揭秘和MDN,对CSS3的新特性也了解加深了..<br><a id=\"more\"></a></p>\n<h2 id=\"CSS3\"><a href=\"#CSS3\" class=\"headerlink\" title=\"CSS3\"></a>CSS3</h2><h3 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h3><p> 参考W3<br> <a href=\"http://www.w3school.com.cn/cssref/css_selectors.asp\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/cssref/css_selectors.asp</a><br> 或者  MDN<br> <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference#选择器\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference#选择器</a></p>\n<h3 id=\"背景和边框\"><a href=\"#背景和边框\" class=\"headerlink\" title=\"背景和边框\"></a>背景和边框</h3><ul>\n<li>border-radius</li>\n<li>box-shadow</li>\n<li>border-image<h4 id=\"border-radius\"><a href=\"#border-radius\" class=\"headerlink\" title=\"border-radius\"></a>border-radius</h4>border-radius 有四个参数  border-radius(top-left, top-right, bottom-right, bottom-left)<h4 id=\"box-shadow\"><a href=\"#box-shadow\" class=\"headerlink\" title=\"box-shadow\"></a>box-shadow</h4>box-shadow（inset, offset-x, offset-y, blur-radius, spread-radius, color）<br>默认是outset 当第一个参数写了inset之后就变成阴影在边框内，背景之上内容之下。<br>offset-x, offset-y 是 水平和垂直的阴影偏移量<br>blur-radius  默认为0，边缘锋利，不能为负，值越大，模糊面积越大，阴影就越大越淡<br>spread-radius 取正值，阴影扩大，取负值，阴影收缩。默认为0，此时阴影与元素同样大<h4 id=\"border-image\"><a href=\"#border-image\" class=\"headerlink\" title=\"border-image\"></a>border-image</h4><h3 id=\"文本效果\"><a href=\"#文本效果\" class=\"headerlink\" title=\"文本效果\"></a>文本效果</h3></li>\n<li>text-shadow  文本阴影</li>\n<li>word-wrap: normal | break-word;  强制文本进行换行</li>\n<li>text-overflow: clip | ellipsis | string;   (修剪| 省略号代替溢出的文本 | 使用给定的字符串而不是省略号来代替)<h3 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"@规则\"></a>@规则</h3><h4 id=\"font-face规则-（使用自定义字体）\"><a href=\"#font-face规则-（使用自定义字体）\" class=\"headerlink\" title=\"@font-face规则 （使用自定义字体）\"></a>@font-face规则 （使用自定义字体）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@font-face &#123;</span><br><span class=\"line\">\tfont-family: myFont;</span><br><span class=\"line\">\tsrc: url(&apos;xxxx.ttf&apos;);  //自定义的字体文件路径</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">\tfont-family: myFont;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"media规则-（媒体查询，作用：在不同设备上使用不同的CSS）\"><a href=\"#media规则-（媒体查询，作用：在不同设备上使用不同的CSS）\" class=\"headerlink\" title=\"@media规则 （媒体查询，作用：在不同设备上使用不同的CSS）\"></a>@media规则 （媒体查询，作用：在不同设备上使用不同的CSS）</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*在打印机设备上显示*/</span></span><br><span class=\"line\">@<span class=\"keyword\">media</span> print &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*在屏幕上显示*/</span></span><br><span class=\"line\">@<span class=\"keyword\">media</span> screen &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*在700px~1024px的设备上显示以下样式*/</span></span><br><span class=\"line\">@<span class=\"keyword\">media</span> screen and (max-width: <span class=\"number\">1024px</span>) and (min-width: <span class=\"number\">700px</span>) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"keyframes规则-（描述CSS动画的中间步骤）放在CSS3动画一起讲\"><a href=\"#keyframes规则-（描述CSS动画的中间步骤）放在CSS3动画一起讲\" class=\"headerlink\" title=\"@keyframes规则 （描述CSS动画的中间步骤）放在CSS3动画一起讲\"></a>@keyframes规则 （描述CSS动画的中间步骤）放在CSS3动画一起讲</h4><h3 id=\"CSS3-变形-（2D-amp-3D转换）\"><a href=\"#CSS3-变形-（2D-amp-3D转换）\" class=\"headerlink\" title=\"CSS3 变形 （2D&amp;3D转换）\"></a>CSS3 变形 （2D&amp;3D转换）</h3><p> <strong>transform</strong>属性： &amp;nbsp 可以在不影响正常文档流的情况下改变作用内容的位置</p>\n<h4 id=\"2D转换\"><a href=\"#2D转换\" class=\"headerlink\" title=\"2D转换\"></a>2D转换</h4><ul>\n<li>translate(x,y)  元素从当前位置分别在水平和垂直移动 x、y 距离</li>\n<li>rotate(x deg) 元素顺时针旋转给定的角度。负值时，元素将逆时针旋转</li>\n<li>scale(x, y)  把尺寸转为原来的 x、y倍</li>\n<li>skew(x deg, y deg) 围绕 X、Y轴翻转 </li>\n<li>matrix()   前面的5个的综合</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">transform</span>:<span class=\"built_in\">translate</span>(50px, 100px) || <span class=\"built_in\">rotate</span>(30deg) || <span class=\"built_in\">scale</span>(1,2) || <span class=\"built_in\">skew</span>(20deg, 30deg)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3D转换\"><a href=\"#3D转换\" class=\"headerlink\" title=\"3D转换\"></a>3D转换</h4><pre><code>1.  rotateX( )  围绕X轴 以给定的度数进行旋转\n2.  rotateY( )  围绕Y轴 以给定的度数进行旋转\n</code></pre><h3 id=\"CSS3过渡\"><a href=\"#CSS3过渡\" class=\"headerlink\" title=\"CSS3过渡\"></a>CSS3过渡</h3><p><strong>transition</strong>属性： &amp;nbsp 简写属性，一般需要设置的是变化的属性值和变化时间<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">heigth</span>: <span class=\"number\">50px</span>;\t</span><br><span class=\"line\">\t<span class=\"attribute\">transition</span>: width <span class=\"number\">2s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">div</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h3><h4 id=\"keyframes-规则（描述CSS动画的中间步骤）\"><a href=\"#keyframes-规则（描述CSS动画的中间步骤）\" class=\"headerlink\" title=\"@keyframes 规则（描述CSS动画的中间步骤）\"></a>@keyframes 规则（描述CSS动画的中间步骤）</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">keyframes</span> myAnimate&#123;</span><br><span class=\"line\">\t<span class=\"selector-tag\">from</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"selector-tag\">to</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">color</span>: black;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> Second &#123;</span><br><span class=\"line\">\t0% &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t25% &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background-color</span>: green;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t50% &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background-color</span>: blue;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t75% &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background-color</span>: white;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t100% &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background-color</span>: black;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"动画属性\"><a href=\"#动画属性\" class=\"headerlink\" title=\"动画属性\"></a>动画属性</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">animation-name</span>: myAnimate;  <span class=\"comment\">/*规定@keyframes 动画的名称*/</span></span><br><span class=\"line\">\tanimation-duration: 5s;  /&amp;规定动画完成一个周期所花费的时间*/</span><br><span class=\"line\">\t<span class=\"selector-tag\">animation-timing-function</span>: <span class=\"selector-tag\">ease</span>; <span class=\"comment\">/*规定动画的速度曲线 默认为\"ease\"*/</span></span><br><span class=\"line\">\t<span class=\"selector-tag\">animation-delay</span>： 100<span class=\"selector-tag\">ms</span>； <span class=\"comment\">/*表示延迟多久才开始动画*/</span></span><br><span class=\"line\">\t<span class=\"selector-tag\">animation-iteration-count</span>: <span class=\"selector-tag\">infinite</span>; <span class=\"comment\">/*规定播放的次数，默认为1, infinite表示无限循环*/</span></span><br><span class=\"line\">\t<span class=\"selector-tag\">animation-direction</span>： <span class=\"selector-tag\">alternate</span>； <span class=\"comment\">/*规定动画在下一周期是否逆向播放，默认为'normal'*/</span></span><br><span class=\"line\">\t<span class=\"selector-tag\">animation-play-state</span>: <span class=\"selector-tag\">running</span>; <span class=\"comment\">/*规定动画是否在进行中，默认为running*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*简写属性*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.second</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">animation</span>: Second <span class=\"number\">5s</span> linear <span class=\"number\">1s</span> infinite alternate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Flex布局\"><a href=\"#Flex布局\" class=\"headerlink\" title=\"Flex布局\"></a>Flex布局</h2><blockquote>\n<p>阮一峰Flex教程 <a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool</a>  </p>\n</blockquote>\n<p>传统的布局解决方案是 display + position + float ,但这种方案要实现垂直居中就很麻烦.</p>\n<p>Flex是Flexbile Box的缩写 意思是”弹性布局”<br>Flex现在的兼容性就已经很好了,所以可以很安全的使用flex布局而不用怎么考虑浏览器兼容性了.</p>\n<h3 id=\"What-is-Flex\"><a href=\"#What-is-Flex\" class=\"headerlink\" title=\"What is Flex?\"></a>What is Flex?</h3><p>任何容器都可以使用flex布局<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*行内元素也可使用flex布局*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline-flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意:任何使用flex布局的 float,clear,vertical-align的属性将失效</strong></p>\n<h3 id=\"Flex基本概念\"><a href=\"#Flex基本概念\" class=\"headerlink\" title=\"Flex基本概念\"></a>Flex基本概念</h3><p><strong>Flex Container &amp; Flex item</strong></p>\n<p>采用Flex布局的元素, 称为<strong>Flex Container -&gt; 容器</strong>, 此容器的所有子元素自动成为容器成员,称为<strong>Flex item -&gt; 项目</strong></p>\n<p><img src=\"http://osuuzm0m8.bkt.clouddn.com/2017-07-10%2011-52-19%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png\"></p>\n<p>容器默认存在两根轴,主轴(main axis) &amp; 交叉轴(cross axis) 主轴的开始位置叫做main start 结束位置叫做main end<br>同理有 cross start &amp; cross end.项目默认沿主轴排列.  单个项目占据的主轴空间叫做main size,占据的交叉轴空间叫做 cross size .</p>\n<h3 id=\"容器的属性\"><a href=\"#容器的属性\" class=\"headerlink\" title=\"容器的属性\"></a>容器的属性</h3><ol>\n<li>flex-direction 决定主轴的方向 即item的排列方向<br>row row-reverse column column-reverse  </li>\n<li>flex-wrap<br>wrap、nowrap、 wrap-reverse</li>\n<li>flex-flow<br>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</li>\n<li>justify-content</li>\n<li>align-items</li>\n<li>align-content</li>\n</ol>\n<h3 id=\"项目的属性\"><a href=\"#项目的属性\" class=\"headerlink\" title=\"项目的属性\"></a>项目的属性</h3><ul>\n<li>order 定义项目的排列顺序。数值越小，排列越靠前</li>\n<li>flex-grow  定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大.</li>\n<li>flex-shrink 定义项目的缩小比例，默认为1，当空间不足时，该项目将缩小。</li>\n<li>flex-basis</li>\n<li>flex：  flex-grow &amp; flex-shrink &amp; flex-basis的简写，后两个属性可选。</li>\n<li>align-self   可覆盖align-item属性<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3></li>\n</ul>\n<h2 id=\"Canvas\"><a href=\"#Canvas\" class=\"headerlink\" title=\"Canvas\"></a>Canvas</h2><h3 id=\"What-is-Canvas？\"><a href=\"#What-is-Canvas？\" class=\"headerlink\" title=\"What is Canvas？\"></a>What is Canvas？</h3><blockquote>\n<p>canvas  标签只有两个属性—— width和height。这些都是可选的，并且同样利用 DOM properties 来设置。当没有设置宽度和高度的时候，canvas会初始化宽度为300像素和高度为150像素。该元素可以使用CSS来定义大小，但在绘制时图像会伸缩以适应它的框架尺寸：如果CSS的尺寸与初始画布的比例不一致，它会出现扭曲。</p>\n</blockquote>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p>@(HTML)<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">onload</span> = <span class=\"string\">\"draw();\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">id</span> = <span class=\"string\">\"canvas\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"500\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"500\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>@(Js)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">draw</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"canvas\"</span>); <span class=\"comment\">//获取canvas元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> t = canvas.getContext(<span class=\"string\">'2d'</span>); <span class=\"comment\">//canvas元素的getContext('2d')方法 获得渲染上下文和它的绘画功能</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>canvas的栅格和 坐标空间<br><img src=\"http://i1.buimg.com/1949/e6019cbf5a8745b0.png\" alt=\"Markdown\"></p>\n<p>绘制矩形<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t.fillStyle = <span class=\"string\">'rgba(130,120,244,.5)'</span>; <span class=\"comment\">//设置填充样式</span></span><br><span class=\"line\">t.strokeStyle = <span class=\"string\">'rgba(100,200,130,.5)'</span>; <span class=\"comment\">//设置描边样式</span></span><br><span class=\"line\"></span><br><span class=\"line\">t.fillRect(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">30</span>, <span class=\"number\">30</span>); <span class=\"comment\">//绘制一个填充的矩形</span></span><br><span class=\"line\">t.strokeRect(<span class=\"number\">75</span>, <span class=\"number\">75</span>, <span class=\"number\">30</span>, <span class=\"number\">30</span>); <span class=\"comment\">//绘制一个矩形的边框</span></span><br></pre></td></tr></table></figure></p>\n<p>结果如下图<br><img src=\"http://i1.buimg.com/1949/71022b72e3961e1e.png\" alt=\"Markdown\"></p>\n<h3 id=\"使用路径\"><a href=\"#使用路径\" class=\"headerlink\" title=\"使用路径\"></a>使用路径</h3><p>绘制圆形<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t.beginPath();</span><br><span class=\"line\">t.arc(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">0</span>, <span class=\"built_in\">Math</span>.PI*<span class=\"number\">2</span>, <span class=\"literal\">true</span>);  </span><br><span class=\"line\"><span class=\"comment\">// arc(x, y, radius, startAngle, endAngle, anticlockwise)  anticlockwise默认为true，顺时针 </span></span><br><span class=\"line\">t.closePath();\t<span class=\"comment\">//关闭路径</span></span><br><span class=\"line\">t.fillStyle = <span class=\"string\">'rgba(231, 142, 56, .5)'</span>;  </span><br><span class=\"line\">t.fill(); <span class=\"comment\">//填充</span></span><br></pre></td></tr></table></figure></p>\n<p>如图<br><img src=\"http://i1.buimg.com/1949/3a76773b6033b51c.png\" alt=\"Markdown\"></p>\n<p>绘制线条<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t.beginPath();</span><br><span class=\"line\">t.moveTo(<span class=\"number\">50</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">t.lineTo(<span class=\"number\">50</span>,<span class=\"number\">75</span>);</span><br><span class=\"line\">t.closePath();</span><br><span class=\"line\">t.stroke();</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://i4.piimg.com/1949/50fb206a53c8caf2.png\" alt=\"Markdown\"></p>\n<p>其他高级操作自行探索</p>\n<h3 id=\"清除画布\"><a href=\"#清除画布\" class=\"headerlink\" title=\"清除画布\"></a>清除画布</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t.clearRect(0, 0, 500, 500) // （x, y, width, height）</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用canvas制作动画\"><a href=\"#利用canvas制作动画\" class=\"headerlink\" title=\"利用canvas制作动画\"></a>利用canvas制作动画</h3><ol>\n<li>清空画布</li>\n<li>保存canvas状态</li>\n<li>绘制动画图形</li>\n<li>恢复canvas状态</li>\n</ol>\n<p><strong>使用canvas制作时钟</strong></p>\n<h2 id=\"LocalStorage\"><a href=\"#LocalStorage\" class=\"headerlink\" title=\"LocalStorage\"></a>LocalStorage</h2><h3 id=\"What-is-LocalStorage？\"><a href=\"#What-is-LocalStorage？\" class=\"headerlink\" title=\"What is LocalStorage？\"></a>What is LocalStorage？</h3><p>localstorage 是用来存储客户端临时信息H5新特性.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof(window.localStorage)  //object</span><br></pre></td></tr></table></figure></p>\n<p>localstorage 存储的数据没有时间限制。<br>与之对应的sessionStorage 存储的数据当用户关闭浏览器窗口后，数据会被删除。<br>他们均只能存储字符串类型.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> storage = localStorage;</span><br><span class=\"line\">storage.setItem(<span class=\"string\">\"name\"</span>,<span class=\"number\">4</span>);  <span class=\"comment\">// 写入</span></span><br><span class=\"line\">storage[<span class=\"string\">\"temp\"</span>] = <span class=\"number\">1</span>;\t\t<span class=\"comment\">// 写入</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(storage.getItem(<span class=\"string\">\"temp\"</span>));  <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(storage[<span class=\"string\">\"name\"</span>]);\t\t<span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> storage[<span class=\"string\">\"name\"</span>]);  <span class=\"comment\">//string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除localStorage的某个键值对</span></span><br><span class=\"line\">storage.removeItem(<span class=\"string\">\"name\"</span>)；</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(storage);  <span class=\"comment\">// &#123; temp: '1', length:1&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 将localStorage的所有内容删除</span></span><br><span class=\"line\">storage.clear();      <span class=\"comment\">// &#123;&#125;</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>因为需要给大一捞仔们介绍下..CSS和 H5的东西,所以就顺便复习了下这些知识,写成学习记录blog,结合CSS揭秘和MDN,对CSS3的新特性也了解加深了..<br>","more":"</p>\n<h2 id=\"CSS3\"><a href=\"#CSS3\" class=\"headerlink\" title=\"CSS3\"></a>CSS3</h2><h3 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h3><p> 参考W3<br> <a href=\"http://www.w3school.com.cn/cssref/css_selectors.asp\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/cssref/css_selectors.asp</a><br> 或者  MDN<br> <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference#选择器\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference#选择器</a></p>\n<h3 id=\"背景和边框\"><a href=\"#背景和边框\" class=\"headerlink\" title=\"背景和边框\"></a>背景和边框</h3><ul>\n<li>border-radius</li>\n<li>box-shadow</li>\n<li>border-image<h4 id=\"border-radius\"><a href=\"#border-radius\" class=\"headerlink\" title=\"border-radius\"></a>border-radius</h4>border-radius 有四个参数  border-radius(top-left, top-right, bottom-right, bottom-left)<h4 id=\"box-shadow\"><a href=\"#box-shadow\" class=\"headerlink\" title=\"box-shadow\"></a>box-shadow</h4>box-shadow（inset, offset-x, offset-y, blur-radius, spread-radius, color）<br>默认是outset 当第一个参数写了inset之后就变成阴影在边框内，背景之上内容之下。<br>offset-x, offset-y 是 水平和垂直的阴影偏移量<br>blur-radius  默认为0，边缘锋利，不能为负，值越大，模糊面积越大，阴影就越大越淡<br>spread-radius 取正值，阴影扩大，取负值，阴影收缩。默认为0，此时阴影与元素同样大<h4 id=\"border-image\"><a href=\"#border-image\" class=\"headerlink\" title=\"border-image\"></a>border-image</h4><h3 id=\"文本效果\"><a href=\"#文本效果\" class=\"headerlink\" title=\"文本效果\"></a>文本效果</h3></li>\n<li>text-shadow  文本阴影</li>\n<li>word-wrap: normal | break-word;  强制文本进行换行</li>\n<li>text-overflow: clip | ellipsis | string;   (修剪| 省略号代替溢出的文本 | 使用给定的字符串而不是省略号来代替)<h3 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"@规则\"></a>@规则</h3><h4 id=\"font-face规则-（使用自定义字体）\"><a href=\"#font-face规则-（使用自定义字体）\" class=\"headerlink\" title=\"@font-face规则 （使用自定义字体）\"></a>@font-face规则 （使用自定义字体）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@font-face &#123;</span><br><span class=\"line\">\tfont-family: myFont;</span><br><span class=\"line\">\tsrc: url(&apos;xxxx.ttf&apos;);  //自定义的字体文件路径</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">\tfont-family: myFont;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"media规则-（媒体查询，作用：在不同设备上使用不同的CSS）\"><a href=\"#media规则-（媒体查询，作用：在不同设备上使用不同的CSS）\" class=\"headerlink\" title=\"@media规则 （媒体查询，作用：在不同设备上使用不同的CSS）\"></a>@media规则 （媒体查询，作用：在不同设备上使用不同的CSS）</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*在打印机设备上显示*/</span></span><br><span class=\"line\">@<span class=\"keyword\">media</span> print &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*在屏幕上显示*/</span></span><br><span class=\"line\">@<span class=\"keyword\">media</span> screen &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*在700px~1024px的设备上显示以下样式*/</span></span><br><span class=\"line\">@<span class=\"keyword\">media</span> screen and (max-width: <span class=\"number\">1024px</span>) and (min-width: <span class=\"number\">700px</span>) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"keyframes规则-（描述CSS动画的中间步骤）放在CSS3动画一起讲\"><a href=\"#keyframes规则-（描述CSS动画的中间步骤）放在CSS3动画一起讲\" class=\"headerlink\" title=\"@keyframes规则 （描述CSS动画的中间步骤）放在CSS3动画一起讲\"></a>@keyframes规则 （描述CSS动画的中间步骤）放在CSS3动画一起讲</h4><h3 id=\"CSS3-变形-（2D-amp-3D转换）\"><a href=\"#CSS3-变形-（2D-amp-3D转换）\" class=\"headerlink\" title=\"CSS3 变形 （2D&amp;3D转换）\"></a>CSS3 变形 （2D&amp;3D转换）</h3><p> <strong>transform</strong>属性： &amp;nbsp 可以在不影响正常文档流的情况下改变作用内容的位置</p>\n<h4 id=\"2D转换\"><a href=\"#2D转换\" class=\"headerlink\" title=\"2D转换\"></a>2D转换</h4><ul>\n<li>translate(x,y)  元素从当前位置分别在水平和垂直移动 x、y 距离</li>\n<li>rotate(x deg) 元素顺时针旋转给定的角度。负值时，元素将逆时针旋转</li>\n<li>scale(x, y)  把尺寸转为原来的 x、y倍</li>\n<li>skew(x deg, y deg) 围绕 X、Y轴翻转 </li>\n<li>matrix()   前面的5个的综合</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">transform</span>:<span class=\"built_in\">translate</span>(50px, 100px) || <span class=\"built_in\">rotate</span>(30deg) || <span class=\"built_in\">scale</span>(1,2) || <span class=\"built_in\">skew</span>(20deg, 30deg)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3D转换\"><a href=\"#3D转换\" class=\"headerlink\" title=\"3D转换\"></a>3D转换</h4><pre><code>1.  rotateX( )  围绕X轴 以给定的度数进行旋转\n2.  rotateY( )  围绕Y轴 以给定的度数进行旋转\n</code></pre><h3 id=\"CSS3过渡\"><a href=\"#CSS3过渡\" class=\"headerlink\" title=\"CSS3过渡\"></a>CSS3过渡</h3><p><strong>transition</strong>属性： &amp;nbsp 简写属性，一般需要设置的是变化的属性值和变化时间<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">heigth</span>: <span class=\"number\">50px</span>;\t</span><br><span class=\"line\">\t<span class=\"attribute\">transition</span>: width <span class=\"number\">2s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">div</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h3><h4 id=\"keyframes-规则（描述CSS动画的中间步骤）\"><a href=\"#keyframes-规则（描述CSS动画的中间步骤）\" class=\"headerlink\" title=\"@keyframes 规则（描述CSS动画的中间步骤）\"></a>@keyframes 规则（描述CSS动画的中间步骤）</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">keyframes</span> myAnimate&#123;</span><br><span class=\"line\">\t<span class=\"selector-tag\">from</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"selector-tag\">to</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">color</span>: black;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> Second &#123;</span><br><span class=\"line\">\t0% &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t25% &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background-color</span>: green;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t50% &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background-color</span>: blue;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t75% &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background-color</span>: white;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t100% &#123;</span><br><span class=\"line\">\t\t<span class=\"attribute\">background-color</span>: black;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"动画属性\"><a href=\"#动画属性\" class=\"headerlink\" title=\"动画属性\"></a>动画属性</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">animation-name</span>: myAnimate;  <span class=\"comment\">/*规定@keyframes 动画的名称*/</span></span><br><span class=\"line\">\tanimation-duration: 5s;  /&amp;规定动画完成一个周期所花费的时间*/</span><br><span class=\"line\">\t<span class=\"selector-tag\">animation-timing-function</span>: <span class=\"selector-tag\">ease</span>; <span class=\"comment\">/*规定动画的速度曲线 默认为\"ease\"*/</span></span><br><span class=\"line\">\t<span class=\"selector-tag\">animation-delay</span>： 100<span class=\"selector-tag\">ms</span>； <span class=\"comment\">/*表示延迟多久才开始动画*/</span></span><br><span class=\"line\">\t<span class=\"selector-tag\">animation-iteration-count</span>: <span class=\"selector-tag\">infinite</span>; <span class=\"comment\">/*规定播放的次数，默认为1, infinite表示无限循环*/</span></span><br><span class=\"line\">\t<span class=\"selector-tag\">animation-direction</span>： <span class=\"selector-tag\">alternate</span>； <span class=\"comment\">/*规定动画在下一周期是否逆向播放，默认为'normal'*/</span></span><br><span class=\"line\">\t<span class=\"selector-tag\">animation-play-state</span>: <span class=\"selector-tag\">running</span>; <span class=\"comment\">/*规定动画是否在进行中，默认为running*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*简写属性*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.second</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">animation</span>: Second <span class=\"number\">5s</span> linear <span class=\"number\">1s</span> infinite alternate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Flex布局\"><a href=\"#Flex布局\" class=\"headerlink\" title=\"Flex布局\"></a>Flex布局</h2><blockquote>\n<p>阮一峰Flex教程 <a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool</a>  </p>\n</blockquote>\n<p>传统的布局解决方案是 display + position + float ,但这种方案要实现垂直居中就很麻烦.</p>\n<p>Flex是Flexbile Box的缩写 意思是”弹性布局”<br>Flex现在的兼容性就已经很好了,所以可以很安全的使用flex布局而不用怎么考虑浏览器兼容性了.</p>\n<h3 id=\"What-is-Flex\"><a href=\"#What-is-Flex\" class=\"headerlink\" title=\"What is Flex?\"></a>What is Flex?</h3><p>任何容器都可以使用flex布局<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*行内元素也可使用flex布局*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline-flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意:任何使用flex布局的 float,clear,vertical-align的属性将失效</strong></p>\n<h3 id=\"Flex基本概念\"><a href=\"#Flex基本概念\" class=\"headerlink\" title=\"Flex基本概念\"></a>Flex基本概念</h3><p><strong>Flex Container &amp; Flex item</strong></p>\n<p>采用Flex布局的元素, 称为<strong>Flex Container -&gt; 容器</strong>, 此容器的所有子元素自动成为容器成员,称为<strong>Flex item -&gt; 项目</strong></p>\n<p><img src=\"http://osuuzm0m8.bkt.clouddn.com/2017-07-10%2011-52-19%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png\"></p>\n<p>容器默认存在两根轴,主轴(main axis) &amp; 交叉轴(cross axis) 主轴的开始位置叫做main start 结束位置叫做main end<br>同理有 cross start &amp; cross end.项目默认沿主轴排列.  单个项目占据的主轴空间叫做main size,占据的交叉轴空间叫做 cross size .</p>\n<h3 id=\"容器的属性\"><a href=\"#容器的属性\" class=\"headerlink\" title=\"容器的属性\"></a>容器的属性</h3><ol>\n<li>flex-direction 决定主轴的方向 即item的排列方向<br>row row-reverse column column-reverse  </li>\n<li>flex-wrap<br>wrap、nowrap、 wrap-reverse</li>\n<li>flex-flow<br>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</li>\n<li>justify-content</li>\n<li>align-items</li>\n<li>align-content</li>\n</ol>\n<h3 id=\"项目的属性\"><a href=\"#项目的属性\" class=\"headerlink\" title=\"项目的属性\"></a>项目的属性</h3><ul>\n<li>order 定义项目的排列顺序。数值越小，排列越靠前</li>\n<li>flex-grow  定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大.</li>\n<li>flex-shrink 定义项目的缩小比例，默认为1，当空间不足时，该项目将缩小。</li>\n<li>flex-basis</li>\n<li>flex：  flex-grow &amp; flex-shrink &amp; flex-basis的简写，后两个属性可选。</li>\n<li>align-self   可覆盖align-item属性<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3></li>\n</ul>\n<h2 id=\"Canvas\"><a href=\"#Canvas\" class=\"headerlink\" title=\"Canvas\"></a>Canvas</h2><h3 id=\"What-is-Canvas？\"><a href=\"#What-is-Canvas？\" class=\"headerlink\" title=\"What is Canvas？\"></a>What is Canvas？</h3><blockquote>\n<p>canvas  标签只有两个属性—— width和height。这些都是可选的，并且同样利用 DOM properties 来设置。当没有设置宽度和高度的时候，canvas会初始化宽度为300像素和高度为150像素。该元素可以使用CSS来定义大小，但在绘制时图像会伸缩以适应它的框架尺寸：如果CSS的尺寸与初始画布的比例不一致，它会出现扭曲。</p>\n</blockquote>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p>@(HTML)<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">onload</span> = <span class=\"string\">\"draw();\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">id</span> = <span class=\"string\">\"canvas\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"500\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"500\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>@(Js)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">draw</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"canvas\"</span>); <span class=\"comment\">//获取canvas元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> t = canvas.getContext(<span class=\"string\">'2d'</span>); <span class=\"comment\">//canvas元素的getContext('2d')方法 获得渲染上下文和它的绘画功能</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>canvas的栅格和 坐标空间<br><img src=\"http://i1.buimg.com/1949/e6019cbf5a8745b0.png\" alt=\"Markdown\"></p>\n<p>绘制矩形<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t.fillStyle = <span class=\"string\">'rgba(130,120,244,.5)'</span>; <span class=\"comment\">//设置填充样式</span></span><br><span class=\"line\">t.strokeStyle = <span class=\"string\">'rgba(100,200,130,.5)'</span>; <span class=\"comment\">//设置描边样式</span></span><br><span class=\"line\"></span><br><span class=\"line\">t.fillRect(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">30</span>, <span class=\"number\">30</span>); <span class=\"comment\">//绘制一个填充的矩形</span></span><br><span class=\"line\">t.strokeRect(<span class=\"number\">75</span>, <span class=\"number\">75</span>, <span class=\"number\">30</span>, <span class=\"number\">30</span>); <span class=\"comment\">//绘制一个矩形的边框</span></span><br></pre></td></tr></table></figure></p>\n<p>结果如下图<br><img src=\"http://i1.buimg.com/1949/71022b72e3961e1e.png\" alt=\"Markdown\"></p>\n<h3 id=\"使用路径\"><a href=\"#使用路径\" class=\"headerlink\" title=\"使用路径\"></a>使用路径</h3><p>绘制圆形<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t.beginPath();</span><br><span class=\"line\">t.arc(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">0</span>, <span class=\"built_in\">Math</span>.PI*<span class=\"number\">2</span>, <span class=\"literal\">true</span>);  </span><br><span class=\"line\"><span class=\"comment\">// arc(x, y, radius, startAngle, endAngle, anticlockwise)  anticlockwise默认为true，顺时针 </span></span><br><span class=\"line\">t.closePath();\t<span class=\"comment\">//关闭路径</span></span><br><span class=\"line\">t.fillStyle = <span class=\"string\">'rgba(231, 142, 56, .5)'</span>;  </span><br><span class=\"line\">t.fill(); <span class=\"comment\">//填充</span></span><br></pre></td></tr></table></figure></p>\n<p>如图<br><img src=\"http://i1.buimg.com/1949/3a76773b6033b51c.png\" alt=\"Markdown\"></p>\n<p>绘制线条<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t.beginPath();</span><br><span class=\"line\">t.moveTo(<span class=\"number\">50</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">t.lineTo(<span class=\"number\">50</span>,<span class=\"number\">75</span>);</span><br><span class=\"line\">t.closePath();</span><br><span class=\"line\">t.stroke();</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://i4.piimg.com/1949/50fb206a53c8caf2.png\" alt=\"Markdown\"></p>\n<p>其他高级操作自行探索</p>\n<h3 id=\"清除画布\"><a href=\"#清除画布\" class=\"headerlink\" title=\"清除画布\"></a>清除画布</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t.clearRect(0, 0, 500, 500) // （x, y, width, height）</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用canvas制作动画\"><a href=\"#利用canvas制作动画\" class=\"headerlink\" title=\"利用canvas制作动画\"></a>利用canvas制作动画</h3><ol>\n<li>清空画布</li>\n<li>保存canvas状态</li>\n<li>绘制动画图形</li>\n<li>恢复canvas状态</li>\n</ol>\n<p><strong>使用canvas制作时钟</strong></p>\n<h2 id=\"LocalStorage\"><a href=\"#LocalStorage\" class=\"headerlink\" title=\"LocalStorage\"></a>LocalStorage</h2><h3 id=\"What-is-LocalStorage？\"><a href=\"#What-is-LocalStorage？\" class=\"headerlink\" title=\"What is LocalStorage？\"></a>What is LocalStorage？</h3><p>localstorage 是用来存储客户端临时信息H5新特性.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof(window.localStorage)  //object</span><br></pre></td></tr></table></figure></p>\n<p>localstorage 存储的数据没有时间限制。<br>与之对应的sessionStorage 存储的数据当用户关闭浏览器窗口后，数据会被删除。<br>他们均只能存储字符串类型.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> storage = localStorage;</span><br><span class=\"line\">storage.setItem(<span class=\"string\">\"name\"</span>,<span class=\"number\">4</span>);  <span class=\"comment\">// 写入</span></span><br><span class=\"line\">storage[<span class=\"string\">\"temp\"</span>] = <span class=\"number\">1</span>;\t\t<span class=\"comment\">// 写入</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(storage.getItem(<span class=\"string\">\"temp\"</span>));  <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(storage[<span class=\"string\">\"name\"</span>]);\t\t<span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> storage[<span class=\"string\">\"name\"</span>]);  <span class=\"comment\">//string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除localStorage的某个键值对</span></span><br><span class=\"line\">storage.removeItem(<span class=\"string\">\"name\"</span>)；</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(storage);  <span class=\"comment\">// &#123; temp: '1', length:1&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 将localStorage的所有内容删除</span></span><br><span class=\"line\">storage.clear();      <span class=\"comment\">// &#123;&#125;</span></span><br></pre></td></tr></table></figure></p>"},{"title":"webpack笔记","date":"2017-07-24T16:00:00.000Z","_content":"\n这几天学习下了webpack,也做了demo,大概也了解webpack如何配置了...此篇是学习笔记...为了巩固刚学的知识..\n<!-- more -->\n这次使用的是webpack的新版本3.x\n\n## 安装\n新建一个文件夹， 使用`npm init` 快速配置package.json\n\n文件目录是这样的... src用来放资源文件, build用来放打包后的文件. \n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fhyoffw4egj206w0ayglx.jpg)\n\n### 安装 webpack\n\n安装webpack & webpack-dev-server\n```bash\nnpm install webpack webpack-dev-server--save-v\n```\n\n安装webpack-dev-server（开发服务器)用于开发，便于调试..可以实时监听数据改变并刷新页面（live reloading）\n\n至于 这里`--save`和 `--save-v`的区别  \n`--save` 自动把模块和版本号添加到package.json配置文件的dependencies键对上  \n`--save-v` 自动把模块和版本号添加到package.json的devdependencies键对上  \ndevdependencies下列出的模块是开发时用的，它们不会被部署到生产环境中，dependencies下的模块，则是生产环境中需要的依赖。(dev指的是开发的意思, prod是生产production的缩写)\n\n永远不要在生产环境中使用开发工具...(我这里用在开发环境中的有webpack-dev-server)\n\n## webpack.config.js\n\n在项目目录里新建一个`webpack.config.js`文件用来配置webpack.  \nwebpack主要核心的东西就是 `entry(入口)`, `output(出口)`, `loader`, `plugins(插件)`\n>webpack工作概念: 当 webpack 处理应用程序时，它会递归地构建一个**关系依赖图**,其中包含程序需要的每个模块,然后将这些模块打包成少量的bundle,通常只有一个文件,再由浏览器加载..\n### entry（入口文件）\nwebpack创建关系依赖图,图的起点称作**入口起点**,它告诉webpack从哪里开始,并根据**关系依赖图**来确定需要打包的内容.也可以称作启动文件.  \n单页面应用只有一个入口起点,多页面应用就有多个入口起点.  \n\n`webpack-config.js`\n```javascript\nentry: {\n    home:  __dirname + '/home.js',   //__dirname是node.js一个全局变量,指的是当前模块的目录名字.\n    about: __dirname + '/about.js',\n    setting: __dirname + '/setting.js'\n}\n```\n只有一个入口文件可以写成  \n```javascript\nentry: __dirname + '/src/index.js'\n```\n### output (输出)\n**输出你所打包的内容**\n``` javascript\noutput: {\n\tpath: __dirname + \"/build\",  //路径\n\tfilename: \"bundle.js\"\t\t //文件名\n},\n```\n### module 模块\n在模块化编程中，开发者将程序分解成离散功能块，并称之为模块  \nwebpack把每个文件(.css,.html, .scss, .jpg, .png etc.)都作为模块处理, 然而,**webpack自身只理解JavaScript**  \n\nwebpack的关系依赖图就是各个模块之间的依赖关系,模块之间的依赖关系可以通过这几种方式确定.  \n1.  [ES6](http://es6.ruanyifeng.com/) 的 `import`语句  \n2.  [commonJS](http://javascript.ruanyifeng.com/nodejs/module.html) 的`require()`语句  \n3.  [AMD](http://zhaoda.net/webpack-handbook/amd.html)的 `define`和`require`语句  \n4.  css/less/sass文件中的 `@import`语句  \n5.  样式(`url(...)`)或 HTML 文件(` <img src=...> `)中的图片链接(image url)\n\n#### module.rules\n之前版本的webpack是使用loaders的，webpack 2.x之后就使用rules了。  \n**rules** ：(数组) 创建模块时，匹配请求的规则数组，这些规则能够对模块应用loader。  (loader又是什么)\n\n#### loader又是什么\nloader描述了webpack如何处理非JavaScript(non-JavaScript)模块，并且在bundle中引入这些依赖.  \nloader 有两个目标  \n1.  识别出应该被对应的loader进行转换的那些文件(test属性)  \n2.  使用某个loader转换这些文件,使其能够被加入到关系依赖图中去,并最终添加到bundle中 (<span id=\"use\">use属性</span>)  \n\n\n\n##### 安装style-loader & css-loader \n\n`npm install style-loader css-loader --save-v`\n\n`webpack3的语法`\n\n```json\nmodule: {\n    rules: [\n        {\n            test: /\\.css$/,  //一般是正则表达式\n            use: [\n                {\n                    loader: \"style-loader\"\n                },\n                {\n                    loader: \"css-loader?modules\"  // ?modules 表示打开Css modules功能\n                }\n            ]\n        },\n    ]\n}\n```\n\n用一句通俗的话来讲吧..就是:  \"喂,webpack编译器吗? 当你碰到require()语句或者 import语句中被解析为'.css'的路径时,在打包添加到bundle之前,先用  css-loader给他搞一下..然后再交给style-loader处理添加到style标签里..嵌入到JS代码中,恩,然后搞完再添加到bundle去\"  \n\n**注:  模块的加载是从下到上的. 这里先加载css-loader 然后再加载style-loader**\n\n###### 安装 Babel\n\n`npm install babel-core babel-preset-es2015 babel-loader --save-v`  \n\n-  babel-core 是Bebel的核心编译器,  \n-  babel-preset-es2015 是一个配置文件,我们可以把 ES2015的代码转化成ES5    \n-  babel-loader 用来编译JS文件\n\n修改`package.json`  在其中添加一个\"babel\"键\n\n```\n{\n    \"babel\": {\n        \"presets\": {\n            \"es2015\"\n        }\n    }\n}\n```\n\n\n\n#### Rule \n\n\n\nRule 能够根据rule筛选出来的模块对其应用loader\n\n每个规则可以分为三部分，   条件（condition），结果（result），嵌套规则（nested rule）\n\n \n\n#### Rule Conditions (规则条件)\n条件有两种输入值   \n1.  resource：请求文件的绝对路径。它根据resolve规则解析\n2.  issuer: 被请求资源（requested the resource）的模块文件的绝对路径。是导入的位置\n\nresource 有4个属性对其匹配 ：  \n1.  `test`  ：使用正则表达式匹配loader所处理的文件的拓展名\n2.  `include` ：添加必须处理的文件/文件夹\n3.  `exclude`： 屏蔽不需要处理的文件/文件夹\n4.  `resource`\n\n条件可以是其中之一： \n\n```javascript\ntest: /\\.js$/ // 使用正则表达式\nexclude: /node_modules/  //屏蔽拉黑node_modules此文件夹...\n```\n#### Rule result\nrule result 只在 rule condition 匹配时使用\n\n\n\n用 [use](#use)属性\n\n### dev-tool\n\ndev-tool : 开发者辅助调试工具 \n\n`string` 默认值: `false`\n\n选择一种source-map来增强调试过程,以下各种选先的构建和重构建速度不同..\n\n#### source-map是什么?\n\n> [阮一峰的文章](http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html) source-map是一个信息文件, 里面存储着位置信息,转换后的代码的每一个位置,所对应的转换前的位置.  出错的时候, 工具报错(浏览器控制台)将直接显示原始代码,而不是转换后的代码.    \n\nsource-map 文件可以存储位置信息,存储转换前的所有变量名和属性名, 存储转换前的文件.   \n\n**两个文件的各个位置是如何一一对应的?**\n\nsource-map 文件也有一个属性用来存储转换前文件跟转换后文件的对应信息,如(对应的行号, 位置对应,)  \n\n在位置对应里,每个位置使用5位,表示5个字段, 分别表示\n\n-  这个位置在(转换后的代码)的第几列, \n-  这个位置属于转换前的文件的哪一个文件. \n-  这个位置属于转换前代码的第几行, \n-  这个位置属于转换前代码的第几列, \n-  这个位置属于转换前的所有变量和属性名的哪一个.   \n\n\n\n简单了解了这个东西,不深入去探讨..等到以后用到的话,再去进一步学习.\n\n\n\n![Alt text](http://osuuzm0m8.bkt.clouddn.com/webpack.png)  \n\n```javascript\ndevtool: 'cheap-eval-source-map' \n```\n\n我在开发环境下是使用这个的, 报错有对应的行号提示,构建,重构建速度也快,相比较于eval, eval映射到的是转换后的代码,所以没有行号提示. 综合起来还是 `\"cheap-eval-source-map\"`比较合适..生产环境下我使用`\"cheap-source-map\"`\n\n###  devServer （开发服务器）\nwebpack-dev-server 由webpack提供的一个本地开发服务器，可以让浏览器监测代码的修改，并自动刷新修改后的结果，提高效率。  \nwebpack-dev-server.. 个人觉得最方便的就是自动刷新 & 热重载\n`语法`\n```javascript \ndevServer: {\n\tcontentBase； path.join(__dirname, 'src'), // 告知本地服务器从哪里提供内容.\n\thistoryApiFallback: true,\n\tport: 5555  //默认是8080端口,可自定义\n}\n```\n\n现在配置了开发服务器的话, 开发过程中监测着代码文件,当代码文件发生变化时, 可以自动刷新,重新构建网页.  \n\n但是过于频繁的刷新,当你的项目比较大时,reload页面需要等待的时间就比较长了,所以,dev-server还可以设置开启热替代.可以利用 插件 Hot Module Replacement 来实现.  模块热替换在程序运行时对模块修改,添加或者删除时,不需要重新加载整个页面,只更新改变内容.  \n\n有两种方式可以启用模块热替换,\n\n- 在 `webpack.config.js`文件中,\n\n   ```\n  plugins: [\n      new webpack.HotModuleReplacement()  //new一个HotModuleReplacement对象\n  ]\n\n  devServer: {\n      ...\n      inline: true, //采用inline模式.而不是iframe模式\n      hot: true    //开启热替换\n  }\n   ```\n\n  这样需要写的东西太对,所以我还是通过第二种方式, CLI命令行添加参数来开启\n\n  所以我还是用第二种方式来开启..\n\n- CLI添加参数.  顺便把这段开启webpack的代码写到`package.json`的 `\"scripts\"`键上,  如下\n\n  添加参数 `--line --hot`\n\n  ```json\n  \"scripts\": {\n  \t\"dev\": \"webpack-dev-server --inline --hot --env=dev --open\"\n  }\n  ```\n\n  直接在终端运行 `npm run dev`就可以开启开发服务器了.带有热重载的,不过此时热重载还没生效,因为还需要配置点其他东西.  \n\n还需要修改的东西\n\n修改entry入口数组,\n\n```json\nentry: {\n  main: [\n      'webpack/hot/only-dev-server',  //在热更新失败后,需要采取手动刷新\n      'webpack-dev-server/client?http://127.0.0.1:5555/',  //资源服务器,我这里是本地服务器localhost,如果需要远程服务器的资源就相应的更改就好了.\n      './src/index.js'   //入口文件\n  ]\n}\n```\n\n`index.js` (入口JS文件)  \n\n为了让html文件也可以采用热替换,需要把html当作一个模块来引入到`index.js`内\n\n`index.js`\n\n````javascript\nrequire('./index.tpl.html');\n````\n\n也要在rules新建一个一个规则  \n\nhtml-loader需要先install\n\n`npm install html-loader --save-v`\n\n`webpack.config.js`\n\n```javascript\nmodule: {\n    rules: [\n        {\n            test: /\\.html$/,\n            use: [\"html-loader\"]  //使用html-loader,将html内容存为js字符串.  \n          \t\t\t\t\t\t  //遇到  require ('./index.tpl.html') \n          \t\t\t\t\t\t  //index.tpl.html的内容会被转成一个Js字符串,合并到JS文件中\n        }\n    ]\n}\n```\n\n`index.js`\n\n```javascript\nif(moduel.hot) {\n\t//module.hot.accept(dependencies, callback); //如果某个模块热替换后需要调用回调函数的就需要写这个.\n\tmodule.hot.accept('./a.js', () => {\n        console.log(\"change a.js\");\n\t});\n    //如果是某人index.js的所有模块都采用热替换的话,则只需写\n    //module.hot.accept(); 这样所有模块都采用热替换.\n\tmodule.hot.decline('./component.js'); //强制component.js的修改热更新失败,只能reload整个页面.\n}\n```\n\n这样就已经可以实现热替换功能了,无论html,css,js etc.发生改变都会热替换那个模块,如果热替换失败的话,浏览器会自动刷新或者需要手动刷新,HMR会在控制台输出信息,可以查阅..\n\n#### 生产环境...& 开发环境...的配置文件.\n\n呃...一开始我是没有注意到这个生产环境跟开发环境之间所引用的配置的文件需要区别的东西的,看了官方的文档才知道,生产环境跟开发环境所用的配置文件不是完全相同的,官网推荐的那种手动方式,分别使用webpack.dev.js 和 webpack.prod.js 去区别开发环境跟生产环境,由于两个文件重复的东西太多,所以感觉效率不是很好..(懒得写两个,其实几乎差不多的文件)\n\ngoogle了下,找到了一个我个人比较喜欢也容易理解的方法..\n\n` webpack.config.js`\n\n```javascript\nvar path = require('path');\nvar webpack = require('webpack');\nvar HtmlWebpackPlugin = require('html-webpack-plugin');\n\n// 生产环境需要用到的配置文件的内容\nconst prodConfig = {\n  \n}\n\n// 开发环境需要用到的配置文件的内容\nfunction devConfig() {\n  const config = {\n      ...\n  };\n  \n  return Object.assign({}, prodConfig, config, {plugins: prodConfig.plugins.concat(config.plugins)})\n  /*采用 Object.assign的方法,把几个对象复制到一个空对象上,形成一个新对象,拥有两个对象所有属性,如果属性名,属性值以后面对象的值为准.(后面的对象的值覆盖掉前面对象的值.)  因为plugins是个数组,所以需要用concat方法来将两个对象的plugins数组连接起来.*/\n}\n\n// 再根据CLI时传的env的参数来确定使用什么环境下的配置文件\nmodule.exports = function(env) {\n  \tconsole.log(\"env is: \",env);\n\n\tif(env === \"dev\") {\n\t\treturn devConfig();\n\t}\n\n\treturn prodConfig;\n}\n```\n\n\n\n`package.json`\n\n```json\n{\n    \"scripts\": {\n    \t\"dev\": \"webpack-dev-server --inline --hot --env=dev --open\",\n    \t\"build\": \"rimraf build && webpack -p --env=prod\"\n    }\n}\n```\n\n`rimraf`是用来每次build之前清空build文件夹的..\n\n```bash\nnpm install rimraf --save-v\n```\n\n这两天的webpack的入门学习大概就这些了(之前看了一些webpack@1.x 和@2,x的学习教程,然后发现webpack已经出到3 了,干脆直接去官网啃文档了,不过这文档,真的是有点晦涩啊....)...webpack对于SPA(单页面应用来说还是挺不错的..),(主要是模块化),如果是多页面应用的话,用gulp来打包,压缩文件会更方便.. 等缓一缓再去学习下gulp,  ...等到....掌握了,再去考虑,鱼跟熊掌怎么兼得的问题了.   路漫漫其修远兮,前方道路远又远又远啊....\n\n> 参考网站: [webpack中文网](https://doc.webpack-china.org/)\n>\n> ​\t\t[webpack模块热替换](http://www.cnblogs.com/stoneniqiu/p/6496425.html)\n>\n> etc.. 有些也忘了...  \n>\n> 呃 还有参考github上一些项目的issues的解决办法, 发现....呃....英文真的很重要阿...orz..\n\n","source":"_posts/webpack.md","raw":"---\ntitle: webpack笔记\ncategory: webpack\ndate: 2017-7-25\ntags: [前端工程化]\n---\n\n这几天学习下了webpack,也做了demo,大概也了解webpack如何配置了...此篇是学习笔记...为了巩固刚学的知识..\n<!-- more -->\n这次使用的是webpack的新版本3.x\n\n## 安装\n新建一个文件夹， 使用`npm init` 快速配置package.json\n\n文件目录是这样的... src用来放资源文件, build用来放打包后的文件. \n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fhyoffw4egj206w0ayglx.jpg)\n\n### 安装 webpack\n\n安装webpack & webpack-dev-server\n```bash\nnpm install webpack webpack-dev-server--save-v\n```\n\n安装webpack-dev-server（开发服务器)用于开发，便于调试..可以实时监听数据改变并刷新页面（live reloading）\n\n至于 这里`--save`和 `--save-v`的区别  \n`--save` 自动把模块和版本号添加到package.json配置文件的dependencies键对上  \n`--save-v` 自动把模块和版本号添加到package.json的devdependencies键对上  \ndevdependencies下列出的模块是开发时用的，它们不会被部署到生产环境中，dependencies下的模块，则是生产环境中需要的依赖。(dev指的是开发的意思, prod是生产production的缩写)\n\n永远不要在生产环境中使用开发工具...(我这里用在开发环境中的有webpack-dev-server)\n\n## webpack.config.js\n\n在项目目录里新建一个`webpack.config.js`文件用来配置webpack.  \nwebpack主要核心的东西就是 `entry(入口)`, `output(出口)`, `loader`, `plugins(插件)`\n>webpack工作概念: 当 webpack 处理应用程序时，它会递归地构建一个**关系依赖图**,其中包含程序需要的每个模块,然后将这些模块打包成少量的bundle,通常只有一个文件,再由浏览器加载..\n### entry（入口文件）\nwebpack创建关系依赖图,图的起点称作**入口起点**,它告诉webpack从哪里开始,并根据**关系依赖图**来确定需要打包的内容.也可以称作启动文件.  \n单页面应用只有一个入口起点,多页面应用就有多个入口起点.  \n\n`webpack-config.js`\n```javascript\nentry: {\n    home:  __dirname + '/home.js',   //__dirname是node.js一个全局变量,指的是当前模块的目录名字.\n    about: __dirname + '/about.js',\n    setting: __dirname + '/setting.js'\n}\n```\n只有一个入口文件可以写成  \n```javascript\nentry: __dirname + '/src/index.js'\n```\n### output (输出)\n**输出你所打包的内容**\n``` javascript\noutput: {\n\tpath: __dirname + \"/build\",  //路径\n\tfilename: \"bundle.js\"\t\t //文件名\n},\n```\n### module 模块\n在模块化编程中，开发者将程序分解成离散功能块，并称之为模块  \nwebpack把每个文件(.css,.html, .scss, .jpg, .png etc.)都作为模块处理, 然而,**webpack自身只理解JavaScript**  \n\nwebpack的关系依赖图就是各个模块之间的依赖关系,模块之间的依赖关系可以通过这几种方式确定.  \n1.  [ES6](http://es6.ruanyifeng.com/) 的 `import`语句  \n2.  [commonJS](http://javascript.ruanyifeng.com/nodejs/module.html) 的`require()`语句  \n3.  [AMD](http://zhaoda.net/webpack-handbook/amd.html)的 `define`和`require`语句  \n4.  css/less/sass文件中的 `@import`语句  \n5.  样式(`url(...)`)或 HTML 文件(` <img src=...> `)中的图片链接(image url)\n\n#### module.rules\n之前版本的webpack是使用loaders的，webpack 2.x之后就使用rules了。  \n**rules** ：(数组) 创建模块时，匹配请求的规则数组，这些规则能够对模块应用loader。  (loader又是什么)\n\n#### loader又是什么\nloader描述了webpack如何处理非JavaScript(non-JavaScript)模块，并且在bundle中引入这些依赖.  \nloader 有两个目标  \n1.  识别出应该被对应的loader进行转换的那些文件(test属性)  \n2.  使用某个loader转换这些文件,使其能够被加入到关系依赖图中去,并最终添加到bundle中 (<span id=\"use\">use属性</span>)  \n\n\n\n##### 安装style-loader & css-loader \n\n`npm install style-loader css-loader --save-v`\n\n`webpack3的语法`\n\n```json\nmodule: {\n    rules: [\n        {\n            test: /\\.css$/,  //一般是正则表达式\n            use: [\n                {\n                    loader: \"style-loader\"\n                },\n                {\n                    loader: \"css-loader?modules\"  // ?modules 表示打开Css modules功能\n                }\n            ]\n        },\n    ]\n}\n```\n\n用一句通俗的话来讲吧..就是:  \"喂,webpack编译器吗? 当你碰到require()语句或者 import语句中被解析为'.css'的路径时,在打包添加到bundle之前,先用  css-loader给他搞一下..然后再交给style-loader处理添加到style标签里..嵌入到JS代码中,恩,然后搞完再添加到bundle去\"  \n\n**注:  模块的加载是从下到上的. 这里先加载css-loader 然后再加载style-loader**\n\n###### 安装 Babel\n\n`npm install babel-core babel-preset-es2015 babel-loader --save-v`  \n\n-  babel-core 是Bebel的核心编译器,  \n-  babel-preset-es2015 是一个配置文件,我们可以把 ES2015的代码转化成ES5    \n-  babel-loader 用来编译JS文件\n\n修改`package.json`  在其中添加一个\"babel\"键\n\n```\n{\n    \"babel\": {\n        \"presets\": {\n            \"es2015\"\n        }\n    }\n}\n```\n\n\n\n#### Rule \n\n\n\nRule 能够根据rule筛选出来的模块对其应用loader\n\n每个规则可以分为三部分，   条件（condition），结果（result），嵌套规则（nested rule）\n\n \n\n#### Rule Conditions (规则条件)\n条件有两种输入值   \n1.  resource：请求文件的绝对路径。它根据resolve规则解析\n2.  issuer: 被请求资源（requested the resource）的模块文件的绝对路径。是导入的位置\n\nresource 有4个属性对其匹配 ：  \n1.  `test`  ：使用正则表达式匹配loader所处理的文件的拓展名\n2.  `include` ：添加必须处理的文件/文件夹\n3.  `exclude`： 屏蔽不需要处理的文件/文件夹\n4.  `resource`\n\n条件可以是其中之一： \n\n```javascript\ntest: /\\.js$/ // 使用正则表达式\nexclude: /node_modules/  //屏蔽拉黑node_modules此文件夹...\n```\n#### Rule result\nrule result 只在 rule condition 匹配时使用\n\n\n\n用 [use](#use)属性\n\n### dev-tool\n\ndev-tool : 开发者辅助调试工具 \n\n`string` 默认值: `false`\n\n选择一种source-map来增强调试过程,以下各种选先的构建和重构建速度不同..\n\n#### source-map是什么?\n\n> [阮一峰的文章](http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html) source-map是一个信息文件, 里面存储着位置信息,转换后的代码的每一个位置,所对应的转换前的位置.  出错的时候, 工具报错(浏览器控制台)将直接显示原始代码,而不是转换后的代码.    \n\nsource-map 文件可以存储位置信息,存储转换前的所有变量名和属性名, 存储转换前的文件.   \n\n**两个文件的各个位置是如何一一对应的?**\n\nsource-map 文件也有一个属性用来存储转换前文件跟转换后文件的对应信息,如(对应的行号, 位置对应,)  \n\n在位置对应里,每个位置使用5位,表示5个字段, 分别表示\n\n-  这个位置在(转换后的代码)的第几列, \n-  这个位置属于转换前的文件的哪一个文件. \n-  这个位置属于转换前代码的第几行, \n-  这个位置属于转换前代码的第几列, \n-  这个位置属于转换前的所有变量和属性名的哪一个.   \n\n\n\n简单了解了这个东西,不深入去探讨..等到以后用到的话,再去进一步学习.\n\n\n\n![Alt text](http://osuuzm0m8.bkt.clouddn.com/webpack.png)  \n\n```javascript\ndevtool: 'cheap-eval-source-map' \n```\n\n我在开发环境下是使用这个的, 报错有对应的行号提示,构建,重构建速度也快,相比较于eval, eval映射到的是转换后的代码,所以没有行号提示. 综合起来还是 `\"cheap-eval-source-map\"`比较合适..生产环境下我使用`\"cheap-source-map\"`\n\n###  devServer （开发服务器）\nwebpack-dev-server 由webpack提供的一个本地开发服务器，可以让浏览器监测代码的修改，并自动刷新修改后的结果，提高效率。  \nwebpack-dev-server.. 个人觉得最方便的就是自动刷新 & 热重载\n`语法`\n```javascript \ndevServer: {\n\tcontentBase； path.join(__dirname, 'src'), // 告知本地服务器从哪里提供内容.\n\thistoryApiFallback: true,\n\tport: 5555  //默认是8080端口,可自定义\n}\n```\n\n现在配置了开发服务器的话, 开发过程中监测着代码文件,当代码文件发生变化时, 可以自动刷新,重新构建网页.  \n\n但是过于频繁的刷新,当你的项目比较大时,reload页面需要等待的时间就比较长了,所以,dev-server还可以设置开启热替代.可以利用 插件 Hot Module Replacement 来实现.  模块热替换在程序运行时对模块修改,添加或者删除时,不需要重新加载整个页面,只更新改变内容.  \n\n有两种方式可以启用模块热替换,\n\n- 在 `webpack.config.js`文件中,\n\n   ```\n  plugins: [\n      new webpack.HotModuleReplacement()  //new一个HotModuleReplacement对象\n  ]\n\n  devServer: {\n      ...\n      inline: true, //采用inline模式.而不是iframe模式\n      hot: true    //开启热替换\n  }\n   ```\n\n  这样需要写的东西太对,所以我还是通过第二种方式, CLI命令行添加参数来开启\n\n  所以我还是用第二种方式来开启..\n\n- CLI添加参数.  顺便把这段开启webpack的代码写到`package.json`的 `\"scripts\"`键上,  如下\n\n  添加参数 `--line --hot`\n\n  ```json\n  \"scripts\": {\n  \t\"dev\": \"webpack-dev-server --inline --hot --env=dev --open\"\n  }\n  ```\n\n  直接在终端运行 `npm run dev`就可以开启开发服务器了.带有热重载的,不过此时热重载还没生效,因为还需要配置点其他东西.  \n\n还需要修改的东西\n\n修改entry入口数组,\n\n```json\nentry: {\n  main: [\n      'webpack/hot/only-dev-server',  //在热更新失败后,需要采取手动刷新\n      'webpack-dev-server/client?http://127.0.0.1:5555/',  //资源服务器,我这里是本地服务器localhost,如果需要远程服务器的资源就相应的更改就好了.\n      './src/index.js'   //入口文件\n  ]\n}\n```\n\n`index.js` (入口JS文件)  \n\n为了让html文件也可以采用热替换,需要把html当作一个模块来引入到`index.js`内\n\n`index.js`\n\n````javascript\nrequire('./index.tpl.html');\n````\n\n也要在rules新建一个一个规则  \n\nhtml-loader需要先install\n\n`npm install html-loader --save-v`\n\n`webpack.config.js`\n\n```javascript\nmodule: {\n    rules: [\n        {\n            test: /\\.html$/,\n            use: [\"html-loader\"]  //使用html-loader,将html内容存为js字符串.  \n          \t\t\t\t\t\t  //遇到  require ('./index.tpl.html') \n          \t\t\t\t\t\t  //index.tpl.html的内容会被转成一个Js字符串,合并到JS文件中\n        }\n    ]\n}\n```\n\n`index.js`\n\n```javascript\nif(moduel.hot) {\n\t//module.hot.accept(dependencies, callback); //如果某个模块热替换后需要调用回调函数的就需要写这个.\n\tmodule.hot.accept('./a.js', () => {\n        console.log(\"change a.js\");\n\t});\n    //如果是某人index.js的所有模块都采用热替换的话,则只需写\n    //module.hot.accept(); 这样所有模块都采用热替换.\n\tmodule.hot.decline('./component.js'); //强制component.js的修改热更新失败,只能reload整个页面.\n}\n```\n\n这样就已经可以实现热替换功能了,无论html,css,js etc.发生改变都会热替换那个模块,如果热替换失败的话,浏览器会自动刷新或者需要手动刷新,HMR会在控制台输出信息,可以查阅..\n\n#### 生产环境...& 开发环境...的配置文件.\n\n呃...一开始我是没有注意到这个生产环境跟开发环境之间所引用的配置的文件需要区别的东西的,看了官方的文档才知道,生产环境跟开发环境所用的配置文件不是完全相同的,官网推荐的那种手动方式,分别使用webpack.dev.js 和 webpack.prod.js 去区别开发环境跟生产环境,由于两个文件重复的东西太多,所以感觉效率不是很好..(懒得写两个,其实几乎差不多的文件)\n\ngoogle了下,找到了一个我个人比较喜欢也容易理解的方法..\n\n` webpack.config.js`\n\n```javascript\nvar path = require('path');\nvar webpack = require('webpack');\nvar HtmlWebpackPlugin = require('html-webpack-plugin');\n\n// 生产环境需要用到的配置文件的内容\nconst prodConfig = {\n  \n}\n\n// 开发环境需要用到的配置文件的内容\nfunction devConfig() {\n  const config = {\n      ...\n  };\n  \n  return Object.assign({}, prodConfig, config, {plugins: prodConfig.plugins.concat(config.plugins)})\n  /*采用 Object.assign的方法,把几个对象复制到一个空对象上,形成一个新对象,拥有两个对象所有属性,如果属性名,属性值以后面对象的值为准.(后面的对象的值覆盖掉前面对象的值.)  因为plugins是个数组,所以需要用concat方法来将两个对象的plugins数组连接起来.*/\n}\n\n// 再根据CLI时传的env的参数来确定使用什么环境下的配置文件\nmodule.exports = function(env) {\n  \tconsole.log(\"env is: \",env);\n\n\tif(env === \"dev\") {\n\t\treturn devConfig();\n\t}\n\n\treturn prodConfig;\n}\n```\n\n\n\n`package.json`\n\n```json\n{\n    \"scripts\": {\n    \t\"dev\": \"webpack-dev-server --inline --hot --env=dev --open\",\n    \t\"build\": \"rimraf build && webpack -p --env=prod\"\n    }\n}\n```\n\n`rimraf`是用来每次build之前清空build文件夹的..\n\n```bash\nnpm install rimraf --save-v\n```\n\n这两天的webpack的入门学习大概就这些了(之前看了一些webpack@1.x 和@2,x的学习教程,然后发现webpack已经出到3 了,干脆直接去官网啃文档了,不过这文档,真的是有点晦涩啊....)...webpack对于SPA(单页面应用来说还是挺不错的..),(主要是模块化),如果是多页面应用的话,用gulp来打包,压缩文件会更方便.. 等缓一缓再去学习下gulp,  ...等到....掌握了,再去考虑,鱼跟熊掌怎么兼得的问题了.   路漫漫其修远兮,前方道路远又远又远啊....\n\n> 参考网站: [webpack中文网](https://doc.webpack-china.org/)\n>\n> ​\t\t[webpack模块热替换](http://www.cnblogs.com/stoneniqiu/p/6496425.html)\n>\n> etc.. 有些也忘了...  \n>\n> 呃 还有参考github上一些项目的issues的解决办法, 发现....呃....英文真的很重要阿...orz..\n\n","slug":"webpack","published":1,"updated":"2018-03-12T15:19:58.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf81eh97001ev4ef44fci6hm","content":"<p>这几天学习下了webpack,也做了demo,大概也了解webpack如何配置了…此篇是学习笔记…为了巩固刚学的知识..<br><a id=\"more\"></a><br>这次使用的是webpack的新版本3.x</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>新建一个文件夹， 使用<code>npm init</code> 快速配置package.json</p>\n<p>文件目录是这样的… src用来放资源文件, build用来放打包后的文件. </p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fhyoffw4egj206w0ayglx.jpg\" alt=\"\"></p>\n<h3 id=\"安装-webpack\"><a href=\"#安装-webpack\" class=\"headerlink\" title=\"安装 webpack\"></a>安装 webpack</h3><p>安装webpack &amp; webpack-dev-server<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install webpack webpack-dev-server--save-v</span><br></pre></td></tr></table></figure></p>\n<p>安装webpack-dev-server（开发服务器)用于开发，便于调试..可以实时监听数据改变并刷新页面（live reloading）</p>\n<p>至于 这里<code>--save</code>和 <code>--save-v</code>的区别<br><code>--save</code> 自动把模块和版本号添加到package.json配置文件的dependencies键对上<br><code>--save-v</code> 自动把模块和版本号添加到package.json的devdependencies键对上<br>devdependencies下列出的模块是开发时用的，它们不会被部署到生产环境中，dependencies下的模块，则是生产环境中需要的依赖。(dev指的是开发的意思, prod是生产production的缩写)</p>\n<p>永远不要在生产环境中使用开发工具…(我这里用在开发环境中的有webpack-dev-server)</p>\n<h2 id=\"webpack-config-js\"><a href=\"#webpack-config-js\" class=\"headerlink\" title=\"webpack.config.js\"></a>webpack.config.js</h2><p>在项目目录里新建一个<code>webpack.config.js</code>文件用来配置webpack.<br>webpack主要核心的东西就是 <code>entry(入口)</code>, <code>output(出口)</code>, <code>loader</code>, <code>plugins(插件)</code></p>\n<blockquote>\n<p>webpack工作概念: 当 webpack 处理应用程序时，它会递归地构建一个<strong>关系依赖图</strong>,其中包含程序需要的每个模块,然后将这些模块打包成少量的bundle,通常只有一个文件,再由浏览器加载..</p>\n</blockquote>\n<h3 id=\"entry（入口文件）\"><a href=\"#entry（入口文件）\" class=\"headerlink\" title=\"entry（入口文件）\"></a>entry（入口文件）</h3><p>webpack创建关系依赖图,图的起点称作<strong>入口起点</strong>,它告诉webpack从哪里开始,并根据<strong>关系依赖图</strong>来确定需要打包的内容.也可以称作启动文件.<br>单页面应用只有一个入口起点,多页面应用就有多个入口起点.  </p>\n<p><code>webpack-config.js</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">    home:  __dirname + <span class=\"string\">'/home.js'</span>,   <span class=\"comment\">//__dirname是node.js一个全局变量,指的是当前模块的目录名字.</span></span><br><span class=\"line\">    about: __dirname + <span class=\"string\">'/about.js'</span>,</span><br><span class=\"line\">    setting: __dirname + <span class=\"string\">'/setting.js'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>只有一个入口文件可以写成<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: __dirname + <span class=\"string\">'/src/index.js'</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"output-输出\"><a href=\"#output-输出\" class=\"headerlink\" title=\"output (输出)\"></a>output (输出)</h3><p><strong>输出你所打包的内容</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">output: &#123;</span><br><span class=\"line\">\tpath: __dirname + <span class=\"string\">\"/build\"</span>,  <span class=\"comment\">//路径</span></span><br><span class=\"line\">\tfilename: <span class=\"string\">\"bundle.js\"</span>\t\t <span class=\"comment\">//文件名</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"module-模块\"><a href=\"#module-模块\" class=\"headerlink\" title=\"module 模块\"></a>module 模块</h3><p>在模块化编程中，开发者将程序分解成离散功能块，并称之为模块<br>webpack把每个文件(.css,.html, .scss, .jpg, .png etc.)都作为模块处理, 然而,<strong>webpack自身只理解JavaScript</strong>  </p>\n<p>webpack的关系依赖图就是各个模块之间的依赖关系,模块之间的依赖关系可以通过这几种方式确定.  </p>\n<ol>\n<li><a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">ES6</a> 的 <code>import</code>语句  </li>\n<li><a href=\"http://javascript.ruanyifeng.com/nodejs/module.html\" target=\"_blank\" rel=\"noopener\">commonJS</a> 的<code>require()</code>语句  </li>\n<li><a href=\"http://zhaoda.net/webpack-handbook/amd.html\" target=\"_blank\" rel=\"noopener\">AMD</a>的 <code>define</code>和<code>require</code>语句  </li>\n<li>css/less/sass文件中的 <code>@import</code>语句  </li>\n<li>样式(<code>url(...)</code>)或 HTML 文件(<code>&lt;img src=...&gt;</code>)中的图片链接(image url)</li>\n</ol>\n<h4 id=\"module-rules\"><a href=\"#module-rules\" class=\"headerlink\" title=\"module.rules\"></a>module.rules</h4><p>之前版本的webpack是使用loaders的，webpack 2.x之后就使用rules了。<br><strong>rules</strong> ：(数组) 创建模块时，匹配请求的规则数组，这些规则能够对模块应用loader。  (loader又是什么)</p>\n<h4 id=\"loader又是什么\"><a href=\"#loader又是什么\" class=\"headerlink\" title=\"loader又是什么\"></a>loader又是什么</h4><p>loader描述了webpack如何处理非JavaScript(non-JavaScript)模块，并且在bundle中引入这些依赖.<br>loader 有两个目标  </p>\n<ol>\n<li>识别出应该被对应的loader进行转换的那些文件(test属性)  </li>\n<li>使用某个loader转换这些文件,使其能够被加入到关系依赖图中去,并最终添加到bundle中 (<span id=\"use\">use属性</span>)  </li>\n</ol>\n<h5 id=\"安装style-loader-amp-css-loader\"><a href=\"#安装style-loader-amp-css-loader\" class=\"headerlink\" title=\"安装style-loader &amp; css-loader\"></a>安装style-loader &amp; css-loader</h5><p><code>npm install style-loader css-loader --save-v</code></p>\n<p><code>webpack3的语法</code></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            test: /\\.css$/,  //一般是正则表达式</span><br><span class=\"line\">            use: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    loader: \"style-loader\"</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    loader: \"css-loader?modules\"  // ?modules 表示打开Css modules功能</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用一句通俗的话来讲吧..就是:  “喂,webpack编译器吗? 当你碰到require()语句或者 import语句中被解析为’.css’的路径时,在打包添加到bundle之前,先用  css-loader给他搞一下..然后再交给style-loader处理添加到style标签里..嵌入到JS代码中,恩,然后搞完再添加到bundle去”  </p>\n<p><strong>注:  模块的加载是从下到上的. 这里先加载css-loader 然后再加载style-loader</strong></p>\n<h6 id=\"安装-Babel\"><a href=\"#安装-Babel\" class=\"headerlink\" title=\"安装 Babel\"></a>安装 Babel</h6><p><code>npm install babel-core babel-preset-es2015 babel-loader --save-v</code>  </p>\n<ul>\n<li>babel-core 是Bebel的核心编译器,  </li>\n<li>babel-preset-es2015 是一个配置文件,我们可以把 ES2015的代码转化成ES5    </li>\n<li>babel-loader 用来编译JS文件</li>\n</ul>\n<p>修改<code>package.json</code>  在其中添加一个”babel”键</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;babel&quot;: &#123;</span><br><span class=\"line\">        &quot;presets&quot;: &#123;</span><br><span class=\"line\">            &quot;es2015&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Rule\"><a href=\"#Rule\" class=\"headerlink\" title=\"Rule\"></a>Rule</h4><p>Rule 能够根据rule筛选出来的模块对其应用loader</p>\n<p>每个规则可以分为三部分，   条件（condition），结果（result），嵌套规则（nested rule）</p>\n<h4 id=\"Rule-Conditions-规则条件\"><a href=\"#Rule-Conditions-规则条件\" class=\"headerlink\" title=\"Rule Conditions (规则条件)\"></a>Rule Conditions (规则条件)</h4><p>条件有两种输入值   </p>\n<ol>\n<li>resource：请求文件的绝对路径。它根据resolve规则解析</li>\n<li>issuer: 被请求资源（requested the resource）的模块文件的绝对路径。是导入的位置</li>\n</ol>\n<p>resource 有4个属性对其匹配 ：  </p>\n<ol>\n<li><code>test</code>  ：使用正则表达式匹配loader所处理的文件的拓展名</li>\n<li><code>include</code> ：添加必须处理的文件/文件夹</li>\n<li><code>exclude</code>： 屏蔽不需要处理的文件/文件夹</li>\n<li><code>resource</code></li>\n</ol>\n<p>条件可以是其中之一： </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test: <span class=\"regexp\">/\\.js$/</span> <span class=\"comment\">// 使用正则表达式</span></span><br><span class=\"line\">exclude: <span class=\"regexp\">/node_modules/</span>  <span class=\"comment\">//屏蔽拉黑node_modules此文件夹...</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Rule-result\"><a href=\"#Rule-result\" class=\"headerlink\" title=\"Rule result\"></a>Rule result</h4><p>rule result 只在 rule condition 匹配时使用</p>\n<p>用 <a href=\"#use\">use</a>属性</p>\n<h3 id=\"dev-tool\"><a href=\"#dev-tool\" class=\"headerlink\" title=\"dev-tool\"></a>dev-tool</h3><p>dev-tool : 开发者辅助调试工具 </p>\n<p><code>string</code> 默认值: <code>false</code></p>\n<p>选择一种source-map来增强调试过程,以下各种选先的构建和重构建速度不同..</p>\n<h4 id=\"source-map是什么\"><a href=\"#source-map是什么\" class=\"headerlink\" title=\"source-map是什么?\"></a>source-map是什么?</h4><blockquote>\n<p><a href=\"http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html\" target=\"_blank\" rel=\"noopener\">阮一峰的文章</a> source-map是一个信息文件, 里面存储着位置信息,转换后的代码的每一个位置,所对应的转换前的位置.  出错的时候, 工具报错(浏览器控制台)将直接显示原始代码,而不是转换后的代码.    </p>\n</blockquote>\n<p>source-map 文件可以存储位置信息,存储转换前的所有变量名和属性名, 存储转换前的文件.   </p>\n<p><strong>两个文件的各个位置是如何一一对应的?</strong></p>\n<p>source-map 文件也有一个属性用来存储转换前文件跟转换后文件的对应信息,如(对应的行号, 位置对应,)  </p>\n<p>在位置对应里,每个位置使用5位,表示5个字段, 分别表示</p>\n<ul>\n<li>这个位置在(转换后的代码)的第几列, </li>\n<li>这个位置属于转换前的文件的哪一个文件. </li>\n<li>这个位置属于转换前代码的第几行, </li>\n<li>这个位置属于转换前代码的第几列, </li>\n<li>这个位置属于转换前的所有变量和属性名的哪一个.   </li>\n</ul>\n<p>简单了解了这个东西,不深入去探讨..等到以后用到的话,再去进一步学习.</p>\n<p><img src=\"http://osuuzm0m8.bkt.clouddn.com/webpack.png\" alt=\"Alt text\">  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devtool: <span class=\"string\">'cheap-eval-source-map'</span></span><br></pre></td></tr></table></figure>\n<p>我在开发环境下是使用这个的, 报错有对应的行号提示,构建,重构建速度也快,相比较于eval, eval映射到的是转换后的代码,所以没有行号提示. 综合起来还是 <code>&quot;cheap-eval-source-map&quot;</code>比较合适..生产环境下我使用<code>&quot;cheap-source-map&quot;</code></p>\n<h3 id=\"devServer-（开发服务器）\"><a href=\"#devServer-（开发服务器）\" class=\"headerlink\" title=\"devServer （开发服务器）\"></a>devServer （开发服务器）</h3><p>webpack-dev-server 由webpack提供的一个本地开发服务器，可以让浏览器监测代码的修改，并自动刷新修改后的结果，提高效率。<br>webpack-dev-server.. 个人觉得最方便的就是自动刷新 &amp; 热重载<br><code>语法</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">\tcontentBase； path.join(__dirname, <span class=\"string\">'src'</span>), <span class=\"comment\">// 告知本地服务器从哪里提供内容.</span></span><br><span class=\"line\">\thistoryApiFallback: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\tport: <span class=\"number\">5555</span>  <span class=\"comment\">//默认是8080端口,可自定义</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在配置了开发服务器的话, 开发过程中监测着代码文件,当代码文件发生变化时, 可以自动刷新,重新构建网页.  </p>\n<p>但是过于频繁的刷新,当你的项目比较大时,reload页面需要等待的时间就比较长了,所以,dev-server还可以设置开启热替代.可以利用 插件 Hot Module Replacement 来实现.  模块热替换在程序运行时对模块修改,添加或者删除时,不需要重新加载整个页面,只更新改变内容.  </p>\n<p>有两种方式可以启用模块热替换,</p>\n<ul>\n<li><p>在 <code>webpack.config.js</code>文件中,</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">    new webpack.HotModuleReplacement()  //new一个HotModuleReplacement对象</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    inline: true, //采用inline模式.而不是iframe模式</span><br><span class=\"line\">    hot: true    //开启热替换</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样需要写的东西太对,所以我还是通过第二种方式, CLI命令行添加参数来开启</p>\n<p>所以我还是用第二种方式来开启..</p>\n</li>\n<li><p>CLI添加参数.  顺便把这段开启webpack的代码写到<code>package.json</code>的 <code>&quot;scripts&quot;</code>键上,  如下</p>\n<p>添加参数 <code>--line --hot</code></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\">\t\"dev\": \"webpack-dev-server --inline --hot --env=dev --open\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>直接在终端运行 <code>npm run dev</code>就可以开启开发服务器了.带有热重载的,不过此时热重载还没生效,因为还需要配置点其他东西.  </p>\n</li>\n</ul>\n<p>还需要修改的东西</p>\n<p>修改entry入口数组,</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">  main: [</span><br><span class=\"line\">      'webpack/hot/only-dev-server',  //在热更新失败后,需要采取手动刷新</span><br><span class=\"line\">      'webpack-dev-server/client?http://127.0.0.1:5555/',  //资源服务器,我这里是本地服务器localhost,如果需要远程服务器的资源就相应的更改就好了.</span><br><span class=\"line\">      './src/index.js'   //入口文件</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>index.js</code> (入口JS文件)  </p>\n<p>为了让html文件也可以采用热替换,需要把html当作一个模块来引入到<code>index.js</code>内</p>\n<p><code>index.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'./index.tpl.html'</span>);</span><br></pre></td></tr></table></figure>\n<p>也要在rules新建一个一个规则  </p>\n<p>html-loader需要先install</p>\n<p><code>npm install html-loader --save-v</code></p>\n<p><code>webpack.config.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            test: <span class=\"regexp\">/\\.html$/</span>,</span><br><span class=\"line\">            use: [<span class=\"string\">\"html-loader\"</span>]  <span class=\"comment\">//使用html-loader,将html内容存为js字符串.  </span></span><br><span class=\"line\">          \t\t\t\t\t\t  <span class=\"comment\">//遇到  require ('./index.tpl.html') </span></span><br><span class=\"line\">          \t\t\t\t\t\t  <span class=\"comment\">//index.tpl.html的内容会被转成一个Js字符串,合并到JS文件中</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>index.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(moduel.hot) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//module.hot.accept(dependencies, callback); //如果某个模块热替换后需要调用回调函数的就需要写这个.</span></span><br><span class=\"line\">\t<span class=\"built_in\">module</span>.hot.accept(<span class=\"string\">'./a.js'</span>, () =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"change a.js\"</span>);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">    <span class=\"comment\">//如果是某人index.js的所有模块都采用热替换的话,则只需写</span></span><br><span class=\"line\">    <span class=\"comment\">//module.hot.accept(); 这样所有模块都采用热替换.</span></span><br><span class=\"line\">\t<span class=\"built_in\">module</span>.hot.decline(<span class=\"string\">'./component.js'</span>); <span class=\"comment\">//强制component.js的修改热更新失败,只能reload整个页面.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就已经可以实现热替换功能了,无论html,css,js etc.发生改变都会热替换那个模块,如果热替换失败的话,浏览器会自动刷新或者需要手动刷新,HMR会在控制台输出信息,可以查阅..</p>\n<h4 id=\"生产环境…-amp-开发环境…的配置文件\"><a href=\"#生产环境…-amp-开发环境…的配置文件\" class=\"headerlink\" title=\"生产环境…&amp; 开发环境…的配置文件.\"></a>生产环境…&amp; 开发环境…的配置文件.</h4><p>呃…一开始我是没有注意到这个生产环境跟开发环境之间所引用的配置的文件需要区别的东西的,看了官方的文档才知道,生产环境跟开发环境所用的配置文件不是完全相同的,官网推荐的那种手动方式,分别使用webpack.dev.js 和 webpack.prod.js 去区别开发环境跟生产环境,由于两个文件重复的东西太多,所以感觉效率不是很好..(懒得写两个,其实几乎差不多的文件)</p>\n<p>google了下,找到了一个我个人比较喜欢也容易理解的方法..</p>\n<p><code>webpack.config.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生产环境需要用到的配置文件的内容</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> prodConfig = &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开发环境需要用到的配置文件的内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">devConfig</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, prodConfig, config, &#123;<span class=\"attr\">plugins</span>: prodConfig.plugins.concat(config.plugins)&#125;)</span><br><span class=\"line\">  <span class=\"comment\">/*采用 Object.assign的方法,把几个对象复制到一个空对象上,形成一个新对象,拥有两个对象所有属性,如果属性名,属性值以后面对象的值为准.(后面的对象的值覆盖掉前面对象的值.)  因为plugins是个数组,所以需要用concat方法来将两个对象的plugins数组连接起来.*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再根据CLI时传的env的参数来确定使用什么环境下的配置文件</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">env</span>) </span>&#123;</span><br><span class=\"line\">  \t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"env is: \"</span>,env);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(env === <span class=\"string\">\"dev\"</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> devConfig();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> prodConfig;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>package.json</code></p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    \t<span class=\"attr\">\"dev\"</span>: <span class=\"string\">\"webpack-dev-server --inline --hot --env=dev --open\"</span>,</span><br><span class=\"line\">    \t<span class=\"attr\">\"build\"</span>: <span class=\"string\">\"rimraf build &amp;&amp; webpack -p --env=prod\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>rimraf</code>是用来每次build之前清空build文件夹的..</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install rimraf --save-v</span><br></pre></td></tr></table></figure>\n<p>这两天的webpack的入门学习大概就这些了(之前看了一些<a href=\"mailto:webpack@1.x\" target=\"_blank\" rel=\"noopener\">webpack@1.x</a> 和@2,x的学习教程,然后发现webpack已经出到3 了,干脆直接去官网啃文档了,不过这文档,真的是有点晦涩啊….)…webpack对于SPA(单页面应用来说还是挺不错的..),(主要是模块化),如果是多页面应用的话,用gulp来打包,压缩文件会更方便.. 等缓一缓再去学习下gulp,  …等到….掌握了,再去考虑,鱼跟熊掌怎么兼得的问题了.   路漫漫其修远兮,前方道路远又远又远啊….</p>\n<blockquote>\n<p>参考网站: <a href=\"https://doc.webpack-china.org/\" target=\"_blank\" rel=\"noopener\">webpack中文网</a></p>\n<p>​        <a href=\"http://www.cnblogs.com/stoneniqiu/p/6496425.html\" target=\"_blank\" rel=\"noopener\">webpack模块热替换</a></p>\n<p>etc.. 有些也忘了…  </p>\n<p>呃 还有参考github上一些项目的issues的解决办法, 发现….呃….英文真的很重要阿…orz..</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>这几天学习下了webpack,也做了demo,大概也了解webpack如何配置了…此篇是学习笔记…为了巩固刚学的知识..<br>","more":"<br>这次使用的是webpack的新版本3.x</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>新建一个文件夹， 使用<code>npm init</code> 快速配置package.json</p>\n<p>文件目录是这样的… src用来放资源文件, build用来放打包后的文件. </p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fhyoffw4egj206w0ayglx.jpg\" alt=\"\"></p>\n<h3 id=\"安装-webpack\"><a href=\"#安装-webpack\" class=\"headerlink\" title=\"安装 webpack\"></a>安装 webpack</h3><p>安装webpack &amp; webpack-dev-server<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install webpack webpack-dev-server--save-v</span><br></pre></td></tr></table></figure></p>\n<p>安装webpack-dev-server（开发服务器)用于开发，便于调试..可以实时监听数据改变并刷新页面（live reloading）</p>\n<p>至于 这里<code>--save</code>和 <code>--save-v</code>的区别<br><code>--save</code> 自动把模块和版本号添加到package.json配置文件的dependencies键对上<br><code>--save-v</code> 自动把模块和版本号添加到package.json的devdependencies键对上<br>devdependencies下列出的模块是开发时用的，它们不会被部署到生产环境中，dependencies下的模块，则是生产环境中需要的依赖。(dev指的是开发的意思, prod是生产production的缩写)</p>\n<p>永远不要在生产环境中使用开发工具…(我这里用在开发环境中的有webpack-dev-server)</p>\n<h2 id=\"webpack-config-js\"><a href=\"#webpack-config-js\" class=\"headerlink\" title=\"webpack.config.js\"></a>webpack.config.js</h2><p>在项目目录里新建一个<code>webpack.config.js</code>文件用来配置webpack.<br>webpack主要核心的东西就是 <code>entry(入口)</code>, <code>output(出口)</code>, <code>loader</code>, <code>plugins(插件)</code></p>\n<blockquote>\n<p>webpack工作概念: 当 webpack 处理应用程序时，它会递归地构建一个<strong>关系依赖图</strong>,其中包含程序需要的每个模块,然后将这些模块打包成少量的bundle,通常只有一个文件,再由浏览器加载..</p>\n</blockquote>\n<h3 id=\"entry（入口文件）\"><a href=\"#entry（入口文件）\" class=\"headerlink\" title=\"entry（入口文件）\"></a>entry（入口文件）</h3><p>webpack创建关系依赖图,图的起点称作<strong>入口起点</strong>,它告诉webpack从哪里开始,并根据<strong>关系依赖图</strong>来确定需要打包的内容.也可以称作启动文件.<br>单页面应用只有一个入口起点,多页面应用就有多个入口起点.  </p>\n<p><code>webpack-config.js</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">    home:  __dirname + <span class=\"string\">'/home.js'</span>,   <span class=\"comment\">//__dirname是node.js一个全局变量,指的是当前模块的目录名字.</span></span><br><span class=\"line\">    about: __dirname + <span class=\"string\">'/about.js'</span>,</span><br><span class=\"line\">    setting: __dirname + <span class=\"string\">'/setting.js'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>只有一个入口文件可以写成<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: __dirname + <span class=\"string\">'/src/index.js'</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"output-输出\"><a href=\"#output-输出\" class=\"headerlink\" title=\"output (输出)\"></a>output (输出)</h3><p><strong>输出你所打包的内容</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">output: &#123;</span><br><span class=\"line\">\tpath: __dirname + <span class=\"string\">\"/build\"</span>,  <span class=\"comment\">//路径</span></span><br><span class=\"line\">\tfilename: <span class=\"string\">\"bundle.js\"</span>\t\t <span class=\"comment\">//文件名</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"module-模块\"><a href=\"#module-模块\" class=\"headerlink\" title=\"module 模块\"></a>module 模块</h3><p>在模块化编程中，开发者将程序分解成离散功能块，并称之为模块<br>webpack把每个文件(.css,.html, .scss, .jpg, .png etc.)都作为模块处理, 然而,<strong>webpack自身只理解JavaScript</strong>  </p>\n<p>webpack的关系依赖图就是各个模块之间的依赖关系,模块之间的依赖关系可以通过这几种方式确定.  </p>\n<ol>\n<li><a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">ES6</a> 的 <code>import</code>语句  </li>\n<li><a href=\"http://javascript.ruanyifeng.com/nodejs/module.html\" target=\"_blank\" rel=\"noopener\">commonJS</a> 的<code>require()</code>语句  </li>\n<li><a href=\"http://zhaoda.net/webpack-handbook/amd.html\" target=\"_blank\" rel=\"noopener\">AMD</a>的 <code>define</code>和<code>require</code>语句  </li>\n<li>css/less/sass文件中的 <code>@import</code>语句  </li>\n<li>样式(<code>url(...)</code>)或 HTML 文件(<code>&lt;img src=...&gt;</code>)中的图片链接(image url)</li>\n</ol>\n<h4 id=\"module-rules\"><a href=\"#module-rules\" class=\"headerlink\" title=\"module.rules\"></a>module.rules</h4><p>之前版本的webpack是使用loaders的，webpack 2.x之后就使用rules了。<br><strong>rules</strong> ：(数组) 创建模块时，匹配请求的规则数组，这些规则能够对模块应用loader。  (loader又是什么)</p>\n<h4 id=\"loader又是什么\"><a href=\"#loader又是什么\" class=\"headerlink\" title=\"loader又是什么\"></a>loader又是什么</h4><p>loader描述了webpack如何处理非JavaScript(non-JavaScript)模块，并且在bundle中引入这些依赖.<br>loader 有两个目标  </p>\n<ol>\n<li>识别出应该被对应的loader进行转换的那些文件(test属性)  </li>\n<li>使用某个loader转换这些文件,使其能够被加入到关系依赖图中去,并最终添加到bundle中 (<span id=\"use\">use属性</span>)  </li>\n</ol>\n<h5 id=\"安装style-loader-amp-css-loader\"><a href=\"#安装style-loader-amp-css-loader\" class=\"headerlink\" title=\"安装style-loader &amp; css-loader\"></a>安装style-loader &amp; css-loader</h5><p><code>npm install style-loader css-loader --save-v</code></p>\n<p><code>webpack3的语法</code></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            test: /\\.css$/,  //一般是正则表达式</span><br><span class=\"line\">            use: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    loader: \"style-loader\"</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    loader: \"css-loader?modules\"  // ?modules 表示打开Css modules功能</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用一句通俗的话来讲吧..就是:  “喂,webpack编译器吗? 当你碰到require()语句或者 import语句中被解析为’.css’的路径时,在打包添加到bundle之前,先用  css-loader给他搞一下..然后再交给style-loader处理添加到style标签里..嵌入到JS代码中,恩,然后搞完再添加到bundle去”  </p>\n<p><strong>注:  模块的加载是从下到上的. 这里先加载css-loader 然后再加载style-loader</strong></p>\n<h6 id=\"安装-Babel\"><a href=\"#安装-Babel\" class=\"headerlink\" title=\"安装 Babel\"></a>安装 Babel</h6><p><code>npm install babel-core babel-preset-es2015 babel-loader --save-v</code>  </p>\n<ul>\n<li>babel-core 是Bebel的核心编译器,  </li>\n<li>babel-preset-es2015 是一个配置文件,我们可以把 ES2015的代码转化成ES5    </li>\n<li>babel-loader 用来编译JS文件</li>\n</ul>\n<p>修改<code>package.json</code>  在其中添加一个”babel”键</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;babel&quot;: &#123;</span><br><span class=\"line\">        &quot;presets&quot;: &#123;</span><br><span class=\"line\">            &quot;es2015&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Rule\"><a href=\"#Rule\" class=\"headerlink\" title=\"Rule\"></a>Rule</h4><p>Rule 能够根据rule筛选出来的模块对其应用loader</p>\n<p>每个规则可以分为三部分，   条件（condition），结果（result），嵌套规则（nested rule）</p>\n<h4 id=\"Rule-Conditions-规则条件\"><a href=\"#Rule-Conditions-规则条件\" class=\"headerlink\" title=\"Rule Conditions (规则条件)\"></a>Rule Conditions (规则条件)</h4><p>条件有两种输入值   </p>\n<ol>\n<li>resource：请求文件的绝对路径。它根据resolve规则解析</li>\n<li>issuer: 被请求资源（requested the resource）的模块文件的绝对路径。是导入的位置</li>\n</ol>\n<p>resource 有4个属性对其匹配 ：  </p>\n<ol>\n<li><code>test</code>  ：使用正则表达式匹配loader所处理的文件的拓展名</li>\n<li><code>include</code> ：添加必须处理的文件/文件夹</li>\n<li><code>exclude</code>： 屏蔽不需要处理的文件/文件夹</li>\n<li><code>resource</code></li>\n</ol>\n<p>条件可以是其中之一： </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test: <span class=\"regexp\">/\\.js$/</span> <span class=\"comment\">// 使用正则表达式</span></span><br><span class=\"line\">exclude: <span class=\"regexp\">/node_modules/</span>  <span class=\"comment\">//屏蔽拉黑node_modules此文件夹...</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Rule-result\"><a href=\"#Rule-result\" class=\"headerlink\" title=\"Rule result\"></a>Rule result</h4><p>rule result 只在 rule condition 匹配时使用</p>\n<p>用 <a href=\"#use\">use</a>属性</p>\n<h3 id=\"dev-tool\"><a href=\"#dev-tool\" class=\"headerlink\" title=\"dev-tool\"></a>dev-tool</h3><p>dev-tool : 开发者辅助调试工具 </p>\n<p><code>string</code> 默认值: <code>false</code></p>\n<p>选择一种source-map来增强调试过程,以下各种选先的构建和重构建速度不同..</p>\n<h4 id=\"source-map是什么\"><a href=\"#source-map是什么\" class=\"headerlink\" title=\"source-map是什么?\"></a>source-map是什么?</h4><blockquote>\n<p><a href=\"http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html\" target=\"_blank\" rel=\"noopener\">阮一峰的文章</a> source-map是一个信息文件, 里面存储着位置信息,转换后的代码的每一个位置,所对应的转换前的位置.  出错的时候, 工具报错(浏览器控制台)将直接显示原始代码,而不是转换后的代码.    </p>\n</blockquote>\n<p>source-map 文件可以存储位置信息,存储转换前的所有变量名和属性名, 存储转换前的文件.   </p>\n<p><strong>两个文件的各个位置是如何一一对应的?</strong></p>\n<p>source-map 文件也有一个属性用来存储转换前文件跟转换后文件的对应信息,如(对应的行号, 位置对应,)  </p>\n<p>在位置对应里,每个位置使用5位,表示5个字段, 分别表示</p>\n<ul>\n<li>这个位置在(转换后的代码)的第几列, </li>\n<li>这个位置属于转换前的文件的哪一个文件. </li>\n<li>这个位置属于转换前代码的第几行, </li>\n<li>这个位置属于转换前代码的第几列, </li>\n<li>这个位置属于转换前的所有变量和属性名的哪一个.   </li>\n</ul>\n<p>简单了解了这个东西,不深入去探讨..等到以后用到的话,再去进一步学习.</p>\n<p><img src=\"http://osuuzm0m8.bkt.clouddn.com/webpack.png\" alt=\"Alt text\">  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devtool: <span class=\"string\">'cheap-eval-source-map'</span></span><br></pre></td></tr></table></figure>\n<p>我在开发环境下是使用这个的, 报错有对应的行号提示,构建,重构建速度也快,相比较于eval, eval映射到的是转换后的代码,所以没有行号提示. 综合起来还是 <code>&quot;cheap-eval-source-map&quot;</code>比较合适..生产环境下我使用<code>&quot;cheap-source-map&quot;</code></p>\n<h3 id=\"devServer-（开发服务器）\"><a href=\"#devServer-（开发服务器）\" class=\"headerlink\" title=\"devServer （开发服务器）\"></a>devServer （开发服务器）</h3><p>webpack-dev-server 由webpack提供的一个本地开发服务器，可以让浏览器监测代码的修改，并自动刷新修改后的结果，提高效率。<br>webpack-dev-server.. 个人觉得最方便的就是自动刷新 &amp; 热重载<br><code>语法</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">\tcontentBase； path.join(__dirname, <span class=\"string\">'src'</span>), <span class=\"comment\">// 告知本地服务器从哪里提供内容.</span></span><br><span class=\"line\">\thistoryApiFallback: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\tport: <span class=\"number\">5555</span>  <span class=\"comment\">//默认是8080端口,可自定义</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在配置了开发服务器的话, 开发过程中监测着代码文件,当代码文件发生变化时, 可以自动刷新,重新构建网页.  </p>\n<p>但是过于频繁的刷新,当你的项目比较大时,reload页面需要等待的时间就比较长了,所以,dev-server还可以设置开启热替代.可以利用 插件 Hot Module Replacement 来实现.  模块热替换在程序运行时对模块修改,添加或者删除时,不需要重新加载整个页面,只更新改变内容.  </p>\n<p>有两种方式可以启用模块热替换,</p>\n<ul>\n<li><p>在 <code>webpack.config.js</code>文件中,</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">    new webpack.HotModuleReplacement()  //new一个HotModuleReplacement对象</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    inline: true, //采用inline模式.而不是iframe模式</span><br><span class=\"line\">    hot: true    //开启热替换</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样需要写的东西太对,所以我还是通过第二种方式, CLI命令行添加参数来开启</p>\n<p>所以我还是用第二种方式来开启..</p>\n</li>\n<li><p>CLI添加参数.  顺便把这段开启webpack的代码写到<code>package.json</code>的 <code>&quot;scripts&quot;</code>键上,  如下</p>\n<p>添加参数 <code>--line --hot</code></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\">\t\"dev\": \"webpack-dev-server --inline --hot --env=dev --open\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>直接在终端运行 <code>npm run dev</code>就可以开启开发服务器了.带有热重载的,不过此时热重载还没生效,因为还需要配置点其他东西.  </p>\n</li>\n</ul>\n<p>还需要修改的东西</p>\n<p>修改entry入口数组,</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">  main: [</span><br><span class=\"line\">      'webpack/hot/only-dev-server',  //在热更新失败后,需要采取手动刷新</span><br><span class=\"line\">      'webpack-dev-server/client?http://127.0.0.1:5555/',  //资源服务器,我这里是本地服务器localhost,如果需要远程服务器的资源就相应的更改就好了.</span><br><span class=\"line\">      './src/index.js'   //入口文件</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>index.js</code> (入口JS文件)  </p>\n<p>为了让html文件也可以采用热替换,需要把html当作一个模块来引入到<code>index.js</code>内</p>\n<p><code>index.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'./index.tpl.html'</span>);</span><br></pre></td></tr></table></figure>\n<p>也要在rules新建一个一个规则  </p>\n<p>html-loader需要先install</p>\n<p><code>npm install html-loader --save-v</code></p>\n<p><code>webpack.config.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            test: <span class=\"regexp\">/\\.html$/</span>,</span><br><span class=\"line\">            use: [<span class=\"string\">\"html-loader\"</span>]  <span class=\"comment\">//使用html-loader,将html内容存为js字符串.  </span></span><br><span class=\"line\">          \t\t\t\t\t\t  <span class=\"comment\">//遇到  require ('./index.tpl.html') </span></span><br><span class=\"line\">          \t\t\t\t\t\t  <span class=\"comment\">//index.tpl.html的内容会被转成一个Js字符串,合并到JS文件中</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>index.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(moduel.hot) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//module.hot.accept(dependencies, callback); //如果某个模块热替换后需要调用回调函数的就需要写这个.</span></span><br><span class=\"line\">\t<span class=\"built_in\">module</span>.hot.accept(<span class=\"string\">'./a.js'</span>, () =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"change a.js\"</span>);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">    <span class=\"comment\">//如果是某人index.js的所有模块都采用热替换的话,则只需写</span></span><br><span class=\"line\">    <span class=\"comment\">//module.hot.accept(); 这样所有模块都采用热替换.</span></span><br><span class=\"line\">\t<span class=\"built_in\">module</span>.hot.decline(<span class=\"string\">'./component.js'</span>); <span class=\"comment\">//强制component.js的修改热更新失败,只能reload整个页面.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就已经可以实现热替换功能了,无论html,css,js etc.发生改变都会热替换那个模块,如果热替换失败的话,浏览器会自动刷新或者需要手动刷新,HMR会在控制台输出信息,可以查阅..</p>\n<h4 id=\"生产环境…-amp-开发环境…的配置文件\"><a href=\"#生产环境…-amp-开发环境…的配置文件\" class=\"headerlink\" title=\"生产环境…&amp; 开发环境…的配置文件.\"></a>生产环境…&amp; 开发环境…的配置文件.</h4><p>呃…一开始我是没有注意到这个生产环境跟开发环境之间所引用的配置的文件需要区别的东西的,看了官方的文档才知道,生产环境跟开发环境所用的配置文件不是完全相同的,官网推荐的那种手动方式,分别使用webpack.dev.js 和 webpack.prod.js 去区别开发环境跟生产环境,由于两个文件重复的东西太多,所以感觉效率不是很好..(懒得写两个,其实几乎差不多的文件)</p>\n<p>google了下,找到了一个我个人比较喜欢也容易理解的方法..</p>\n<p><code>webpack.config.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生产环境需要用到的配置文件的内容</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> prodConfig = &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开发环境需要用到的配置文件的内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">devConfig</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, prodConfig, config, &#123;<span class=\"attr\">plugins</span>: prodConfig.plugins.concat(config.plugins)&#125;)</span><br><span class=\"line\">  <span class=\"comment\">/*采用 Object.assign的方法,把几个对象复制到一个空对象上,形成一个新对象,拥有两个对象所有属性,如果属性名,属性值以后面对象的值为准.(后面的对象的值覆盖掉前面对象的值.)  因为plugins是个数组,所以需要用concat方法来将两个对象的plugins数组连接起来.*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再根据CLI时传的env的参数来确定使用什么环境下的配置文件</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">env</span>) </span>&#123;</span><br><span class=\"line\">  \t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"env is: \"</span>,env);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(env === <span class=\"string\">\"dev\"</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> devConfig();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> prodConfig;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>package.json</code></p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    \t<span class=\"attr\">\"dev\"</span>: <span class=\"string\">\"webpack-dev-server --inline --hot --env=dev --open\"</span>,</span><br><span class=\"line\">    \t<span class=\"attr\">\"build\"</span>: <span class=\"string\">\"rimraf build &amp;&amp; webpack -p --env=prod\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>rimraf</code>是用来每次build之前清空build文件夹的..</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install rimraf --save-v</span><br></pre></td></tr></table></figure>\n<p>这两天的webpack的入门学习大概就这些了(之前看了一些<a href=\"mailto:webpack@1.x\" target=\"_blank\" rel=\"noopener\">webpack@1.x</a> 和@2,x的学习教程,然后发现webpack已经出到3 了,干脆直接去官网啃文档了,不过这文档,真的是有点晦涩啊….)…webpack对于SPA(单页面应用来说还是挺不错的..),(主要是模块化),如果是多页面应用的话,用gulp来打包,压缩文件会更方便.. 等缓一缓再去学习下gulp,  …等到….掌握了,再去考虑,鱼跟熊掌怎么兼得的问题了.   路漫漫其修远兮,前方道路远又远又远啊….</p>\n<blockquote>\n<p>参考网站: <a href=\"https://doc.webpack-china.org/\" target=\"_blank\" rel=\"noopener\">webpack中文网</a></p>\n<p>​        <a href=\"http://www.cnblogs.com/stoneniqiu/p/6496425.html\" target=\"_blank\" rel=\"noopener\">webpack模块热替换</a></p>\n<p>etc.. 有些也忘了…  </p>\n<p>呃 还有参考github上一些项目的issues的解决办法, 发现….呃….英文真的很重要阿…orz..</p>\n</blockquote>"},{"title":"学习Vue源码","date":"2018-03-22T16:00:00.000Z","_content":"\n记一次阅读Vue源码的总结.\n\n<!-- more -->\n\n## 响应式原理\n\nVue通过响应式在修改数据的时候更新视图。\n\n在官网copy的介绍响应式原理的图.\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fpcluuphejj20xc0kugnm.jpg)\n\n流向为： model -> view\n可以对表单元素`v-model`来进行双向数据绑定.\n\n\n### 数据劫持 & 将数据变成可观察的（Observable）\n\n``` javascript\n//   observer/index.js\n\n/**\n * Observer class that is attached to each observed\n * object. Once attached, the observer converts the target\n * object's property keys into getter/setters that\n * collect dependencies and dispatch updates.\n */\n// Observer是一个可以附加到每一个被观察的对象的类。一次附加，观察者将会将目标对象的属性键转化为拥有getter/setters的访问器属性，可以用来收集依赖（getter）和在属性有变化时分派通知更新（setter）\nexport class Observer {\n  value: any;\n  dep: Dep; //dep为一个Dep（依赖）类型\n  vmCount: number; // number of vms that has this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep() // 创建新的Dep实例\n    this.vmCount = 0\n\n    //前面还有一些对传入构造函数的参数的类型的判断，而这里执行的话，value是个对象，从下面的walk方法可以看出\n    this.walk(value)\n  }    \n\n    /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  //尤大这里注释的意思是，Wlak方法遍历传进来的对象的每一个属性，把它们转化为访问器属性（getter/setter），这个方法只在参数是对象类型的时候被调用.\n  walk (obj: Object) {\n    //用Object.keys方法获取obj对象的所有属性.\n    const keys = Object.keys(obj)\n    //遍历属性，defineReactive方法处理.\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n}\n\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\n\n/**\n * 尝试为一个value创建一个观察者实例，如果value已经拥有一个存\n * 的观察者实例，则返回它。\n * 如果成功创建了，则返回新的观察者实例.\n */\nexport function observe (value: any, asRootData: ?boolean): Observer | void {\n  //ob是一个Observer实例\n  let ob: Observer | void\n  // ...\n  // ...\n  //上面忽略的部分主要是防止为一个data重复创建Observer实例\n  ob = new Observer()\n  return ob  //返回一个Observer实例\n}\n\n\n/**\n * Define a reactive property on an Object.\n */\n/** 此方法用来定义一个对象的响应式属性 这里的reactive我理解为响应式.\n *  defineReactive方法\n */\n\nexport function defineReactive (\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: ?Function, //这里使用的是flow，一种静态类型检查工具.\n  shallow?: boolean  //shallow 浅的意思，应该是来判断val是一个基本属性还是引用属性吧.\n) {\n  //对obj对象里的key属性描述进行检索，返回一个描述符对象\n  const property = Object.getOwnPropertyDescriptor(obj, key)\n\n  //如果该属性描述符对象的configurable（能否修改属性）为false，则返回\n  if (property && property.configurable === false) {\n    return\n  }\n\n  //获取该属性已经定义了的 getter/setters 函数\n  // cater for pre-defined getter/setters\n  const getter = property && property.get\n  if (!getter && arguments.length === 2) {\n    //没有传入val参数且 getter不存在的话，val的值为key的value.\n    val = obj[key]\n  }\n  const setter = property && property.set\n\n  // 如果shallow为假，代表说val为一个对象，则递归调用ovserve方法来将子对象里的属性变成可观察的.\n  let childOb = !shallow && observe(val)\n\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      //如果getter存在，则调用getter获取到值\n      const value = getter ? getter.call(obj) : val\n      if (Dep.target) {\n        dep.depend() //将Dep.target指的watch实例与当前val的dep实例连接起来。将watch实例push进dep实例维护的订阅者数组.\n        if (childOb) {\n          childOb.dep.depend()\n          if (Array.isArray(value)) {\n            dependArray(value)\n          }\n        }\n      return value\n      // 主要是实现依赖收集。下面第二节分析Dep.\n    },\n    set: function reactiveSetter (newVal) {\n\n      //取得旧值value\n      const value = getter ? getter.call(obj) : val\n      /* eslint-disable no-self-compare */\n      //旧值value与newVal比较，若一样，跳出,不继续执行往下的操作。\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      \n      if (setter) {\n        //如果setter存在, 执行setter函数，传入obj的this，和传入参数newVal\n        setter.call(obj, newVal)\n      } else {\n        //不存在就直接把新值赋给val\n        val = newVal\n      }\n\n      // 如果shallow为假，代表说val为一个对象，则递归调用ovserve方法来将子对象里的属性变成可观察的.\n      childOb = !shallow && observe(newVal)\n\n      //通知在订阅者数组内的订阅者\n      dep.notify()\n    }\n  })\n}   \n\n```\n### 小结\n\n[initData源码](https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L107)\n``` javascript\n\nfunction initData (vm: Component) { \n    //...\n    //...\n    // observe data\n    observe(data, true /* asRootData */)\n}\n```\n`Vue`在其初始化时调用`observe`方法，为`data`对象的每个属性利用`Object.defineProperty()`方法给每个属性添加`getter`, `setter`，让每个属性都变成`observable`(可观察的).如果属性的`value`为一个对象的话，那么内部会递归调用`observe`方法来给子对象的属性创建观察者实例，使其变为`observable`的.\n(其实还会将template上的每个`v-`指令还有`computed`，`props`的数据全部转化为`observale`)\n\n当Vue进行render时，需要取数据，就会触发`getter`，进行依赖收集， （将订阅者(watcher)和观察者观察的（data）绑定起来）,修改某一个可观察属性时，就会触发该属性的`setter`，通知订阅者（watcher）进行更新操作.\n\n\n\n\n## 依赖（dependence）Dep\n\n这个dep对象上可以挂载多个订阅者\n``` javascript\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\n/**\n * 这里我理解为，一个dep实例可以挂载多个订阅者. \n */\nexport default class Dep {\n  static target: ?Watcher;\n  id: number;  //用来表示\n  subs: Array<Watcher>;\n\n  constructor () {\n    this.id = uid++\n    this.subs = []\n  }\n\n  // 将订阅者添加到subs数组\n  addSub (sub: Watcher) {\n    this.subs.push(sub)\n  }\n\n  //从subs里移除某个订阅者\n  removeSub (sub: Watcher) {\n    remove(this.subs, sub)\n  }\n\n  //用与将watcher与Dep的绑定\n  depend () {\n    if (Dep.target) {\n      Dep.target.addDep(this)\n    }\n  }\n\n  //通知， 通知subs里的所有订阅者（watcher实例）执行update操作\n  notify () {\n    // stabilize the subscriber list first\n    const subs = this.subs.slice()\n    for (let i = 0, l = subs.length; i < l; i++) {\n      subs[i].update()\n    }\n  }\n}\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\n// 这里定义了个全局变量 Dep.target，用于确定当前的watcher实例.任何时候只有一个watcher实例可以给评估.\n// 因为在watcher内部,当它要把自己加进某个data的订阅者数组里时，会将其自身赋给Dep.target，然后触发data的getter，这时就会将其push进subs数组，然后watch再把Dep.target置空.\nDep.target = null\n\n//一个target栈，用以评估watcher实例\nconst targetStack = []\n\n//这两个方法暴露给watcher使用.用于来给Dep.target指示一个watcher.\nexport function pushTarget (_target: ?Watcher) {\n  if (Dep.target) targetStack.push(Dep.target)\n  Dep.target = _target\n}\n\nexport function popTarget () {\n  Dep.target = targetStack.pop()\n}\n```\n### 小结\n\n读取数据，触发`observable` `data`的getter，通过`Dep`将data与订阅者添加一个依赖关系。一个data对应一个`Dep`实例，其有一个uniqueID，用来标识，其内部维护一个`subs`订阅者数组。当data改变，触发setter，会通过`Dep`实例来给subs里的所有订阅者通知更新。\n\n## Watcher 订阅者\n订阅者主要作用：\n1. 通过Dep（依赖）来为每个数据添加订阅者，当数据变化时，会通过`Dep`来通知订阅者进行`update`操作.\n2. 创建订阅者实例会传入一个cb函数，当update执行完后会执行这个cb函数。cb函数是用来执行re-render操作的，用于将新数据重新渲染到view上.\n\n这里就贴我自己写的`watch`\n``` javascript\nimport Dep from './dep'\n\nexport default class Watcher {\n    constructor(vm, exp, cb) {\n        this.vm = vm  //在vue源码里，这里是一个component\n        this.exp = exp //某个属性\n        this.cb = cb\n        this.value = this.get()\n    }\n\n    /**\n     * 调度者接口，当订阅数据更新时执行\n    */\n    update() {\n        console.log('订阅者里的update操作.');\n        this.run()\n    }\n\n    //用来触发getter获取到最新的新值.\n    get() {\n        Dep.target = this\n        let value = this.vm[this.exp] //触发key的getter，将自己添加为订阅者.\n        //添加完后\n        Dep.target = null;\n\n        return value;\n\n    }\n\n    /**\n     * 调度者工作接口，由调度者接口调用\n    */\n    // vue源码里 run执行后执行cb函数，视图重新渲染\n    run() {\n        let value = this.get()\n        console.log('run: ', value)\n        let oldVal = this.value\n\n        if(oldVal !== value) {\n            this.value = value\n            this.cb.call(this.vm, value, oldVal)\n            console.log(\"执行完毕回调\");\n        }\n    }\n}\n```\n### 对三者的一个小结\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fpcluuphejj20xc0kugnm.jpg)\n\n首先是组件渲染函数，进行一次render操作就会取到所有的数据，这时就会触发getter，(这里只取到了视图渲染需要的数据触发getter),从而进行依赖收集，`Data`可以看成与`Watcher`绑定在一起，但是我们知道他们中间是有个`Dep`在维护的他们的关系的，当触发getter时，将watcher添加到Dep的`subs`数组。数据改变时，触发setter，`Dep`通知`subs`里的所有watcher【你订阅的数据改变了】，watcher会触发update，而实际工作是由`run`来执行，判断新旧数据是否一致，如果数据真的改变了，则会触发watcher实例的cb函数，继续将工作交给compiler来做，最终结果会重新渲染视图（一般是渲染部分视图），因为vue也采用了virtual DOM技术，（用JS对象来模仿DOM节点，避免多次直接DOM操作，提高性能）监听到VNode变化时，会先通过diff算法，判断初始虚拟DOM树和改变后的虚拟DOM树是否有差别，具体哪里发生改变，思想是修改尽量少的DOM，进行尽量少的DOM操作，最后把发生改变的虚拟DOM元素应用到真实DOM上.（`patch`操作）\n\n再看上图. `touch`\n\n在源码`watcher.js`也看到`touch`，关于这个我自己是这样理解的.\n``` javascript\n//observer/watcher.js\n\n// ...\n\n// \"touch\" every property so they are all tracked as\n// dependencies for deep watching\nif (this.deep) {\n    traverse(value)\n}\n```\n\n\"touch\" every property so they are all tracked as dependencies for deep watching\n\n这里应该是来对值为`object` or `array`的进一步处理, 触发每个深层对象的依赖.\n\n图中的`touch`也可以理解为访问'touch' every needed property，多了个needed，就是访问所有需要用到的属性. \n\n\n## 自己的实现\n\n模仿Vue完成小作业， 因为还没有去看Vue的模版渲染，所以就只实现了Observer、Dep、Watcher这三者的逻辑关系，最终结果一个简单的观察订阅者模式的demo。\n\n[demo in github]()\n\n## 题外话\n\n浅尝辄止，这个词，来形容过去的学习生活，可以说是很形象很贴切了。\n\n最近也是在忙春招，也是会有点紧张和压抑，原因，`浅尝辄止`。\n\n反正，加油啦。自我安慰（学东西，慢一点没关系啦）。\n\n也是自己第一篇源码相关的总结，学习到不少，这篇主要还是给源码根据自己的理解添加中文注释，可能由很多地方有误。\n\n## link\n[Vue - github](https://github.com/vuejs/vue/blob/dev/src/core/observer)\n\n[柒陌 - github](https://github.com/answershuto/learnVue/blob/master/docs/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%86%8D%E7%9C%8B%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.MarkDown)\n\n[segmentfault](https://segmentfault.com/a/1190000006599500#articleHeader0)\n\n\n\n\n","source":"_posts/学习Vue源码（一）.md","raw":"---\ntitle: 学习Vue源码\ncategory: Vue\ntags: [Vue, JavaScript]\ndate: 2018-3-23\n---\n\n记一次阅读Vue源码的总结.\n\n<!-- more -->\n\n## 响应式原理\n\nVue通过响应式在修改数据的时候更新视图。\n\n在官网copy的介绍响应式原理的图.\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fpcluuphejj20xc0kugnm.jpg)\n\n流向为： model -> view\n可以对表单元素`v-model`来进行双向数据绑定.\n\n\n### 数据劫持 & 将数据变成可观察的（Observable）\n\n``` javascript\n//   observer/index.js\n\n/**\n * Observer class that is attached to each observed\n * object. Once attached, the observer converts the target\n * object's property keys into getter/setters that\n * collect dependencies and dispatch updates.\n */\n// Observer是一个可以附加到每一个被观察的对象的类。一次附加，观察者将会将目标对象的属性键转化为拥有getter/setters的访问器属性，可以用来收集依赖（getter）和在属性有变化时分派通知更新（setter）\nexport class Observer {\n  value: any;\n  dep: Dep; //dep为一个Dep（依赖）类型\n  vmCount: number; // number of vms that has this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep() // 创建新的Dep实例\n    this.vmCount = 0\n\n    //前面还有一些对传入构造函数的参数的类型的判断，而这里执行的话，value是个对象，从下面的walk方法可以看出\n    this.walk(value)\n  }    \n\n    /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  //尤大这里注释的意思是，Wlak方法遍历传进来的对象的每一个属性，把它们转化为访问器属性（getter/setter），这个方法只在参数是对象类型的时候被调用.\n  walk (obj: Object) {\n    //用Object.keys方法获取obj对象的所有属性.\n    const keys = Object.keys(obj)\n    //遍历属性，defineReactive方法处理.\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n}\n\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\n\n/**\n * 尝试为一个value创建一个观察者实例，如果value已经拥有一个存\n * 的观察者实例，则返回它。\n * 如果成功创建了，则返回新的观察者实例.\n */\nexport function observe (value: any, asRootData: ?boolean): Observer | void {\n  //ob是一个Observer实例\n  let ob: Observer | void\n  // ...\n  // ...\n  //上面忽略的部分主要是防止为一个data重复创建Observer实例\n  ob = new Observer()\n  return ob  //返回一个Observer实例\n}\n\n\n/**\n * Define a reactive property on an Object.\n */\n/** 此方法用来定义一个对象的响应式属性 这里的reactive我理解为响应式.\n *  defineReactive方法\n */\n\nexport function defineReactive (\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: ?Function, //这里使用的是flow，一种静态类型检查工具.\n  shallow?: boolean  //shallow 浅的意思，应该是来判断val是一个基本属性还是引用属性吧.\n) {\n  //对obj对象里的key属性描述进行检索，返回一个描述符对象\n  const property = Object.getOwnPropertyDescriptor(obj, key)\n\n  //如果该属性描述符对象的configurable（能否修改属性）为false，则返回\n  if (property && property.configurable === false) {\n    return\n  }\n\n  //获取该属性已经定义了的 getter/setters 函数\n  // cater for pre-defined getter/setters\n  const getter = property && property.get\n  if (!getter && arguments.length === 2) {\n    //没有传入val参数且 getter不存在的话，val的值为key的value.\n    val = obj[key]\n  }\n  const setter = property && property.set\n\n  // 如果shallow为假，代表说val为一个对象，则递归调用ovserve方法来将子对象里的属性变成可观察的.\n  let childOb = !shallow && observe(val)\n\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      //如果getter存在，则调用getter获取到值\n      const value = getter ? getter.call(obj) : val\n      if (Dep.target) {\n        dep.depend() //将Dep.target指的watch实例与当前val的dep实例连接起来。将watch实例push进dep实例维护的订阅者数组.\n        if (childOb) {\n          childOb.dep.depend()\n          if (Array.isArray(value)) {\n            dependArray(value)\n          }\n        }\n      return value\n      // 主要是实现依赖收集。下面第二节分析Dep.\n    },\n    set: function reactiveSetter (newVal) {\n\n      //取得旧值value\n      const value = getter ? getter.call(obj) : val\n      /* eslint-disable no-self-compare */\n      //旧值value与newVal比较，若一样，跳出,不继续执行往下的操作。\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      \n      if (setter) {\n        //如果setter存在, 执行setter函数，传入obj的this，和传入参数newVal\n        setter.call(obj, newVal)\n      } else {\n        //不存在就直接把新值赋给val\n        val = newVal\n      }\n\n      // 如果shallow为假，代表说val为一个对象，则递归调用ovserve方法来将子对象里的属性变成可观察的.\n      childOb = !shallow && observe(newVal)\n\n      //通知在订阅者数组内的订阅者\n      dep.notify()\n    }\n  })\n}   \n\n```\n### 小结\n\n[initData源码](https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L107)\n``` javascript\n\nfunction initData (vm: Component) { \n    //...\n    //...\n    // observe data\n    observe(data, true /* asRootData */)\n}\n```\n`Vue`在其初始化时调用`observe`方法，为`data`对象的每个属性利用`Object.defineProperty()`方法给每个属性添加`getter`, `setter`，让每个属性都变成`observable`(可观察的).如果属性的`value`为一个对象的话，那么内部会递归调用`observe`方法来给子对象的属性创建观察者实例，使其变为`observable`的.\n(其实还会将template上的每个`v-`指令还有`computed`，`props`的数据全部转化为`observale`)\n\n当Vue进行render时，需要取数据，就会触发`getter`，进行依赖收集， （将订阅者(watcher)和观察者观察的（data）绑定起来）,修改某一个可观察属性时，就会触发该属性的`setter`，通知订阅者（watcher）进行更新操作.\n\n\n\n\n## 依赖（dependence）Dep\n\n这个dep对象上可以挂载多个订阅者\n``` javascript\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\n/**\n * 这里我理解为，一个dep实例可以挂载多个订阅者. \n */\nexport default class Dep {\n  static target: ?Watcher;\n  id: number;  //用来表示\n  subs: Array<Watcher>;\n\n  constructor () {\n    this.id = uid++\n    this.subs = []\n  }\n\n  // 将订阅者添加到subs数组\n  addSub (sub: Watcher) {\n    this.subs.push(sub)\n  }\n\n  //从subs里移除某个订阅者\n  removeSub (sub: Watcher) {\n    remove(this.subs, sub)\n  }\n\n  //用与将watcher与Dep的绑定\n  depend () {\n    if (Dep.target) {\n      Dep.target.addDep(this)\n    }\n  }\n\n  //通知， 通知subs里的所有订阅者（watcher实例）执行update操作\n  notify () {\n    // stabilize the subscriber list first\n    const subs = this.subs.slice()\n    for (let i = 0, l = subs.length; i < l; i++) {\n      subs[i].update()\n    }\n  }\n}\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\n// 这里定义了个全局变量 Dep.target，用于确定当前的watcher实例.任何时候只有一个watcher实例可以给评估.\n// 因为在watcher内部,当它要把自己加进某个data的订阅者数组里时，会将其自身赋给Dep.target，然后触发data的getter，这时就会将其push进subs数组，然后watch再把Dep.target置空.\nDep.target = null\n\n//一个target栈，用以评估watcher实例\nconst targetStack = []\n\n//这两个方法暴露给watcher使用.用于来给Dep.target指示一个watcher.\nexport function pushTarget (_target: ?Watcher) {\n  if (Dep.target) targetStack.push(Dep.target)\n  Dep.target = _target\n}\n\nexport function popTarget () {\n  Dep.target = targetStack.pop()\n}\n```\n### 小结\n\n读取数据，触发`observable` `data`的getter，通过`Dep`将data与订阅者添加一个依赖关系。一个data对应一个`Dep`实例，其有一个uniqueID，用来标识，其内部维护一个`subs`订阅者数组。当data改变，触发setter，会通过`Dep`实例来给subs里的所有订阅者通知更新。\n\n## Watcher 订阅者\n订阅者主要作用：\n1. 通过Dep（依赖）来为每个数据添加订阅者，当数据变化时，会通过`Dep`来通知订阅者进行`update`操作.\n2. 创建订阅者实例会传入一个cb函数，当update执行完后会执行这个cb函数。cb函数是用来执行re-render操作的，用于将新数据重新渲染到view上.\n\n这里就贴我自己写的`watch`\n``` javascript\nimport Dep from './dep'\n\nexport default class Watcher {\n    constructor(vm, exp, cb) {\n        this.vm = vm  //在vue源码里，这里是一个component\n        this.exp = exp //某个属性\n        this.cb = cb\n        this.value = this.get()\n    }\n\n    /**\n     * 调度者接口，当订阅数据更新时执行\n    */\n    update() {\n        console.log('订阅者里的update操作.');\n        this.run()\n    }\n\n    //用来触发getter获取到最新的新值.\n    get() {\n        Dep.target = this\n        let value = this.vm[this.exp] //触发key的getter，将自己添加为订阅者.\n        //添加完后\n        Dep.target = null;\n\n        return value;\n\n    }\n\n    /**\n     * 调度者工作接口，由调度者接口调用\n    */\n    // vue源码里 run执行后执行cb函数，视图重新渲染\n    run() {\n        let value = this.get()\n        console.log('run: ', value)\n        let oldVal = this.value\n\n        if(oldVal !== value) {\n            this.value = value\n            this.cb.call(this.vm, value, oldVal)\n            console.log(\"执行完毕回调\");\n        }\n    }\n}\n```\n### 对三者的一个小结\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fpcluuphejj20xc0kugnm.jpg)\n\n首先是组件渲染函数，进行一次render操作就会取到所有的数据，这时就会触发getter，(这里只取到了视图渲染需要的数据触发getter),从而进行依赖收集，`Data`可以看成与`Watcher`绑定在一起，但是我们知道他们中间是有个`Dep`在维护的他们的关系的，当触发getter时，将watcher添加到Dep的`subs`数组。数据改变时，触发setter，`Dep`通知`subs`里的所有watcher【你订阅的数据改变了】，watcher会触发update，而实际工作是由`run`来执行，判断新旧数据是否一致，如果数据真的改变了，则会触发watcher实例的cb函数，继续将工作交给compiler来做，最终结果会重新渲染视图（一般是渲染部分视图），因为vue也采用了virtual DOM技术，（用JS对象来模仿DOM节点，避免多次直接DOM操作，提高性能）监听到VNode变化时，会先通过diff算法，判断初始虚拟DOM树和改变后的虚拟DOM树是否有差别，具体哪里发生改变，思想是修改尽量少的DOM，进行尽量少的DOM操作，最后把发生改变的虚拟DOM元素应用到真实DOM上.（`patch`操作）\n\n再看上图. `touch`\n\n在源码`watcher.js`也看到`touch`，关于这个我自己是这样理解的.\n``` javascript\n//observer/watcher.js\n\n// ...\n\n// \"touch\" every property so they are all tracked as\n// dependencies for deep watching\nif (this.deep) {\n    traverse(value)\n}\n```\n\n\"touch\" every property so they are all tracked as dependencies for deep watching\n\n这里应该是来对值为`object` or `array`的进一步处理, 触发每个深层对象的依赖.\n\n图中的`touch`也可以理解为访问'touch' every needed property，多了个needed，就是访问所有需要用到的属性. \n\n\n## 自己的实现\n\n模仿Vue完成小作业， 因为还没有去看Vue的模版渲染，所以就只实现了Observer、Dep、Watcher这三者的逻辑关系，最终结果一个简单的观察订阅者模式的demo。\n\n[demo in github]()\n\n## 题外话\n\n浅尝辄止，这个词，来形容过去的学习生活，可以说是很形象很贴切了。\n\n最近也是在忙春招，也是会有点紧张和压抑，原因，`浅尝辄止`。\n\n反正，加油啦。自我安慰（学东西，慢一点没关系啦）。\n\n也是自己第一篇源码相关的总结，学习到不少，这篇主要还是给源码根据自己的理解添加中文注释，可能由很多地方有误。\n\n## link\n[Vue - github](https://github.com/vuejs/vue/blob/dev/src/core/observer)\n\n[柒陌 - github](https://github.com/answershuto/learnVue/blob/master/docs/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%86%8D%E7%9C%8B%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.MarkDown)\n\n[segmentfault](https://segmentfault.com/a/1190000006599500#articleHeader0)\n\n\n\n\n","slug":"学习Vue源码（一）","published":1,"updated":"2018-03-22T16:34:53.279Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf81ehh80034v4ef995rp501","content":"<p>记一次阅读Vue源码的总结.</p>\n<a id=\"more\"></a>\n<h2 id=\"响应式原理\"><a href=\"#响应式原理\" class=\"headerlink\" title=\"响应式原理\"></a>响应式原理</h2><p>Vue通过响应式在修改数据的时候更新视图。</p>\n<p>在官网copy的介绍响应式原理的图.<br><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fpcluuphejj20xc0kugnm.jpg\" alt=\"\"></p>\n<p>流向为： model -&gt; view<br>可以对表单元素<code>v-model</code>来进行双向数据绑定.</p>\n<h3 id=\"数据劫持-amp-将数据变成可观察的（Observable）\"><a href=\"#数据劫持-amp-将数据变成可观察的（Observable）\" class=\"headerlink\" title=\"数据劫持 &amp; 将数据变成可观察的（Observable）\"></a>数据劫持 &amp; 将数据变成可观察的（Observable）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//   observer/index.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Observer class that is attached to each observed</span></span><br><span class=\"line\"><span class=\"comment\"> * object. Once attached, the observer converts the target</span></span><br><span class=\"line\"><span class=\"comment\"> * object's property keys into getter/setters that</span></span><br><span class=\"line\"><span class=\"comment\"> * collect dependencies and dispatch updates.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// Observer是一个可以附加到每一个被观察的对象的类。一次附加，观察者将会将目标对象的属性键转化为拥有getter/setters的访问器属性，可以用来收集依赖（getter）和在属性有变化时分派通知更新（setter）</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  value: any;</span><br><span class=\"line\">  dep: Dep; <span class=\"comment\">//dep为一个Dep（依赖）类型</span></span><br><span class=\"line\">  vmCount: number; <span class=\"comment\">// number of vms that has this object as root $data</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (value: any) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.dep = <span class=\"keyword\">new</span> Dep() <span class=\"comment\">// 创建新的Dep实例</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.vmCount = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//前面还有一些对传入构造函数的参数的类型的判断，而这里执行的话，value是个对象，从下面的walk方法可以看出</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.walk(value)</span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Walk through each property and convert them into</span></span><br><span class=\"line\"><span class=\"comment\">   * getter/setters. This method should only be called when</span></span><br><span class=\"line\"><span class=\"comment\">   * value type is Object.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"comment\">//尤大这里注释的意思是，Wlak方法遍历传进来的对象的每一个属性，把它们转化为访问器属性（getter/setter），这个方法只在参数是对象类型的时候被调用.</span></span><br><span class=\"line\">  walk (obj: <span class=\"built_in\">Object</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//用Object.keys方法获取obj对象的所有属性.</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> keys = <span class=\"built_in\">Object</span>.keys(obj)</span><br><span class=\"line\">    <span class=\"comment\">//遍历属性，defineReactive方法处理.</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class=\"line\">      defineReactive(obj, keys[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Attempt to create an observer instance for a value,</span></span><br><span class=\"line\"><span class=\"comment\"> * returns the new observer if successfully observed,</span></span><br><span class=\"line\"><span class=\"comment\"> * or the existing observer if the value already has one.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 尝试为一个value创建一个观察者实例，如果value已经拥有一个存</span></span><br><span class=\"line\"><span class=\"comment\"> * 的观察者实例，则返回它。</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果成功创建了，则返回新的观察者实例.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observe</span> (<span class=\"params\">value: any, asRootData: ?boolean</span>): <span class=\"title\">Observer</span> | <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//ob是一个Observer实例</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> ob: Observer | <span class=\"keyword\">void</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">//上面忽略的部分主要是防止为一个data重复创建Observer实例</span></span><br><span class=\"line\">  ob = <span class=\"keyword\">new</span> Observer()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ob  <span class=\"comment\">//返回一个Observer实例</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Define a reactive property on an Object.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/** 此方法用来定义一个对象的响应式属性 这里的reactive我理解为响应式.</span></span><br><span class=\"line\"><span class=\"comment\"> *  defineReactive方法</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineReactive</span> (<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  obj: Object,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  key: string,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  val: any,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  customSetter?: ?Function, <span class=\"regexp\">//</span>这里使用的是flow，一种静态类型检查工具.</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  shallow?: boolean  <span class=\"regexp\">//</span>shallow 浅的意思，应该是来判断val是一个基本属性还是引用属性吧.</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//对obj对象里的key属性描述进行检索，返回一个描述符对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> property = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//如果该属性描述符对象的configurable（能否修改属性）为false，则返回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (property &amp;&amp; property.configurable === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//获取该属性已经定义了的 getter/setters 函数</span></span><br><span class=\"line\">  <span class=\"comment\">// cater for pre-defined getter/setters</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> getter = property &amp;&amp; property.get</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!getter &amp;&amp; <span class=\"built_in\">arguments</span>.length === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//没有传入val参数且 getter不存在的话，val的值为key的value.</span></span><br><span class=\"line\">    val = obj[key]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> setter = property &amp;&amp; property.set</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 如果shallow为假，代表说val为一个对象，则递归调用ovserve方法来将子对象里的属性变成可观察的.</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(obj, key, &#123;</span><br><span class=\"line\">    enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    get: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reactiveGetter</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//如果getter存在，则调用getter获取到值</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> value = getter ? getter.call(obj) : val</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Dep.target) &#123;</span><br><span class=\"line\">        dep.depend() <span class=\"comment\">//将Dep.target指的watch实例与当前val的dep实例连接起来。将watch实例push进dep实例维护的订阅者数组.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childOb) &#123;</span><br><span class=\"line\">          childOb.dep.depend()</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(value)) &#123;</span><br><span class=\"line\">            dependArray(value)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value</span><br><span class=\"line\">      <span class=\"comment\">// 主要是实现依赖收集。下面第二节分析Dep.</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reactiveSetter</span> (<span class=\"params\">newVal</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//取得旧值value</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> value = getter ? getter.call(obj) : val</span><br><span class=\"line\">      <span class=\"comment\">/* eslint-disable no-self-compare */</span></span><br><span class=\"line\">      <span class=\"comment\">//旧值value与newVal比较，若一样，跳出,不继续执行往下的操作。</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (setter) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果setter存在, 执行setter函数，传入obj的this，和传入参数newVal</span></span><br><span class=\"line\">        setter.call(obj, newVal)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//不存在就直接把新值赋给val</span></span><br><span class=\"line\">        val = newVal</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 如果shallow为假，代表说val为一个对象，则递归调用ovserve方法来将子对象里的属性变成可观察的.</span></span><br><span class=\"line\">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//通知在订阅者数组内的订阅者</span></span><br><span class=\"line\">      dep.notify()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p><a href=\"https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L107\" target=\"_blank\" rel=\"noopener\">initData源码</a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initData</span> (<span class=\"params\">vm: Component</span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"comment\">// observe data</span></span><br><span class=\"line\">    observe(data, <span class=\"literal\">true</span> <span class=\"comment\">/* asRootData */</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>Vue</code>在其初始化时调用<code>observe</code>方法，为<code>data</code>对象的每个属性利用<code>Object.defineProperty()</code>方法给每个属性添加<code>getter</code>, <code>setter</code>，让每个属性都变成<code>observable</code>(可观察的).如果属性的<code>value</code>为一个对象的话，那么内部会递归调用<code>observe</code>方法来给子对象的属性创建观察者实例，使其变为<code>observable</code>的.<br>(其实还会将template上的每个<code>v-</code>指令还有<code>computed</code>，<code>props</code>的数据全部转化为<code>observale</code>)</p>\n<p>当Vue进行render时，需要取数据，就会触发<code>getter</code>，进行依赖收集， （将订阅者(watcher)和观察者观察的（data）绑定起来）,修改某一个可观察属性时，就会触发该属性的<code>setter</code>，通知订阅者（watcher）进行更新操作.</p>\n<h2 id=\"依赖（dependence）Dep\"><a href=\"#依赖（dependence）Dep\" class=\"headerlink\" title=\"依赖（dependence）Dep\"></a>依赖（dependence）Dep</h2><p>这个dep对象上可以挂载多个订阅者<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A dep is an observable that can have multiple</span></span><br><span class=\"line\"><span class=\"comment\"> * directives subscribing to it.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 这里我理解为，一个dep实例可以挂载多个订阅者. </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dep</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> target: ?Watcher;</span><br><span class=\"line\">  id: number;  <span class=\"comment\">//用来表示</span></span><br><span class=\"line\">  subs: <span class=\"built_in\">Array</span>&lt;Watcher&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.id = uid++</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subs = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将订阅者添加到subs数组</span></span><br><span class=\"line\">  addSub (sub: Watcher) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subs.push(sub)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//从subs里移除某个订阅者</span></span><br><span class=\"line\">  removeSub (sub: Watcher) &#123;</span><br><span class=\"line\">    remove(<span class=\"keyword\">this</span>.subs, sub)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//用与将watcher与Dep的绑定</span></span><br><span class=\"line\">  depend () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Dep.target) &#123;</span><br><span class=\"line\">      Dep.target.addDep(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//通知， 通知subs里的所有订阅者（watcher实例）执行update操作</span></span><br><span class=\"line\">  notify () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// stabilize the subscriber list first</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> subs = <span class=\"keyword\">this</span>.subs.slice()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">      subs[i].update()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// the current target watcher being evaluated.</span></span><br><span class=\"line\"><span class=\"comment\">// this is globally unique because there could be only one</span></span><br><span class=\"line\"><span class=\"comment\">// watcher being evaluated at any time.</span></span><br><span class=\"line\"><span class=\"comment\">// 这里定义了个全局变量 Dep.target，用于确定当前的watcher实例.任何时候只有一个watcher实例可以给评估.</span></span><br><span class=\"line\"><span class=\"comment\">// 因为在watcher内部,当它要把自己加进某个data的订阅者数组里时，会将其自身赋给Dep.target，然后触发data的getter，这时就会将其push进subs数组，然后watch再把Dep.target置空.</span></span><br><span class=\"line\">Dep.target = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一个target栈，用以评估watcher实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> targetStack = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这两个方法暴露给watcher使用.用于来给Dep.target指示一个watcher.</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pushTarget</span> (<span class=\"params\">_target: ?Watcher</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Dep.target) targetStack.push(Dep.target)</span><br><span class=\"line\">  Dep.target = _target</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">popTarget</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  Dep.target = targetStack.pop()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>读取数据，触发<code>observable</code> <code>data</code>的getter，通过<code>Dep</code>将data与订阅者添加一个依赖关系。一个data对应一个<code>Dep</code>实例，其有一个uniqueID，用来标识，其内部维护一个<code>subs</code>订阅者数组。当data改变，触发setter，会通过<code>Dep</code>实例来给subs里的所有订阅者通知更新。</p>\n<h2 id=\"Watcher-订阅者\"><a href=\"#Watcher-订阅者\" class=\"headerlink\" title=\"Watcher 订阅者\"></a>Watcher 订阅者</h2><p>订阅者主要作用：</p>\n<ol>\n<li>通过Dep（依赖）来为每个数据添加订阅者，当数据变化时，会通过<code>Dep</code>来通知订阅者进行<code>update</code>操作.</li>\n<li>创建订阅者实例会传入一个cb函数，当update执行完后会执行这个cb函数。cb函数是用来执行re-render操作的，用于将新数据重新渲染到view上.</li>\n</ol>\n<p>这里就贴我自己写的<code>watch</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Dep <span class=\"keyword\">from</span> <span class=\"string\">'./dep'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Watcher</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(vm, exp, cb) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.vm = vm  <span class=\"comment\">//在vue源码里，这里是一个component</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.exp = exp <span class=\"comment\">//某个属性</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cb = cb</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = <span class=\"keyword\">this</span>.get()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 调度者接口，当订阅数据更新时执行</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    update() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'订阅者里的update操作.'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.run()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用来触发getter获取到最新的新值.</span></span><br><span class=\"line\">    get() &#123;</span><br><span class=\"line\">        Dep.target = <span class=\"keyword\">this</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> value = <span class=\"keyword\">this</span>.vm[<span class=\"keyword\">this</span>.exp] <span class=\"comment\">//触发key的getter，将自己添加为订阅者.</span></span><br><span class=\"line\">        <span class=\"comment\">//添加完后</span></span><br><span class=\"line\">        Dep.target = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 调度者工作接口，由调度者接口调用</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"comment\">// vue源码里 run执行后执行cb函数，视图重新渲染</span></span><br><span class=\"line\">    run() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> value = <span class=\"keyword\">this</span>.get()</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'run: '</span>, value)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> oldVal = <span class=\"keyword\">this</span>.value</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(oldVal !== value) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.cb.call(<span class=\"keyword\">this</span>.vm, value, oldVal)</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"执行完毕回调\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"对三者的一个小结\"><a href=\"#对三者的一个小结\" class=\"headerlink\" title=\"对三者的一个小结\"></a>对三者的一个小结</h3><p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fpcluuphejj20xc0kugnm.jpg\" alt=\"\"></p>\n<p>首先是组件渲染函数，进行一次render操作就会取到所有的数据，这时就会触发getter，(这里只取到了视图渲染需要的数据触发getter),从而进行依赖收集，<code>Data</code>可以看成与<code>Watcher</code>绑定在一起，但是我们知道他们中间是有个<code>Dep</code>在维护的他们的关系的，当触发getter时，将watcher添加到Dep的<code>subs</code>数组。数据改变时，触发setter，<code>Dep</code>通知<code>subs</code>里的所有watcher【你订阅的数据改变了】，watcher会触发update，而实际工作是由<code>run</code>来执行，判断新旧数据是否一致，如果数据真的改变了，则会触发watcher实例的cb函数，继续将工作交给compiler来做，最终结果会重新渲染视图（一般是渲染部分视图），因为vue也采用了virtual DOM技术，（用JS对象来模仿DOM节点，避免多次直接DOM操作，提高性能）监听到VNode变化时，会先通过diff算法，判断初始虚拟DOM树和改变后的虚拟DOM树是否有差别，具体哪里发生改变，思想是修改尽量少的DOM，进行尽量少的DOM操作，最后把发生改变的虚拟DOM元素应用到真实DOM上.（<code>patch</code>操作）</p>\n<p>再看上图. <code>touch</code></p>\n<p>在源码<code>watcher.js</code>也看到<code>touch</code>，关于这个我自己是这样理解的.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//observer/watcher.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// \"touch\" every property so they are all tracked as</span></span><br><span class=\"line\"><span class=\"comment\">// dependencies for deep watching</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.deep) &#123;</span><br><span class=\"line\">    traverse(value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>“touch” every property so they are all tracked as dependencies for deep watching</p>\n<p>这里应该是来对值为<code>object</code> or <code>array</code>的进一步处理, 触发每个深层对象的依赖.</p>\n<p>图中的<code>touch</code>也可以理解为访问’touch’ every needed property，多了个needed，就是访问所有需要用到的属性. </p>\n<h2 id=\"自己的实现\"><a href=\"#自己的实现\" class=\"headerlink\" title=\"自己的实现\"></a>自己的实现</h2><p>模仿Vue完成小作业， 因为还没有去看Vue的模版渲染，所以就只实现了Observer、Dep、Watcher这三者的逻辑关系，最终结果一个简单的观察订阅者模式的demo。</p>\n<p><a href=\"\">demo in github</a></p>\n<h2 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h2><p>浅尝辄止，这个词，来形容过去的学习生活，可以说是很形象很贴切了。</p>\n<p>最近也是在忙春招，也是会有点紧张和压抑，原因，<code>浅尝辄止</code>。</p>\n<p>反正，加油啦。自我安慰（学东西，慢一点没关系啦）。</p>\n<p>也是自己第一篇源码相关的总结，学习到不少，这篇主要还是给源码根据自己的理解添加中文注释，可能由很多地方有误。</p>\n<h2 id=\"link\"><a href=\"#link\" class=\"headerlink\" title=\"link\"></a>link</h2><p><a href=\"https://github.com/vuejs/vue/blob/dev/src/core/observer\" target=\"_blank\" rel=\"noopener\">Vue - github</a></p>\n<p><a href=\"https://github.com/answershuto/learnVue/blob/master/docs/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%86%8D%E7%9C%8B%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.MarkDown\" target=\"_blank\" rel=\"noopener\">柒陌 - github</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000006599500#articleHeader0\" target=\"_blank\" rel=\"noopener\">segmentfault</a></p>\n","site":{"data":{}},"excerpt":"<p>记一次阅读Vue源码的总结.</p>","more":"<h2 id=\"响应式原理\"><a href=\"#响应式原理\" class=\"headerlink\" title=\"响应式原理\"></a>响应式原理</h2><p>Vue通过响应式在修改数据的时候更新视图。</p>\n<p>在官网copy的介绍响应式原理的图.<br><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fpcluuphejj20xc0kugnm.jpg\" alt=\"\"></p>\n<p>流向为： model -&gt; view<br>可以对表单元素<code>v-model</code>来进行双向数据绑定.</p>\n<h3 id=\"数据劫持-amp-将数据变成可观察的（Observable）\"><a href=\"#数据劫持-amp-将数据变成可观察的（Observable）\" class=\"headerlink\" title=\"数据劫持 &amp; 将数据变成可观察的（Observable）\"></a>数据劫持 &amp; 将数据变成可观察的（Observable）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//   observer/index.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Observer class that is attached to each observed</span></span><br><span class=\"line\"><span class=\"comment\"> * object. Once attached, the observer converts the target</span></span><br><span class=\"line\"><span class=\"comment\"> * object's property keys into getter/setters that</span></span><br><span class=\"line\"><span class=\"comment\"> * collect dependencies and dispatch updates.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// Observer是一个可以附加到每一个被观察的对象的类。一次附加，观察者将会将目标对象的属性键转化为拥有getter/setters的访问器属性，可以用来收集依赖（getter）和在属性有变化时分派通知更新（setter）</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  value: any;</span><br><span class=\"line\">  dep: Dep; <span class=\"comment\">//dep为一个Dep（依赖）类型</span></span><br><span class=\"line\">  vmCount: number; <span class=\"comment\">// number of vms that has this object as root $data</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (value: any) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.dep = <span class=\"keyword\">new</span> Dep() <span class=\"comment\">// 创建新的Dep实例</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.vmCount = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//前面还有一些对传入构造函数的参数的类型的判断，而这里执行的话，value是个对象，从下面的walk方法可以看出</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.walk(value)</span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Walk through each property and convert them into</span></span><br><span class=\"line\"><span class=\"comment\">   * getter/setters. This method should only be called when</span></span><br><span class=\"line\"><span class=\"comment\">   * value type is Object.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"comment\">//尤大这里注释的意思是，Wlak方法遍历传进来的对象的每一个属性，把它们转化为访问器属性（getter/setter），这个方法只在参数是对象类型的时候被调用.</span></span><br><span class=\"line\">  walk (obj: <span class=\"built_in\">Object</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//用Object.keys方法获取obj对象的所有属性.</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> keys = <span class=\"built_in\">Object</span>.keys(obj)</span><br><span class=\"line\">    <span class=\"comment\">//遍历属性，defineReactive方法处理.</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class=\"line\">      defineReactive(obj, keys[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Attempt to create an observer instance for a value,</span></span><br><span class=\"line\"><span class=\"comment\"> * returns the new observer if successfully observed,</span></span><br><span class=\"line\"><span class=\"comment\"> * or the existing observer if the value already has one.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 尝试为一个value创建一个观察者实例，如果value已经拥有一个存</span></span><br><span class=\"line\"><span class=\"comment\"> * 的观察者实例，则返回它。</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果成功创建了，则返回新的观察者实例.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observe</span> (<span class=\"params\">value: any, asRootData: ?boolean</span>): <span class=\"title\">Observer</span> | <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//ob是一个Observer实例</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> ob: Observer | <span class=\"keyword\">void</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">//上面忽略的部分主要是防止为一个data重复创建Observer实例</span></span><br><span class=\"line\">  ob = <span class=\"keyword\">new</span> Observer()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ob  <span class=\"comment\">//返回一个Observer实例</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Define a reactive property on an Object.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/** 此方法用来定义一个对象的响应式属性 这里的reactive我理解为响应式.</span></span><br><span class=\"line\"><span class=\"comment\"> *  defineReactive方法</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineReactive</span> (<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  obj: Object,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  key: string,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  val: any,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  customSetter?: ?Function, <span class=\"regexp\">//</span>这里使用的是flow，一种静态类型检查工具.</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  shallow?: boolean  <span class=\"regexp\">//</span>shallow 浅的意思，应该是来判断val是一个基本属性还是引用属性吧.</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//对obj对象里的key属性描述进行检索，返回一个描述符对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> property = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//如果该属性描述符对象的configurable（能否修改属性）为false，则返回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (property &amp;&amp; property.configurable === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//获取该属性已经定义了的 getter/setters 函数</span></span><br><span class=\"line\">  <span class=\"comment\">// cater for pre-defined getter/setters</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> getter = property &amp;&amp; property.get</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!getter &amp;&amp; <span class=\"built_in\">arguments</span>.length === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//没有传入val参数且 getter不存在的话，val的值为key的value.</span></span><br><span class=\"line\">    val = obj[key]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> setter = property &amp;&amp; property.set</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 如果shallow为假，代表说val为一个对象，则递归调用ovserve方法来将子对象里的属性变成可观察的.</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(obj, key, &#123;</span><br><span class=\"line\">    enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    get: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reactiveGetter</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//如果getter存在，则调用getter获取到值</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> value = getter ? getter.call(obj) : val</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Dep.target) &#123;</span><br><span class=\"line\">        dep.depend() <span class=\"comment\">//将Dep.target指的watch实例与当前val的dep实例连接起来。将watch实例push进dep实例维护的订阅者数组.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childOb) &#123;</span><br><span class=\"line\">          childOb.dep.depend()</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(value)) &#123;</span><br><span class=\"line\">            dependArray(value)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value</span><br><span class=\"line\">      <span class=\"comment\">// 主要是实现依赖收集。下面第二节分析Dep.</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reactiveSetter</span> (<span class=\"params\">newVal</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//取得旧值value</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> value = getter ? getter.call(obj) : val</span><br><span class=\"line\">      <span class=\"comment\">/* eslint-disable no-self-compare */</span></span><br><span class=\"line\">      <span class=\"comment\">//旧值value与newVal比较，若一样，跳出,不继续执行往下的操作。</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (setter) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果setter存在, 执行setter函数，传入obj的this，和传入参数newVal</span></span><br><span class=\"line\">        setter.call(obj, newVal)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//不存在就直接把新值赋给val</span></span><br><span class=\"line\">        val = newVal</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 如果shallow为假，代表说val为一个对象，则递归调用ovserve方法来将子对象里的属性变成可观察的.</span></span><br><span class=\"line\">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//通知在订阅者数组内的订阅者</span></span><br><span class=\"line\">      dep.notify()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p><a href=\"https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L107\" target=\"_blank\" rel=\"noopener\">initData源码</a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initData</span> (<span class=\"params\">vm: Component</span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"comment\">// observe data</span></span><br><span class=\"line\">    observe(data, <span class=\"literal\">true</span> <span class=\"comment\">/* asRootData */</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>Vue</code>在其初始化时调用<code>observe</code>方法，为<code>data</code>对象的每个属性利用<code>Object.defineProperty()</code>方法给每个属性添加<code>getter</code>, <code>setter</code>，让每个属性都变成<code>observable</code>(可观察的).如果属性的<code>value</code>为一个对象的话，那么内部会递归调用<code>observe</code>方法来给子对象的属性创建观察者实例，使其变为<code>observable</code>的.<br>(其实还会将template上的每个<code>v-</code>指令还有<code>computed</code>，<code>props</code>的数据全部转化为<code>observale</code>)</p>\n<p>当Vue进行render时，需要取数据，就会触发<code>getter</code>，进行依赖收集， （将订阅者(watcher)和观察者观察的（data）绑定起来）,修改某一个可观察属性时，就会触发该属性的<code>setter</code>，通知订阅者（watcher）进行更新操作.</p>\n<h2 id=\"依赖（dependence）Dep\"><a href=\"#依赖（dependence）Dep\" class=\"headerlink\" title=\"依赖（dependence）Dep\"></a>依赖（dependence）Dep</h2><p>这个dep对象上可以挂载多个订阅者<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A dep is an observable that can have multiple</span></span><br><span class=\"line\"><span class=\"comment\"> * directives subscribing to it.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 这里我理解为，一个dep实例可以挂载多个订阅者. </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dep</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> target: ?Watcher;</span><br><span class=\"line\">  id: number;  <span class=\"comment\">//用来表示</span></span><br><span class=\"line\">  subs: <span class=\"built_in\">Array</span>&lt;Watcher&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.id = uid++</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subs = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将订阅者添加到subs数组</span></span><br><span class=\"line\">  addSub (sub: Watcher) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subs.push(sub)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//从subs里移除某个订阅者</span></span><br><span class=\"line\">  removeSub (sub: Watcher) &#123;</span><br><span class=\"line\">    remove(<span class=\"keyword\">this</span>.subs, sub)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//用与将watcher与Dep的绑定</span></span><br><span class=\"line\">  depend () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Dep.target) &#123;</span><br><span class=\"line\">      Dep.target.addDep(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//通知， 通知subs里的所有订阅者（watcher实例）执行update操作</span></span><br><span class=\"line\">  notify () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// stabilize the subscriber list first</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> subs = <span class=\"keyword\">this</span>.subs.slice()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">      subs[i].update()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// the current target watcher being evaluated.</span></span><br><span class=\"line\"><span class=\"comment\">// this is globally unique because there could be only one</span></span><br><span class=\"line\"><span class=\"comment\">// watcher being evaluated at any time.</span></span><br><span class=\"line\"><span class=\"comment\">// 这里定义了个全局变量 Dep.target，用于确定当前的watcher实例.任何时候只有一个watcher实例可以给评估.</span></span><br><span class=\"line\"><span class=\"comment\">// 因为在watcher内部,当它要把自己加进某个data的订阅者数组里时，会将其自身赋给Dep.target，然后触发data的getter，这时就会将其push进subs数组，然后watch再把Dep.target置空.</span></span><br><span class=\"line\">Dep.target = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一个target栈，用以评估watcher实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> targetStack = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这两个方法暴露给watcher使用.用于来给Dep.target指示一个watcher.</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pushTarget</span> (<span class=\"params\">_target: ?Watcher</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Dep.target) targetStack.push(Dep.target)</span><br><span class=\"line\">  Dep.target = _target</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">popTarget</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  Dep.target = targetStack.pop()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>读取数据，触发<code>observable</code> <code>data</code>的getter，通过<code>Dep</code>将data与订阅者添加一个依赖关系。一个data对应一个<code>Dep</code>实例，其有一个uniqueID，用来标识，其内部维护一个<code>subs</code>订阅者数组。当data改变，触发setter，会通过<code>Dep</code>实例来给subs里的所有订阅者通知更新。</p>\n<h2 id=\"Watcher-订阅者\"><a href=\"#Watcher-订阅者\" class=\"headerlink\" title=\"Watcher 订阅者\"></a>Watcher 订阅者</h2><p>订阅者主要作用：</p>\n<ol>\n<li>通过Dep（依赖）来为每个数据添加订阅者，当数据变化时，会通过<code>Dep</code>来通知订阅者进行<code>update</code>操作.</li>\n<li>创建订阅者实例会传入一个cb函数，当update执行完后会执行这个cb函数。cb函数是用来执行re-render操作的，用于将新数据重新渲染到view上.</li>\n</ol>\n<p>这里就贴我自己写的<code>watch</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Dep <span class=\"keyword\">from</span> <span class=\"string\">'./dep'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Watcher</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(vm, exp, cb) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.vm = vm  <span class=\"comment\">//在vue源码里，这里是一个component</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.exp = exp <span class=\"comment\">//某个属性</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cb = cb</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = <span class=\"keyword\">this</span>.get()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 调度者接口，当订阅数据更新时执行</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    update() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'订阅者里的update操作.'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.run()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用来触发getter获取到最新的新值.</span></span><br><span class=\"line\">    get() &#123;</span><br><span class=\"line\">        Dep.target = <span class=\"keyword\">this</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> value = <span class=\"keyword\">this</span>.vm[<span class=\"keyword\">this</span>.exp] <span class=\"comment\">//触发key的getter，将自己添加为订阅者.</span></span><br><span class=\"line\">        <span class=\"comment\">//添加完后</span></span><br><span class=\"line\">        Dep.target = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 调度者工作接口，由调度者接口调用</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"comment\">// vue源码里 run执行后执行cb函数，视图重新渲染</span></span><br><span class=\"line\">    run() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> value = <span class=\"keyword\">this</span>.get()</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'run: '</span>, value)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> oldVal = <span class=\"keyword\">this</span>.value</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(oldVal !== value) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.cb.call(<span class=\"keyword\">this</span>.vm, value, oldVal)</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"执行完毕回调\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"对三者的一个小结\"><a href=\"#对三者的一个小结\" class=\"headerlink\" title=\"对三者的一个小结\"></a>对三者的一个小结</h3><p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fpcluuphejj20xc0kugnm.jpg\" alt=\"\"></p>\n<p>首先是组件渲染函数，进行一次render操作就会取到所有的数据，这时就会触发getter，(这里只取到了视图渲染需要的数据触发getter),从而进行依赖收集，<code>Data</code>可以看成与<code>Watcher</code>绑定在一起，但是我们知道他们中间是有个<code>Dep</code>在维护的他们的关系的，当触发getter时，将watcher添加到Dep的<code>subs</code>数组。数据改变时，触发setter，<code>Dep</code>通知<code>subs</code>里的所有watcher【你订阅的数据改变了】，watcher会触发update，而实际工作是由<code>run</code>来执行，判断新旧数据是否一致，如果数据真的改变了，则会触发watcher实例的cb函数，继续将工作交给compiler来做，最终结果会重新渲染视图（一般是渲染部分视图），因为vue也采用了virtual DOM技术，（用JS对象来模仿DOM节点，避免多次直接DOM操作，提高性能）监听到VNode变化时，会先通过diff算法，判断初始虚拟DOM树和改变后的虚拟DOM树是否有差别，具体哪里发生改变，思想是修改尽量少的DOM，进行尽量少的DOM操作，最后把发生改变的虚拟DOM元素应用到真实DOM上.（<code>patch</code>操作）</p>\n<p>再看上图. <code>touch</code></p>\n<p>在源码<code>watcher.js</code>也看到<code>touch</code>，关于这个我自己是这样理解的.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//observer/watcher.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// \"touch\" every property so they are all tracked as</span></span><br><span class=\"line\"><span class=\"comment\">// dependencies for deep watching</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.deep) &#123;</span><br><span class=\"line\">    traverse(value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>“touch” every property so they are all tracked as dependencies for deep watching</p>\n<p>这里应该是来对值为<code>object</code> or <code>array</code>的进一步处理, 触发每个深层对象的依赖.</p>\n<p>图中的<code>touch</code>也可以理解为访问’touch’ every needed property，多了个needed，就是访问所有需要用到的属性. </p>\n<h2 id=\"自己的实现\"><a href=\"#自己的实现\" class=\"headerlink\" title=\"自己的实现\"></a>自己的实现</h2><p>模仿Vue完成小作业， 因为还没有去看Vue的模版渲染，所以就只实现了Observer、Dep、Watcher这三者的逻辑关系，最终结果一个简单的观察订阅者模式的demo。</p>\n<p><a href=\"\">demo in github</a></p>\n<h2 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h2><p>浅尝辄止，这个词，来形容过去的学习生活，可以说是很形象很贴切了。</p>\n<p>最近也是在忙春招，也是会有点紧张和压抑，原因，<code>浅尝辄止</code>。</p>\n<p>反正，加油啦。自我安慰（学东西，慢一点没关系啦）。</p>\n<p>也是自己第一篇源码相关的总结，学习到不少，这篇主要还是给源码根据自己的理解添加中文注释，可能由很多地方有误。</p>\n<h2 id=\"link\"><a href=\"#link\" class=\"headerlink\" title=\"link\"></a>link</h2><p><a href=\"https://github.com/vuejs/vue/blob/dev/src/core/observer\" target=\"_blank\" rel=\"noopener\">Vue - github</a></p>\n<p><a href=\"https://github.com/answershuto/learnVue/blob/master/docs/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%86%8D%E7%9C%8B%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.MarkDown\" target=\"_blank\" rel=\"noopener\">柒陌 - github</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000006599500#articleHeader0\" target=\"_blank\" rel=\"noopener\">segmentfault</a></p>"},{"title":"数组去重","date":"2018-03-17T16:00:00.000Z","_content":"## 数组去重\n\n整理下数组去重的几种方法.\n\n<!-- more -->\n\n## 第一种\n先将数组`排序`，变量result存储结果数组，将原数组的每一项与结果数组的最后一项比较，如果不相等，则将其push进result数组。\n\n缺点，数组最终结果是有序的。如果不想要有序的结果，则采用二、三、四的实现。\n\n```\nvar testArray = [6,6,3,4,5,1,7,4,1,2]\n\nArray.prototype.unique1 = function() {\n    this.sort((a,b) => a-b);\n    var result = [];\n\n    this.forEach((e, idx) => {\n        if(idx === 0) {\n            result.push(e)\n        }\n\n        if(e !== result[result.length-1]) {\n            result.push(e)\n        }\n    })\n\n    return result;\n}\n\n//更加简便的写法.思路是一样的\nArray.prototype.unique2 = function() {\n\n    return this.sort((a,b) => a-b).reduce((result, e) => {\n        if(result.length === 0 || e !== result[result.length-1]) {\n            result.push(e)\n        }\n        return result;\n    }, [])\n}\n\n```\n\n可以利用数组的reduce方法来简写代码.\n\n## 第二种\nES6。 只需要用一行代码. 很简洁. \n`Set`本身是一个构造函数，可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数来初始化.\n\n主要是利用的`Set`这个新的数据结构的特性，就是其内部成员的值都是唯一的，没有重复.\n还有就是`Set`数据结构本身具有`Iterator`接口，说明`Set`数据结构是可遍历的.\n\nES6的扩展运算符`...`可以将实现了`Iterator`接口的对象，转化为真正的数组\n\n\n```\nvar result = [...new Set(testArray)];\n```\n\n## 第三种\n\n利用indexOf()方法，返回在数组中找到第一个给定元素的索引值，如果没找到，则返回-1\n\n```\nArray.prototype.unique3 = function() {\n    var result = [];\n\n    this.forEach((e, idx) => {\n        if(result.length === 0 || result.indexOf(e) === -1) {\n            result.push(e)\n        }\n    })\n\n    return result;\n}\n```\n\n内部利用Array.prototype的indexOf()方法，对待去重数组里的每一个元素，在result数组中寻找第一次出现的索引值，如果为-1，则说明该元素没有在result数组里，则将其添加到result数组里.\n\n## 第四种\n利用一个空对象来比较，用一个循环来遍历数组，每遍历到一个元素，就用这个元素作为key去对象中访问，如果访问得到的话，就说明重复了，反之，则把该元素加入到result数组中，并将此元素作为对象的属性，赋值为1。\n这种办法虽然也是只用到了一次循环，可它也有局限性.\n\n``` javascript\nArray.prototype.unique4 = function() {\n    var obj = {},\n        result = [];\n    for(let i = 0; i < this.length; i++) {\n        if(!obj[this[i]]) {\n            result.push(this[i]);\n            obj[this[i]] = 1;\n        } \n    }\n    console.log(obj)\n    return result;\n}\n```\n如果测试数组的格式为[1, 2, 3, '1', '2', '3']，如果我们想要的最终结果是[1, 2, 3, '1', '2', '3'],使用第四种办法得出的结果只会是[1, 2, 3]. 之所以出现这种情况，是因为JavaScript的对象的键类型只能为字符串.\n\n> 一个对象的属性名可以是任何有效的 JavaScript 字符串，或者**可以被转换为字符串的任何类型**，包括**空字符串**. ----[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects)\n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fph2vk21cbj20bg05tt8s.jpg)\n\n可以看到，后面的属性1,覆盖了前面的属性\"1\"，`temp`现在其实只有两个属性，`\"\"`和`\"1\"`.遍历对象的key，输出每个key的类型，发现都是string.说明就算是数字类型的键，JS内部还会把它转换成字符串.\n\n所以这种方法其实并不是很适用于一个既有数字又有字符串的数组.因为很可能会出现上面的情况.这也是这种方法的局限性.\n\n## 第五种\n利用两个循环来比较，这个效率没上面的其他实现方法高，这里就不写了.","source":"_posts/数组去重.md","raw":"---\ntitle: 数组去重\ncategory: JavaScript\ntags: [Array]\ndate: 2018-03-18\n---\n## 数组去重\n\n整理下数组去重的几种方法.\n\n<!-- more -->\n\n## 第一种\n先将数组`排序`，变量result存储结果数组，将原数组的每一项与结果数组的最后一项比较，如果不相等，则将其push进result数组。\n\n缺点，数组最终结果是有序的。如果不想要有序的结果，则采用二、三、四的实现。\n\n```\nvar testArray = [6,6,3,4,5,1,7,4,1,2]\n\nArray.prototype.unique1 = function() {\n    this.sort((a,b) => a-b);\n    var result = [];\n\n    this.forEach((e, idx) => {\n        if(idx === 0) {\n            result.push(e)\n        }\n\n        if(e !== result[result.length-1]) {\n            result.push(e)\n        }\n    })\n\n    return result;\n}\n\n//更加简便的写法.思路是一样的\nArray.prototype.unique2 = function() {\n\n    return this.sort((a,b) => a-b).reduce((result, e) => {\n        if(result.length === 0 || e !== result[result.length-1]) {\n            result.push(e)\n        }\n        return result;\n    }, [])\n}\n\n```\n\n可以利用数组的reduce方法来简写代码.\n\n## 第二种\nES6。 只需要用一行代码. 很简洁. \n`Set`本身是一个构造函数，可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数来初始化.\n\n主要是利用的`Set`这个新的数据结构的特性，就是其内部成员的值都是唯一的，没有重复.\n还有就是`Set`数据结构本身具有`Iterator`接口，说明`Set`数据结构是可遍历的.\n\nES6的扩展运算符`...`可以将实现了`Iterator`接口的对象，转化为真正的数组\n\n\n```\nvar result = [...new Set(testArray)];\n```\n\n## 第三种\n\n利用indexOf()方法，返回在数组中找到第一个给定元素的索引值，如果没找到，则返回-1\n\n```\nArray.prototype.unique3 = function() {\n    var result = [];\n\n    this.forEach((e, idx) => {\n        if(result.length === 0 || result.indexOf(e) === -1) {\n            result.push(e)\n        }\n    })\n\n    return result;\n}\n```\n\n内部利用Array.prototype的indexOf()方法，对待去重数组里的每一个元素，在result数组中寻找第一次出现的索引值，如果为-1，则说明该元素没有在result数组里，则将其添加到result数组里.\n\n## 第四种\n利用一个空对象来比较，用一个循环来遍历数组，每遍历到一个元素，就用这个元素作为key去对象中访问，如果访问得到的话，就说明重复了，反之，则把该元素加入到result数组中，并将此元素作为对象的属性，赋值为1。\n这种办法虽然也是只用到了一次循环，可它也有局限性.\n\n``` javascript\nArray.prototype.unique4 = function() {\n    var obj = {},\n        result = [];\n    for(let i = 0; i < this.length; i++) {\n        if(!obj[this[i]]) {\n            result.push(this[i]);\n            obj[this[i]] = 1;\n        } \n    }\n    console.log(obj)\n    return result;\n}\n```\n如果测试数组的格式为[1, 2, 3, '1', '2', '3']，如果我们想要的最终结果是[1, 2, 3, '1', '2', '3'],使用第四种办法得出的结果只会是[1, 2, 3]. 之所以出现这种情况，是因为JavaScript的对象的键类型只能为字符串.\n\n> 一个对象的属性名可以是任何有效的 JavaScript 字符串，或者**可以被转换为字符串的任何类型**，包括**空字符串**. ----[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects)\n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fph2vk21cbj20bg05tt8s.jpg)\n\n可以看到，后面的属性1,覆盖了前面的属性\"1\"，`temp`现在其实只有两个属性，`\"\"`和`\"1\"`.遍历对象的key，输出每个key的类型，发现都是string.说明就算是数字类型的键，JS内部还会把它转换成字符串.\n\n所以这种方法其实并不是很适用于一个既有数字又有字符串的数组.因为很可能会出现上面的情况.这也是这种方法的局限性.\n\n## 第五种\n利用两个循环来比较，这个效率没上面的其他实现方法高，这里就不写了.","slug":"数组去重","published":1,"updated":"2018-03-18T09:31:59.806Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf81ehhd0036v4efr2xsin8o","content":"<h2 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h2><p>整理下数组去重的几种方法.</p>\n<a id=\"more\"></a>\n<h2 id=\"第一种\"><a href=\"#第一种\" class=\"headerlink\" title=\"第一种\"></a>第一种</h2><p>先将数组<code>排序</code>，变量result存储结果数组，将原数组的每一项与结果数组的最后一项比较，如果不相等，则将其push进result数组。</p>\n<p>缺点，数组最终结果是有序的。如果不想要有序的结果，则采用二、三、四的实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var testArray = [6,6,3,4,5,1,7,4,1,2]</span><br><span class=\"line\"></span><br><span class=\"line\">Array.prototype.unique1 = function() &#123;</span><br><span class=\"line\">    this.sort((a,b) =&gt; a-b);</span><br><span class=\"line\">    var result = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    this.forEach((e, idx) =&gt; &#123;</span><br><span class=\"line\">        if(idx === 0) &#123;</span><br><span class=\"line\">            result.push(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if(e !== result[result.length-1]) &#123;</span><br><span class=\"line\">            result.push(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//更加简便的写法.思路是一样的</span><br><span class=\"line\">Array.prototype.unique2 = function() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    return this.sort((a,b) =&gt; a-b).reduce((result, e) =&gt; &#123;</span><br><span class=\"line\">        if(result.length === 0 || e !== result[result.length-1]) &#123;</span><br><span class=\"line\">            result.push(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;, [])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以利用数组的reduce方法来简写代码.</p>\n<h2 id=\"第二种\"><a href=\"#第二种\" class=\"headerlink\" title=\"第二种\"></a>第二种</h2><p>ES6。 只需要用一行代码. 很简洁.<br><code>Set</code>本身是一个构造函数，可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数来初始化.</p>\n<p>主要是利用的<code>Set</code>这个新的数据结构的特性，就是其内部成员的值都是唯一的，没有重复.<br>还有就是<code>Set</code>数据结构本身具有<code>Iterator</code>接口，说明<code>Set</code>数据结构是可遍历的.</p>\n<p>ES6的扩展运算符<code>...</code>可以将实现了<code>Iterator</code>接口的对象，转化为真正的数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var result = [...new Set(testArray)];</span><br></pre></td></tr></table></figure>\n<h2 id=\"第三种\"><a href=\"#第三种\" class=\"headerlink\" title=\"第三种\"></a>第三种</h2><p>利用indexOf()方法，返回在数组中找到第一个给定元素的索引值，如果没找到，则返回-1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.unique3 = function() &#123;</span><br><span class=\"line\">    var result = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    this.forEach((e, idx) =&gt; &#123;</span><br><span class=\"line\">        if(result.length === 0 || result.indexOf(e) === -1) &#123;</span><br><span class=\"line\">            result.push(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>内部利用Array.prototype的indexOf()方法，对待去重数组里的每一个元素，在result数组中寻找第一次出现的索引值，如果为-1，则说明该元素没有在result数组里，则将其添加到result数组里.</p>\n<h2 id=\"第四种\"><a href=\"#第四种\" class=\"headerlink\" title=\"第四种\"></a>第四种</h2><p>利用一个空对象来比较，用一个循环来遍历数组，每遍历到一个元素，就用这个元素作为key去对象中访问，如果访问得到的话，就说明重复了，反之，则把该元素加入到result数组中，并将此元素作为对象的属性，赋值为1。<br>这种办法虽然也是只用到了一次循环，可它也有局限性.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.unique4 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = &#123;&#125;,</span><br><span class=\"line\">        result = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!obj[<span class=\"keyword\">this</span>[i]]) &#123;</span><br><span class=\"line\">            result.push(<span class=\"keyword\">this</span>[i]);</span><br><span class=\"line\">            obj[<span class=\"keyword\">this</span>[i]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(obj)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果测试数组的格式为[1, 2, 3, ‘1’, ‘2’, ‘3’]，如果我们想要的最终结果是[1, 2, 3, ‘1’, ‘2’, ‘3’],使用第四种办法得出的结果只会是[1, 2, 3]. 之所以出现这种情况，是因为JavaScript的对象的键类型只能为字符串.</p>\n<blockquote>\n<p>一个对象的属性名可以是任何有效的 JavaScript 字符串，或者<strong>可以被转换为字符串的任何类型</strong>，包括<strong>空字符串</strong>. —-<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n</blockquote>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fph2vk21cbj20bg05tt8s.jpg\" alt=\"\"></p>\n<p>可以看到，后面的属性1,覆盖了前面的属性”1”，<code>temp</code>现在其实只有两个属性，<code>&quot;&quot;</code>和<code>&quot;1&quot;</code>.遍历对象的key，输出每个key的类型，发现都是string.说明就算是数字类型的键，JS内部还会把它转换成字符串.</p>\n<p>所以这种方法其实并不是很适用于一个既有数字又有字符串的数组.因为很可能会出现上面的情况.这也是这种方法的局限性.</p>\n<h2 id=\"第五种\"><a href=\"#第五种\" class=\"headerlink\" title=\"第五种\"></a>第五种</h2><p>利用两个循环来比较，这个效率没上面的其他实现方法高，这里就不写了.</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h2><p>整理下数组去重的几种方法.</p>","more":"<h2 id=\"第一种\"><a href=\"#第一种\" class=\"headerlink\" title=\"第一种\"></a>第一种</h2><p>先将数组<code>排序</code>，变量result存储结果数组，将原数组的每一项与结果数组的最后一项比较，如果不相等，则将其push进result数组。</p>\n<p>缺点，数组最终结果是有序的。如果不想要有序的结果，则采用二、三、四的实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var testArray = [6,6,3,4,5,1,7,4,1,2]</span><br><span class=\"line\"></span><br><span class=\"line\">Array.prototype.unique1 = function() &#123;</span><br><span class=\"line\">    this.sort((a,b) =&gt; a-b);</span><br><span class=\"line\">    var result = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    this.forEach((e, idx) =&gt; &#123;</span><br><span class=\"line\">        if(idx === 0) &#123;</span><br><span class=\"line\">            result.push(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if(e !== result[result.length-1]) &#123;</span><br><span class=\"line\">            result.push(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//更加简便的写法.思路是一样的</span><br><span class=\"line\">Array.prototype.unique2 = function() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    return this.sort((a,b) =&gt; a-b).reduce((result, e) =&gt; &#123;</span><br><span class=\"line\">        if(result.length === 0 || e !== result[result.length-1]) &#123;</span><br><span class=\"line\">            result.push(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;, [])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以利用数组的reduce方法来简写代码.</p>\n<h2 id=\"第二种\"><a href=\"#第二种\" class=\"headerlink\" title=\"第二种\"></a>第二种</h2><p>ES6。 只需要用一行代码. 很简洁.<br><code>Set</code>本身是一个构造函数，可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数来初始化.</p>\n<p>主要是利用的<code>Set</code>这个新的数据结构的特性，就是其内部成员的值都是唯一的，没有重复.<br>还有就是<code>Set</code>数据结构本身具有<code>Iterator</code>接口，说明<code>Set</code>数据结构是可遍历的.</p>\n<p>ES6的扩展运算符<code>...</code>可以将实现了<code>Iterator</code>接口的对象，转化为真正的数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var result = [...new Set(testArray)];</span><br></pre></td></tr></table></figure>\n<h2 id=\"第三种\"><a href=\"#第三种\" class=\"headerlink\" title=\"第三种\"></a>第三种</h2><p>利用indexOf()方法，返回在数组中找到第一个给定元素的索引值，如果没找到，则返回-1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.unique3 = function() &#123;</span><br><span class=\"line\">    var result = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    this.forEach((e, idx) =&gt; &#123;</span><br><span class=\"line\">        if(result.length === 0 || result.indexOf(e) === -1) &#123;</span><br><span class=\"line\">            result.push(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>内部利用Array.prototype的indexOf()方法，对待去重数组里的每一个元素，在result数组中寻找第一次出现的索引值，如果为-1，则说明该元素没有在result数组里，则将其添加到result数组里.</p>\n<h2 id=\"第四种\"><a href=\"#第四种\" class=\"headerlink\" title=\"第四种\"></a>第四种</h2><p>利用一个空对象来比较，用一个循环来遍历数组，每遍历到一个元素，就用这个元素作为key去对象中访问，如果访问得到的话，就说明重复了，反之，则把该元素加入到result数组中，并将此元素作为对象的属性，赋值为1。<br>这种办法虽然也是只用到了一次循环，可它也有局限性.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.unique4 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = &#123;&#125;,</span><br><span class=\"line\">        result = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!obj[<span class=\"keyword\">this</span>[i]]) &#123;</span><br><span class=\"line\">            result.push(<span class=\"keyword\">this</span>[i]);</span><br><span class=\"line\">            obj[<span class=\"keyword\">this</span>[i]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(obj)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果测试数组的格式为[1, 2, 3, ‘1’, ‘2’, ‘3’]，如果我们想要的最终结果是[1, 2, 3, ‘1’, ‘2’, ‘3’],使用第四种办法得出的结果只会是[1, 2, 3]. 之所以出现这种情况，是因为JavaScript的对象的键类型只能为字符串.</p>\n<blockquote>\n<p>一个对象的属性名可以是任何有效的 JavaScript 字符串，或者<strong>可以被转换为字符串的任何类型</strong>，包括<strong>空字符串</strong>. —-<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n</blockquote>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fph2vk21cbj20bg05tt8s.jpg\" alt=\"\"></p>\n<p>可以看到，后面的属性1,覆盖了前面的属性”1”，<code>temp</code>现在其实只有两个属性，<code>&quot;&quot;</code>和<code>&quot;1&quot;</code>.遍历对象的key，输出每个key的类型，发现都是string.说明就算是数字类型的键，JS内部还会把它转换成字符串.</p>\n<p>所以这种方法其实并不是很适用于一个既有数字又有字符串的数组.因为很可能会出现上面的情况.这也是这种方法的局限性.</p>\n<h2 id=\"第五种\"><a href=\"#第五种\" class=\"headerlink\" title=\"第五种\"></a>第五种</h2><p>利用两个循环来比较，这个效率没上面的其他实现方法高，这里就不写了.</p>"},{"title":"事件流","date":"2018-03-11T16:00:00.000Z","_content":"\n最近在复习，回过头看了一下事件流，将自己的理解和总结写一下.\n\n<!-- more -->\n## 何为事件流\n\n事件流是从页面中接受事件的顺序。\n\n当你点击了页面的一个按钮的同时，你也点击了包括此按钮的容器元素，甚至也可以认为点击了整个页面。\n为了解决这种情况，事件流的概念就诞生了。\n\n事件流分为两种，由两个浏览器开发团队提出，分别是`事件冒泡流`，`事件捕获流`。\n现在的浏览器基本上都实现了这两种事件流模型。\n\n## 事件冒泡\n顾名思义，就是从下往上传播。\n\n在事件开始时，由最具体的元素接收事件，就是嵌套层次最深的那个节点，然后依次往上级元素传播，直到到达顶层对象（现在的浏览器实现都是冒泡到`window`对象） \n\n## 事件捕获\n与冒泡模型相反，捕获模型是从上往下传播。\n\n在事件开始，由顶层对象接收事件，然后沿着DOM树依次向下传播，直到到达事件的实际目标。(浏览器一般也是从window对象开始捕获事件的，)\n\n``` html\n<html>\n    <body>\n        <div>\n            <button type=\"button\" onclick=\"alert('button')\">\n            </button>\n        </div>\n    </body>\n</html>\n```\n\n当你点击button，采用冒泡模型，事件会以如下的顺序传播\n\n1. `<button> -> <div> -> <body> -> <html> -> Document对象 -> window对象`\n\n采用捕获模型，事件会以如下的顺序传播 \n\n2. `window对象 -> Document对象 -> <html> -> <body> -> <div> -> <button>`\n\n## DOM事件流\n\n`DOM2级事件`规定事件流包括三个阶段： `事件捕获阶段`、`处于目标阶段`、`事件冒泡阶段`\n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fpaccm8hakj21hc0u0e82.jpg)\n\n`捕获阶段`只从`window对象`到达`<div>`就停止了，下一个阶段是`目标阶段`，事件在`<button>`上发生，（事件处理会被看成冒泡阶段的一部分），然后冒泡阶段开始，事件由下往上传播。\n\n## 事件处理程序\n一个事件，可以是`click`,也可以是`mouseover`、`DOMContentLoaded`、`load`，详情参考[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Event)\n\n响应一个事件的函数，叫做`事件处理程序`，也可以叫`事件监听器`，当事件发生时，对应的事件处理程序就会执行。\n\n有三种方式可以注册事件监听器\n\n``` html\n<html>\n    <body>\n        <!-- Method 1 -->\n        <div id=\"test\" onclick=\"console.log(\"By Html Attribute\")\">\n        </div>\n    </body>\n    <script>\n        (function register() {\n            var test = document.getElementById('test');\n\n            //Method 2\n            test.onload = function(event) {\n                console.log(\" By DOM Element Attribute\");\n            }\n            //Method 3\n            test.addEventListener(\"mouseover\", function(event) {\n                console.log(\"By addEventListener\");\n            })\n        })()\n    </script>\n</html>\n\n```\n\n## 事件委托\n当页面中的事件处理程序过多的时候，会占用过多内存空间，解决办法就是`事件委托`\n\n`事件委托`利用了事件冒泡，只需要指定一个事件处理程序，就可以管理某一类型的事件。\n\n### 实践\n当你想给每一个li都添加一个事件处理程序时，你需要添加三个事件处理程序，当你添加的事件处理程序过多时，页面的性能会受到影响。\n\n\n使用事件委托，只需在DOM树中**尽量最高的层次**上添加一个事件处理程序，可以有效地减少事件处理程序的数量。\n``` javascript\n<ul id=\"List\">\n    <li id=\"item1\">1</li>\n    <li id=\"item2\">2</li>\n    <li id=\"item3\">3</li>\n</ul>\n\n\nvar list = document.getElementById(\"List\");\n\nlist.addEventListener(\"click\", function(event){\n    var target = event.target || event.srcElement; //兼容写法\n    //事件对象的target属性为一个Element对象，保存着当前点击的目标元素的信息\n    console.log(target)\n}, false)\n\n```\n\n下一篇预告. promise\n\n","source":"_posts/事件流.md","raw":"---\ntitle: 事件流\ncategory: JavaScript\ndate: 2018-3-12\ntags: [JavaScript, Event]\n---\n\n最近在复习，回过头看了一下事件流，将自己的理解和总结写一下.\n\n<!-- more -->\n## 何为事件流\n\n事件流是从页面中接受事件的顺序。\n\n当你点击了页面的一个按钮的同时，你也点击了包括此按钮的容器元素，甚至也可以认为点击了整个页面。\n为了解决这种情况，事件流的概念就诞生了。\n\n事件流分为两种，由两个浏览器开发团队提出，分别是`事件冒泡流`，`事件捕获流`。\n现在的浏览器基本上都实现了这两种事件流模型。\n\n## 事件冒泡\n顾名思义，就是从下往上传播。\n\n在事件开始时，由最具体的元素接收事件，就是嵌套层次最深的那个节点，然后依次往上级元素传播，直到到达顶层对象（现在的浏览器实现都是冒泡到`window`对象） \n\n## 事件捕获\n与冒泡模型相反，捕获模型是从上往下传播。\n\n在事件开始，由顶层对象接收事件，然后沿着DOM树依次向下传播，直到到达事件的实际目标。(浏览器一般也是从window对象开始捕获事件的，)\n\n``` html\n<html>\n    <body>\n        <div>\n            <button type=\"button\" onclick=\"alert('button')\">\n            </button>\n        </div>\n    </body>\n</html>\n```\n\n当你点击button，采用冒泡模型，事件会以如下的顺序传播\n\n1. `<button> -> <div> -> <body> -> <html> -> Document对象 -> window对象`\n\n采用捕获模型，事件会以如下的顺序传播 \n\n2. `window对象 -> Document对象 -> <html> -> <body> -> <div> -> <button>`\n\n## DOM事件流\n\n`DOM2级事件`规定事件流包括三个阶段： `事件捕获阶段`、`处于目标阶段`、`事件冒泡阶段`\n\n![](http://ww1.sinaimg.cn/large/ad9f1193gy1fpaccm8hakj21hc0u0e82.jpg)\n\n`捕获阶段`只从`window对象`到达`<div>`就停止了，下一个阶段是`目标阶段`，事件在`<button>`上发生，（事件处理会被看成冒泡阶段的一部分），然后冒泡阶段开始，事件由下往上传播。\n\n## 事件处理程序\n一个事件，可以是`click`,也可以是`mouseover`、`DOMContentLoaded`、`load`，详情参考[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Event)\n\n响应一个事件的函数，叫做`事件处理程序`，也可以叫`事件监听器`，当事件发生时，对应的事件处理程序就会执行。\n\n有三种方式可以注册事件监听器\n\n``` html\n<html>\n    <body>\n        <!-- Method 1 -->\n        <div id=\"test\" onclick=\"console.log(\"By Html Attribute\")\">\n        </div>\n    </body>\n    <script>\n        (function register() {\n            var test = document.getElementById('test');\n\n            //Method 2\n            test.onload = function(event) {\n                console.log(\" By DOM Element Attribute\");\n            }\n            //Method 3\n            test.addEventListener(\"mouseover\", function(event) {\n                console.log(\"By addEventListener\");\n            })\n        })()\n    </script>\n</html>\n\n```\n\n## 事件委托\n当页面中的事件处理程序过多的时候，会占用过多内存空间，解决办法就是`事件委托`\n\n`事件委托`利用了事件冒泡，只需要指定一个事件处理程序，就可以管理某一类型的事件。\n\n### 实践\n当你想给每一个li都添加一个事件处理程序时，你需要添加三个事件处理程序，当你添加的事件处理程序过多时，页面的性能会受到影响。\n\n\n使用事件委托，只需在DOM树中**尽量最高的层次**上添加一个事件处理程序，可以有效地减少事件处理程序的数量。\n``` javascript\n<ul id=\"List\">\n    <li id=\"item1\">1</li>\n    <li id=\"item2\">2</li>\n    <li id=\"item3\">3</li>\n</ul>\n\n\nvar list = document.getElementById(\"List\");\n\nlist.addEventListener(\"click\", function(event){\n    var target = event.target || event.srcElement; //兼容写法\n    //事件对象的target属性为一个Element对象，保存着当前点击的目标元素的信息\n    console.log(target)\n}, false)\n\n```\n\n下一篇预告. promise\n\n","slug":"事件流","published":1,"updated":"2018-03-12T16:23:47.607Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf81ehhr003av4efummqfjq7","content":"<p>最近在复习，回过头看了一下事件流，将自己的理解和总结写一下.</p>\n<a id=\"more\"></a>\n<h2 id=\"何为事件流\"><a href=\"#何为事件流\" class=\"headerlink\" title=\"何为事件流\"></a>何为事件流</h2><p>事件流是从页面中接受事件的顺序。</p>\n<p>当你点击了页面的一个按钮的同时，你也点击了包括此按钮的容器元素，甚至也可以认为点击了整个页面。<br>为了解决这种情况，事件流的概念就诞生了。</p>\n<p>事件流分为两种，由两个浏览器开发团队提出，分别是<code>事件冒泡流</code>，<code>事件捕获流</code>。<br>现在的浏览器基本上都实现了这两种事件流模型。</p>\n<h2 id=\"事件冒泡\"><a href=\"#事件冒泡\" class=\"headerlink\" title=\"事件冒泡\"></a>事件冒泡</h2><p>顾名思义，就是从下往上传播。</p>\n<p>在事件开始时，由最具体的元素接收事件，就是嵌套层次最深的那个节点，然后依次往上级元素传播，直到到达顶层对象（现在的浏览器实现都是冒泡到<code>window</code>对象） </p>\n<h2 id=\"事件捕获\"><a href=\"#事件捕获\" class=\"headerlink\" title=\"事件捕获\"></a>事件捕获</h2><p>与冒泡模型相反，捕获模型是从上往下传播。</p>\n<p>在事件开始，由顶层对象接收事件，然后沿着DOM树依次向下传播，直到到达事件的实际目标。(浏览器一般也是从window对象开始捕获事件的，)</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"alert('button')\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当你点击button，采用冒泡模型，事件会以如下的顺序传播</p>\n<ol>\n<li><code>&lt;button&gt; -&gt; &lt;div&gt; -&gt; &lt;body&gt; -&gt; &lt;html&gt; -&gt; Document对象 -&gt; window对象</code></li>\n</ol>\n<p>采用捕获模型，事件会以如下的顺序传播 </p>\n<ol>\n<li><code>window对象 -&gt; Document对象 -&gt; &lt;html&gt; -&gt; &lt;body&gt; -&gt; &lt;div&gt; -&gt; &lt;button&gt;</code></li>\n</ol>\n<h2 id=\"DOM事件流\"><a href=\"#DOM事件流\" class=\"headerlink\" title=\"DOM事件流\"></a>DOM事件流</h2><p><code>DOM2级事件</code>规定事件流包括三个阶段： <code>事件捕获阶段</code>、<code>处于目标阶段</code>、<code>事件冒泡阶段</code></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fpaccm8hakj21hc0u0e82.jpg\" alt=\"\"></p>\n<p><code>捕获阶段</code>只从<code>window对象</code>到达<code>&lt;div&gt;</code>就停止了，下一个阶段是<code>目标阶段</code>，事件在<code>&lt;button&gt;</code>上发生，（事件处理会被看成冒泡阶段的一部分），然后冒泡阶段开始，事件由下往上传播。</p>\n<h2 id=\"事件处理程序\"><a href=\"#事件处理程序\" class=\"headerlink\" title=\"事件处理程序\"></a>事件处理程序</h2><p>一个事件，可以是<code>click</code>,也可以是<code>mouseover</code>、<code>DOMContentLoaded</code>、<code>load</code>，详情参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Event\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n<p>响应一个事件的函数，叫做<code>事件处理程序</code>，也可以叫<code>事件监听器</code>，当事件发生时，对应的事件处理程序就会执行。</p>\n<p>有三种方式可以注册事件监听器</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- Method 1 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"test\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"console.log(\"</span><span class=\"attr\">By</span> <span class=\"attr\">Html</span> <span class=\"attr\">Attribute</span>\")\"&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">register</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> test = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'test'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//Method 2</span></span></span><br><span class=\"line\"><span class=\"javascript\">            test.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\" By DOM Element Attribute\"</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//Method 3</span></span></span><br><span class=\"line\"><span class=\"javascript\">            test.addEventListener(<span class=\"string\">\"mouseover\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"By addEventListener\"</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;)()</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"事件委托\"><a href=\"#事件委托\" class=\"headerlink\" title=\"事件委托\"></a>事件委托</h2><p>当页面中的事件处理程序过多的时候，会占用过多内存空间，解决办法就是<code>事件委托</code></p>\n<p><code>事件委托</code>利用了事件冒泡，只需要指定一个事件处理程序，就可以管理某一类型的事件。</p>\n<h3 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h3><p>当你想给每一个li都添加一个事件处理程序时，你需要添加三个事件处理程序，当你添加的事件处理程序过多时，页面的性能会受到影响。</p>\n<p>使用事件委托，只需在DOM树中<strong>尽量最高的层次</strong>上添加一个事件处理程序，可以有效地减少事件处理程序的数量。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul id=<span class=\"string\">\"List\"</span>&gt;</span><br><span class=\"line\">    &lt;li id=<span class=\"string\">\"item1\"</span>&gt;<span class=\"number\">1</span>&lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;li id=\"item2\"&gt;2&lt;/</span>li&gt;</span><br><span class=\"line\">    &lt;li id=<span class=\"string\">\"item3\"</span>&gt;<span class=\"number\">3</span>&lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/u</span>l&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"List\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">list.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> target = event.target || event.srcElement; <span class=\"comment\">//兼容写法</span></span><br><span class=\"line\">    <span class=\"comment\">//事件对象的target属性为一个Element对象，保存着当前点击的目标元素的信息</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(target)</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>)</span><br></pre></td></tr></table></figure></p>\n<p>下一篇预告. promise</p>\n","site":{"data":{}},"excerpt":"<p>最近在复习，回过头看了一下事件流，将自己的理解和总结写一下.</p>","more":"<h2 id=\"何为事件流\"><a href=\"#何为事件流\" class=\"headerlink\" title=\"何为事件流\"></a>何为事件流</h2><p>事件流是从页面中接受事件的顺序。</p>\n<p>当你点击了页面的一个按钮的同时，你也点击了包括此按钮的容器元素，甚至也可以认为点击了整个页面。<br>为了解决这种情况，事件流的概念就诞生了。</p>\n<p>事件流分为两种，由两个浏览器开发团队提出，分别是<code>事件冒泡流</code>，<code>事件捕获流</code>。<br>现在的浏览器基本上都实现了这两种事件流模型。</p>\n<h2 id=\"事件冒泡\"><a href=\"#事件冒泡\" class=\"headerlink\" title=\"事件冒泡\"></a>事件冒泡</h2><p>顾名思义，就是从下往上传播。</p>\n<p>在事件开始时，由最具体的元素接收事件，就是嵌套层次最深的那个节点，然后依次往上级元素传播，直到到达顶层对象（现在的浏览器实现都是冒泡到<code>window</code>对象） </p>\n<h2 id=\"事件捕获\"><a href=\"#事件捕获\" class=\"headerlink\" title=\"事件捕获\"></a>事件捕获</h2><p>与冒泡模型相反，捕获模型是从上往下传播。</p>\n<p>在事件开始，由顶层对象接收事件，然后沿着DOM树依次向下传播，直到到达事件的实际目标。(浏览器一般也是从window对象开始捕获事件的，)</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"alert('button')\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当你点击button，采用冒泡模型，事件会以如下的顺序传播</p>\n<ol>\n<li><code>&lt;button&gt; -&gt; &lt;div&gt; -&gt; &lt;body&gt; -&gt; &lt;html&gt; -&gt; Document对象 -&gt; window对象</code></li>\n</ol>\n<p>采用捕获模型，事件会以如下的顺序传播 </p>\n<ol>\n<li><code>window对象 -&gt; Document对象 -&gt; &lt;html&gt; -&gt; &lt;body&gt; -&gt; &lt;div&gt; -&gt; &lt;button&gt;</code></li>\n</ol>\n<h2 id=\"DOM事件流\"><a href=\"#DOM事件流\" class=\"headerlink\" title=\"DOM事件流\"></a>DOM事件流</h2><p><code>DOM2级事件</code>规定事件流包括三个阶段： <code>事件捕获阶段</code>、<code>处于目标阶段</code>、<code>事件冒泡阶段</code></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ad9f1193gy1fpaccm8hakj21hc0u0e82.jpg\" alt=\"\"></p>\n<p><code>捕获阶段</code>只从<code>window对象</code>到达<code>&lt;div&gt;</code>就停止了，下一个阶段是<code>目标阶段</code>，事件在<code>&lt;button&gt;</code>上发生，（事件处理会被看成冒泡阶段的一部分），然后冒泡阶段开始，事件由下往上传播。</p>\n<h2 id=\"事件处理程序\"><a href=\"#事件处理程序\" class=\"headerlink\" title=\"事件处理程序\"></a>事件处理程序</h2><p>一个事件，可以是<code>click</code>,也可以是<code>mouseover</code>、<code>DOMContentLoaded</code>、<code>load</code>，详情参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Event\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n<p>响应一个事件的函数，叫做<code>事件处理程序</code>，也可以叫<code>事件监听器</code>，当事件发生时，对应的事件处理程序就会执行。</p>\n<p>有三种方式可以注册事件监听器</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- Method 1 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"test\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"console.log(\"</span><span class=\"attr\">By</span> <span class=\"attr\">Html</span> <span class=\"attr\">Attribute</span>\")\"&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">register</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> test = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'test'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//Method 2</span></span></span><br><span class=\"line\"><span class=\"javascript\">            test.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\" By DOM Element Attribute\"</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//Method 3</span></span></span><br><span class=\"line\"><span class=\"javascript\">            test.addEventListener(<span class=\"string\">\"mouseover\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"By addEventListener\"</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;)()</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"事件委托\"><a href=\"#事件委托\" class=\"headerlink\" title=\"事件委托\"></a>事件委托</h2><p>当页面中的事件处理程序过多的时候，会占用过多内存空间，解决办法就是<code>事件委托</code></p>\n<p><code>事件委托</code>利用了事件冒泡，只需要指定一个事件处理程序，就可以管理某一类型的事件。</p>\n<h3 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h3><p>当你想给每一个li都添加一个事件处理程序时，你需要添加三个事件处理程序，当你添加的事件处理程序过多时，页面的性能会受到影响。</p>\n<p>使用事件委托，只需在DOM树中<strong>尽量最高的层次</strong>上添加一个事件处理程序，可以有效地减少事件处理程序的数量。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul id=<span class=\"string\">\"List\"</span>&gt;</span><br><span class=\"line\">    &lt;li id=<span class=\"string\">\"item1\"</span>&gt;<span class=\"number\">1</span>&lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;li id=\"item2\"&gt;2&lt;/</span>li&gt;</span><br><span class=\"line\">    &lt;li id=<span class=\"string\">\"item3\"</span>&gt;<span class=\"number\">3</span>&lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/u</span>l&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"List\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">list.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> target = event.target || event.srcElement; <span class=\"comment\">//兼容写法</span></span><br><span class=\"line\">    <span class=\"comment\">//事件对象的target属性为一个Element对象，保存着当前点击的目标元素的信息</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(target)</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>)</span><br></pre></td></tr></table></figure></p>\n<p>下一篇预告. promise</p>"},{"title":"给自己的博客加个小绿锁(使用netlify)","_content":"\ntest\n<!-- more -->","source":"_posts/netlify.md","raw":"---\ntitle: 给自己的博客加个小绿锁(使用netlify)\ncategory: HTTPS\ntags: [Blog, HTTPS]\n---\n\ntest\n<!-- more -->","slug":"netlify","published":1,"date":"2018-03-26T13:57:04.173Z","updated":"2018-03-26T14:04:52.543Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf8be7oh0000zoefg3qc5i3o","content":"<p>test<br><a id=\"more\"></a></p>\n","site":{"data":{}},"excerpt":"<p>test<br>","more":"</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjf81eh6e0000v4efm1t4gs23","category_id":"cjf81eh6x0002v4ef3kyrkuso","_id":"cjf81eh7q000bv4efk1a7cryq"},{"post_id":"cjf81eh6o0001v4ef7fy5ruwh","category_id":"cjf81eh7h0007v4efz0ilu29t","_id":"cjf81eh7y000gv4efvfeuj55i"},{"post_id":"cjf81eh730004v4ef4ep3hwuh","category_id":"cjf81eh7q000cv4efx22cyrx1","_id":"cjf81eh89000ov4efbzkuiu5r"},{"post_id":"cjf81eh7v000fv4ef7ohn5v69","category_id":"cjf81eh7q000cv4efx22cyrx1","_id":"cjf81eh8e000sv4efdon8cxbm"},{"post_id":"cjf81eh770005v4efv6d2vkoo","category_id":"cjf81eh7q000cv4efx22cyrx1","_id":"cjf81eh8i000uv4efq6tjoupy"},{"post_id":"cjf81eh7f0006v4eff723l019","category_id":"cjf81eh89000nv4ef85ggovjm","_id":"cjf81eh8q0010v4efkdr4jwgv"},{"post_id":"cjf81eh8e000tv4efx4ayngej","category_id":"cjf81eh7q000cv4efx22cyrx1","_id":"cjf81eh8v0015v4efk7auiwox"},{"post_id":"cjf81eh8o000zv4efccaxyhfe","category_id":"cjf81eh7q000cv4efx22cyrx1","_id":"cjf81eh8z0018v4efq7kqcxn5"},{"post_id":"cjf81eh7j0009v4efjvnc2qfd","category_id":"cjf81eh8j000vv4efqg8hyebb","_id":"cjf81eh96001cv4efn8u5oq0h"},{"post_id":"cjf81eh8w0016v4efqzb7tvmj","category_id":"cjf81eh7q000cv4efx22cyrx1","_id":"cjf81eh99001fv4ef4s4wzntu"},{"post_id":"cjf81eh7n000av4ef08apzmei","category_id":"cjf81eh8t0013v4ef6fp77pbb","_id":"cjf81eh9c001jv4efqpx5l8wb"},{"post_id":"cjf81eh8y0017v4ef76vs7sy4","category_id":"cjf81eh7q000cv4efx22cyrx1","_id":"cjf81eh9c001kv4ef0ndyesqr"},{"post_id":"cjf81eh7r000ev4ef1j33bg5g","category_id":"cjf81eh910019v4efqmjisdd4","_id":"cjf81eh9d001nv4efvdij0kfz"},{"post_id":"cjf81eh85000lv4eflu6hqkes","category_id":"cjf81eh9b001hv4ef7lbwhngz","_id":"cjf81eh9f001qv4ef3tarbjub"},{"post_id":"cjf81eh8a000qv4efialwuas4","category_id":"cjf81eh9c001lv4ef4arqc0xs","_id":"cjf81eh9h001tv4efq7o3mlj3"},{"post_id":"cjf81eh8j000wv4ef530tb9te","category_id":"cjf81eh9f001rv4efim1l1jzz","_id":"cjf81eh9k001yv4efh8bo1blw"},{"post_id":"cjf81eh8r0012v4efkj7wy9u7","category_id":"cjf81eh9i001uv4eftdtszu4b","_id":"cjf81eh9m0021v4efjrhsh13o"},{"post_id":"cjf81eh93001bv4efahyy8okn","category_id":"cjf81eh9k001zv4efdbi07dfg","_id":"cjf81eh9o0026v4ef9caxgero"},{"post_id":"cjf81eh97001ev4ef44fci6hm","category_id":"cjf81eh9n0022v4efa5pl9tm9","_id":"cjf81eh9s0029v4efjq4hepkr"},{"post_id":"cjf81ehhd0036v4efr2xsin8o","category_id":"cjf81eh7q000cv4efx22cyrx1","_id":"cjf81ehhx003cv4ef29w6b6eo"},{"post_id":"cjf81ehhr003av4efummqfjq7","category_id":"cjf81eh7q000cv4efx22cyrx1","_id":"cjf81ehhy003fv4efulrkopnn"},{"post_id":"cjf81ehh80034v4ef995rp501","category_id":"cjf81ehhq0038v4efmv678fgw","_id":"cjf81ehhz003hv4efyhzaw6tn"},{"post_id":"cjf8be7oh0000zoefg3qc5i3o","category_id":"cjf81eh89000nv4ef85ggovjm","_id":"cjf8be7pj0002zoefv0q7q2o7"}],"PostTag":[{"post_id":"cjf81eh6e0000v4efm1t4gs23","tag_id":"cjf81eh720003v4efv6dkgh4b","_id":"cjf81eh84000kv4efgpcrd6ld"},{"post_id":"cjf81eh6e0000v4efm1t4gs23","tag_id":"cjf81eh7i0008v4efq20viqdq","_id":"cjf81eh88000mv4efzg6n8qos"},{"post_id":"cjf81eh6e0000v4efm1t4gs23","tag_id":"cjf81eh7q000dv4efct2qbpy5","_id":"cjf81eh8d000rv4ef1f5zvcpq"},{"post_id":"cjf81eh6o0001v4ef7fy5ruwh","tag_id":"cjf81eh7z000iv4eflx1awxb2","_id":"cjf81eh8o000yv4efkxk5xlhw"},{"post_id":"cjf81eh6o0001v4ef7fy5ruwh","tag_id":"cjf81eh8a000pv4efw45qlk0p","_id":"cjf81eh8q0011v4efnk39js1u"},{"post_id":"cjf81eh730004v4ef4ep3hwuh","tag_id":"cjf81eh8n000xv4efqorun0ca","_id":"cjf81eh97001dv4efzmt6ejkf"},{"post_id":"cjf81eh730004v4ef4ep3hwuh","tag_id":"cjf81eh8u0014v4eftubwrhjq","_id":"cjf81eh9b001gv4eflq3eak9a"},{"post_id":"cjf81eh770005v4efv6d2vkoo","tag_id":"cjf81eh8n000xv4efqorun0ca","_id":"cjf81eh9e001ov4ef6as7led5"},{"post_id":"cjf81eh770005v4efv6d2vkoo","tag_id":"cjf81eh9b001iv4efhlg2nmcx","_id":"cjf81eh9e001pv4ef2xf0fmkz"},{"post_id":"cjf81eh7f0006v4eff723l019","tag_id":"cjf81eh9c001mv4efw2evtn1l","_id":"cjf81eh9k001wv4efdmzxvn1j"},{"post_id":"cjf81eh7f0006v4eff723l019","tag_id":"cjf81eh9f001sv4efks44dtbx","_id":"cjf81eh9k001xv4ef5h2u6ea6"},{"post_id":"cjf81eh7n000av4ef08apzmei","tag_id":"cjf81eh9j001vv4efjl4lg05n","_id":"cjf81eh9o0024v4efi799ncc7"},{"post_id":"cjf81eh7n000av4ef08apzmei","tag_id":"cjf81eh9l0020v4efn17oekpl","_id":"cjf81eh9o0025v4efwnf1xsqi"},{"post_id":"cjf81eh7r000ev4ef1j33bg5g","tag_id":"cjf81eh9n0023v4efdcklfm6i","_id":"cjf81eh9q0028v4ef6bdqjb3i"},{"post_id":"cjf81eh7v000fv4ef7ohn5v69","tag_id":"cjf81eh8n000xv4efqorun0ca","_id":"cjf81eh9v002cv4eftvsl7jer"},{"post_id":"cjf81eh7v000fv4ef7ohn5v69","tag_id":"cjf81eh9b001iv4efhlg2nmcx","_id":"cjf81eh9v002dv4efiqruqj9m"},{"post_id":"cjf81eh85000lv4eflu6hqkes","tag_id":"cjf81eh9u002bv4efjc7wwnac","_id":"cjf81eh9w002gv4efawvmkorx"},{"post_id":"cjf81eh85000lv4eflu6hqkes","tag_id":"cjf81eh9v002ev4ef9orwozy0","_id":"cjf81eh9x002hv4efytxx1kmw"},{"post_id":"cjf81eh8a000qv4efialwuas4","tag_id":"cjf81eh9w002fv4efh2hxqicw","_id":"cjf81eh9y002lv4ef7fs3lpv1"},{"post_id":"cjf81eh8a000qv4efialwuas4","tag_id":"cjf81eh9x002iv4efdxfpo2ef","_id":"cjf81eh9y002mv4efxxfmexie"},{"post_id":"cjf81eh8a000qv4efialwuas4","tag_id":"cjf81eh9x002jv4ef1kqmaeo5","_id":"cjf81eh9z002ov4eftso372w4"},{"post_id":"cjf81eh8e000tv4efx4ayngej","tag_id":"cjf81eh9y002kv4efb556u01q","_id":"cjf81eh9z002pv4efvjyw1j4m"},{"post_id":"cjf81eh8j000wv4ef530tb9te","tag_id":"cjf81eh9w002fv4efh2hxqicw","_id":"cjf81eha0002rv4efedpy2e62"},{"post_id":"cjf81eh8o000zv4efccaxyhfe","tag_id":"cjf81eh9z002qv4ef53m1xgdk","_id":"cjf81eha1002tv4efau2i9lvj"},{"post_id":"cjf81eh8w0016v4efqzb7tvmj","tag_id":"cjf81eh8n000xv4efqorun0ca","_id":"cjf81eha2002vv4efdlnbwu1b"},{"post_id":"cjf81eh8w0016v4efqzb7tvmj","tag_id":"cjf81eh9y002kv4efb556u01q","_id":"cjf81eha2002wv4efae2xvhch"},{"post_id":"cjf81eh8y0017v4ef76vs7sy4","tag_id":"cjf81eha1002uv4efoo89151p","_id":"cjf81eha3002yv4ef9sgodln1"},{"post_id":"cjf81eh93001bv4efahyy8okn","tag_id":"cjf81eh720003v4efv6dkgh4b","_id":"cjf81eha50030v4ef0q0qu1zn"},{"post_id":"cjf81eh93001bv4efahyy8okn","tag_id":"cjf81eh7i0008v4efq20viqdq","_id":"cjf81eha50031v4efo2m3b7jp"},{"post_id":"cjf81eh93001bv4efahyy8okn","tag_id":"cjf81eha3002xv4efk1savp9p","_id":"cjf81eha60032v4ef78an7ddt"},{"post_id":"cjf81eh97001ev4ef44fci6hm","tag_id":"cjf81eha4002zv4ef250a2zbi","_id":"cjf81eha60033v4efdkqhb8vv"},{"post_id":"cjf81ehh80034v4ef995rp501","tag_id":"cjf81ehhr0039v4ef1gw4sm3j","_id":"cjf81ehhy003ev4efy8latq0w"},{"post_id":"cjf81ehh80034v4ef995rp501","tag_id":"cjf81eh8n000xv4efqorun0ca","_id":"cjf81ehhz003gv4efpsm4mb2a"},{"post_id":"cjf81ehhd0036v4efr2xsin8o","tag_id":"cjf81ehhx003dv4efilfkblbw","_id":"cjf81ehi0003jv4efptw2axs4"},{"post_id":"cjf81ehhr003av4efummqfjq7","tag_id":"cjf81eh8n000xv4efqorun0ca","_id":"cjf81ehi1003kv4effvto00g3"},{"post_id":"cjf81ehhr003av4efummqfjq7","tag_id":"cjf81ehhz003iv4efrpxxnifo","_id":"cjf81ehi2003lv4efy1kmotrp"},{"post_id":"cjf8be7oh0000zoefg3qc5i3o","tag_id":"cjf8be7oz0001zoefrgmp0kfm","_id":"cjf8be7pk0003zoef6mtpfsiq"},{"post_id":"cjf8be7oh0000zoefg3qc5i3o","tag_id":"cjf81eh9c001mv4efw2evtn1l","_id":"cjf8be7pk0004zoefdavicwmu"}],"Tag":[{"name":"暑假","_id":"cjf81eh720003v4efv6dkgh4b"},{"name":"夏令营","_id":"cjf81eh7i0008v4efq20viqdq"},{"name":"协同前端组","_id":"cjf81eh7q000dv4efct2qbpy5"},{"name":"协同主页","_id":"cjf81eh7z000iv4eflx1awxb2"},{"name":"总结","_id":"cjf81eh8a000pv4efw45qlk0p"},{"name":"JavaScript","_id":"cjf81eh8n000xv4efqorun0ca"},{"name":"模拟实现","_id":"cjf81eh8u0014v4eftubwrhjq"},{"name":"Function","_id":"cjf81eh9b001iv4efhlg2nmcx"},{"name":"HTTPS","_id":"cjf81eh9c001mv4efw2evtn1l"},{"name":"网络","_id":"cjf81eh9f001sv4efks44dtbx"},{"name":"Ubuntu","_id":"cjf81eh9j001vv4efjl4lg05n"},{"name":"Shadowsocks","_id":"cjf81eh9l0020v4efn17oekpl"},{"name":"canvas","_id":"cjf81eh9n0023v4efdcklfm6i"},{"name":"数据库","_id":"cjf81eh9u002bv4efjc7wwnac"},{"name":"课设","_id":"cjf81eh9v002ev4ef9orwozy0"},{"name":"hexo","_id":"cjf81eh9w002fv4efh2hxqicw"},{"name":"笔记","_id":"cjf81eh9x002iv4efdxfpo2ef"},{"name":"HTTP缓存","_id":"cjf81eh9x002jv4ef1kqmaeo5"},{"name":"Object","_id":"cjf81eh9y002kv4efb556u01q"},{"name":"继承","_id":"cjf81eh9z002qv4ef53m1xgdk"},{"name":"原型模式","_id":"cjf81eha1002uv4efoo89151p"},{"name":"2017","_id":"cjf81eha3002xv4efk1savp9p"},{"name":"前端工程化","_id":"cjf81eha4002zv4ef250a2zbi"},{"name":"Vue","_id":"cjf81ehhr0039v4ef1gw4sm3j"},{"name":"Array","_id":"cjf81ehhx003dv4efilfkblbw"},{"name":"Event","_id":"cjf81ehhz003iv4efrpxxnifo"},{"name":"Blog","_id":"cjf8be7oz0001zoefrgmp0kfm"}]}}